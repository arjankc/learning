<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>C#/.NET Learning Notes (Compiled)</title>
    <style>
        :root { --ink: #111; --muted: #666; }
        body { color: var(--ink); font-family: -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.55; max-width: 900px; margin: 1rem auto; padding: 0 1rem; }
        code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        pre { background: #f6f8fa; padding: 12px; overflow: auto; border-radius: 6px; }
        h1 { font-size: 1.9rem; margin-top: 2.2rem; }
        h2 { font-size: 1.5rem; margin-top: 1.8rem; }
        h3 { font-size: 1.2rem; margin-top: 1.4rem; }
        hr { margin: 2rem 0; }
    /* page-break removed to allow continuous flow */
        .toc h1 { margin-top: 0; }
        @media print {
            @page { margin: 16mm 12mm; size: A4; }
            body { margin: 0; }
            header, footer { position: fixed; left: 0; right: 0; color: var(--muted); font-size: 10pt; }
            header { top: 0; }
            footer { bottom: 0; }
            footer .page:after { content: counter(page); }
            pre { white-space: pre-wrap; }
            /* Don't append URLs after links to save space */
            a[href]:after { content: ""; }
        }
    </style>
</head>
<body>
<header></header>
<footer><span class="page"></span></footer>
<h1 id="c.net-learning-notes">C#/.NET Learning Notes</h1>
<p>Compiled for offline study and printing. Start with the Study Guide.</p>
<ul>
<li><a href="00-study-guide.md">Study Guide: C#/.NET Exam Prep</a></li>
<li><a href="01-csharp-basics/01-data-types.md">C# Basics: Data Types (Primitive, Value vs Reference)</a></li>
<li><a href="01-csharp-basics/02-variables-operators-expressions.md">C# Basics: Variables, Operators, and Expressions</a></li>
<li><a href="01-csharp-basics/03-type-conversion.md">Type Conversion in C# (Implicit/Explicit, Boxing/Unboxing)</a></li>
<li><a href="01-csharp-basics/04-namespaces.md">Namespaces in C#</a></li>
<li><a href="02-flow-control/01-branching.md">Branching in C# (if/else, switch)</a></li>
<li><a href="02-flow-control/02-looping.md">Looping in C# (for, while, foreach)</a></li>
<li><a href="02-flow-control/03-iterators.md">Iterators and <code>yield</code></a></li>
<li><a href="03-dotnet-ecosystem/01-clr.md">Common Language Runtime (CLR)</a></li>
<li><a href="03-dotnet-ecosystem/02-fcl.md">.NET Framework Class Library (BCL/FCL)</a></li>
<li><a href="03-dotnet-ecosystem/03-ide-setup.md">IDE Setup (Visual Studio / VS Code)</a></li>
<li><a href="04-oop/01-classes-objects.md">Classes and Objects</a></li>
<li><a href="04-oop/02-oop-principles.md">OOP Principles</a></li>
<li><a href="04-oop/03-advanced-oop.md">Advanced OOP</a></li>
<li><a href="05-collections/01-built-in.md">Built-in Collections</a></li>
<li><a href="05-collections/02-custom.md">Custom Collections</a></li>
<li><a href="06-error-debugging/01-exceptions.md">Exception Handling</a></li>
<li><a href="06-error-debugging/02-custom-exceptions.md">Custom Exceptions</a></li>
<li><a href="06-error-debugging/03-debugging.md">Debugging Techniques</a></li>
<li><a href="07-advanced-csharp/01-delegates-events.md">Delegates and Events</a></li>
<li><a href="07-advanced-csharp/02-linq.md">LINQ</a></li>
<li><a href="07-advanced-csharp/03-async.md">Asynchronous Programming</a></li>
<li><a href="08-data-access/01-ado-net.md">ADO.NET</a></li>
<li><a href="08-data-access/02-ef-core.md">Entity Framework Core</a></li>
<li><a href="08-data-access/03-file-io.md">File I/O</a></li>
<li><a href="09-wpf/01-xaml-basics.md">WPF: XAML Basics</a></li>
<li><a href="09-wpf/02-advanced-wpf.md">WPF: Advanced</a></li>
<li><a href="10-web/01-aspnet-core.md">ASP.NET Core Fundamentals</a></li>
<li><a href="10-web/02-blazor.md">Blazor</a></li>
<li><a href="10-web/03-security.md">Web Security</a></li>
<li><a href="10-web/04-razor-pages-vs-mvc.md">Razor Pages vs MVC in ASP.NET Core</a></li>
<li><a href="11-cross-platform/01-xamarin-forms.md">Xamarin.Forms</a></li>
<li><a href="11-cross-platform/02-mobile-features.md">Mobile Features</a></li>
<li><a href="11-cross-platform/03-maui-intro.md">.NET MAUI Intro</a></li>
<li><a href="12-devops/01-cloud-deployment.md">Cloud Deployment</a></li>
<li><a href="12-devops/02-ci-cd.md">CI/CD Pipelines</a></li>
<li><a href="12-devops/03-docker-containers.md">Docker Containers for .NET Apps</a></li>
<li><a href="99-exam-cram.md">Exam Cram: C#/.NET Quick Reference</a></li>
</ul>
<h1 id="study-guide-c.net-exam-prep">Study Guide: C#/.NET Exam Prep</h1>
<p>Use this as your roadmap. Tiers reflect priority: Tier 1 first, then Tier 2, then Tier 3.</p>
<h2 id="how-to-study">How to study</h2>
<ul>
<li>Read the theory, then type out the examples yourself.</li>
<li>After each section, answer the “Check yourself” questions without looking.</li>
<li>Spaced repetition: revisit weak spots after 1–2 days.</li>
<li>Practice: small katas; then build a tiny app that touches multiple topics.</li>
</ul>
<h2 id="suggested-sequence-23-weeks">Suggested sequence (2–3 weeks)</h2>
<ol>
<li>Tier 1 (Days 1–7): C# Basics, Flow, .NET ecosystem, OOP, Collections, Exceptions/Debugging.</li>
<li>Tier 2 (Days 8–13): Delegates/Events, LINQ, Async, ADO.NET/EF Core, File I/O, WPF basics.</li>
<li>Tier 3 (Days 14–18): ASP.NET Core, Blazor, Security, Mobile/Xamarin/MAUI, DevOps.</li>
</ol>
<h2 id="check-yourself-sample-prompts">Check yourself (sample prompts)</h2>
<ul>
<li>Explain value vs reference semantics; show a bug that arises from misunderstanding them.</li>
<li>When would you use yield? Show a lazy pipeline over a large file.</li>
<li>Demonstrate inheritance vs composition; when is each preferable?</li>
<li>Write a LINQ query for: top 3 items per group; inner join vs group join difference.</li>
<li>Show async/await with cancellation and explain why async void is dangerous.</li>
<li>ADO.NET vs EF Core: trade-offs and when to choose each.</li>
<li>WPF binding modes and validation: set up TwoWay binding with validation.</li>
</ul>
<p>Good luck—keep it small, steady, and hands-on.</p>
<hr />
<h1 id="c-basics-data-types-primitive-value-vs-reference">C# Basics: Data Types (Primitive, Value vs Reference)</h1>
<h2 id="what-are-data-types">What are Data Types?</h2>
<p>Data types define the kind of data a variable can hold in a programming language. In C#, data types are crucial because they determine how much memory is allocated and what operations can be performed on the data.</p>
<h2 id="categories-of-data-types-in-c">Categories of Data Types in C#</h2>
<ol>
<li>Primitive (Built-in) Types: These are basic types provided by the language, such as int, double, char, and bool.</li>
<li>Value Types: These types store data directly. Examples include all primitive types (except string), structs, and enums. Value types are usually stored on the stack.</li>
<li>Reference Types: These types store a reference (address) to the actual data. Examples include string, arrays, classes, and delegates. Reference types are stored on the heap, and variables hold a reference to the memory location.</li>
</ol>
<h2 id="value-vs-reference-types">Value vs Reference Types</h2>
<ul>
<li>Value Types: When you assign a value type variable to another, a copy of the value is made. Changes to one variable do not affect the other.</li>
<li>Reference Types: When you assign a reference type variable to another, both variables refer to the same object in memory. Changes to one variable affect the other.</li>
</ul>
<h2 id="why-is-this-important">Why is this important?</h2>
<p>Understanding the difference helps you predict how your data will behave when passed to methods or assigned to new variables, which is essential for writing bug-free code.</p>
<h2 id="examples">Examples</h2>
<p>Value copy vs reference sharing:</p>
<pre><code class="language-csharp">// Value types: copy the value
int a = 42;
int b = a;    // copy
b++;
// a == 42, b == 43

// Reference types: copy the reference
int[] arr1 = { 1, 2, 3 };
int[] arr2 = arr1;  // same reference
arr2[0] = 99;
// arr1[0] == 99 and arr2[0] == 99

// Strings are reference types but immutable
string s1 = &quot;hello&quot;;
string s2 = s1;
s2 = s2.ToUpperInvariant();
// s1 == &quot;hello&quot; (unchanged), s2 == &quot;HELLO&quot;
</code></pre>
<p>Tip: prefer small, immutable structs for simple data; use classes for entities with identity and shared references.</p>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li>Microsoft Docs: Types in C#: <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/built-in-types">https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/built-in-types</a></li>
<li>Microsoft Docs: Value Types and Reference Types: <a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/types/">https://learn.microsoft.com/dotnet/csharp/programming-guide/types/</a></li>
</ul>
<hr />
<h1 id="c-basics-variables-operators-and-expressions">C# Basics: Variables, Operators, and Expressions</h1>
<h2 id="variables">Variables</h2>
<p>Variables are named storage locations in memory that hold data. In C#, you must declare a variable with a specific data type before using it. This helps the compiler allocate the right amount of memory and enforce type safety.</p>
<h3 id="key-points">Key Points:</h3>
<ul>
<li>Variables must be declared before use.</li>
<li>The data type determines what kind of data the variable can store.</li>
<li>Variable names should be descriptive and follow C# naming conventions (camelCase for local variables).</li>
</ul>
<h2 id="operators">Operators</h2>
<p>Operators are symbols that perform operations on variables and values. C# includes several types of operators:</p>
<ul>
<li>Arithmetic Operators: For mathematical operations (e.g., +, -, *, /, %)</li>
<li>Assignment Operators: For assigning values (e.g., =, +=, -=)</li>
<li>Comparison Operators: For comparing values (e.g., ==, !=, &lt;, &gt;, &lt;=, &gt;=)</li>
<li>Logical Operators: For logical operations (e.g., &amp;&amp;, ||, !)</li>
</ul>
<h2 id="expressions">Expressions</h2>
<p>An expression is a combination of variables, values, and operators that produces a result. For example, a + b is an expression that adds two variables.</p>
<h3 id="examples-1">Examples</h3>
<p>Declarations and arithmetic:</p>
<pre><code class="language-csharp">int x = 10, y = 3;
int sum = x + y;     // 13
int product = x * y; // 30
int quotient = x / y;  // 3 (integer division)
int remainder = x % y; // 1
</code></pre>
<p>Comparison and logical:</p>
<pre><code class="language-csharp">bool isGreater = x &gt; y;              // true
bool bothPositive = (x &gt; 0) &amp;&amp; (y &gt; 0); // true
bool eitherLarge = (x &gt;= 10) || (y &gt;= 10); // true
</code></pre>
<p>Precedence and grouping:</p>
<pre><code class="language-csharp">int result = x + y * 2;   // 10 + 3*2 = 16
int clearer = (x + y) * 2; // 26
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<ul>
<li>Use meaningful variable names.</li>
<li>Keep expressions simple and readable.</li>
<li>Use parentheses to clarify complex expressions.</li>
</ul>
<h2 id="further-reading-1">Further Reading</h2>
<ul>
<li>Microsoft Docs: Variables: <a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/variables/">https://learn.microsoft.com/dotnet/csharp/programming-guide/variables/</a></li>
<li>Microsoft Docs: Operators: <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/">https://learn.microsoft.com/dotnet/csharp/language-reference/operators/</a></li>
<li>Microsoft Docs: Expressions: <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/operators/expressions">https://learn.microsoft.com/dotnet/csharp/language-reference/operators/expressions</a></li>
</ul>
<hr />
<h1 id="type-conversion-in-c-implicitexplicit-boxingunboxing">Type Conversion in C# (Implicit/Explicit, Boxing/Unboxing)</h1>
<h2 id="why-conversion-matters">Why Conversion Matters</h2>
<p>C# is statically typed, so types must match. Conversions let values move between compatible types with predictable behavior.</p>
<h2 id="implicit-vs-explicit-conversion">Implicit vs Explicit Conversion</h2>
<ul>
<li>Implicit conversions are safe and lossless (e.g., smaller numeric type to larger). The compiler applies them automatically.</li>
<li>Explicit conversions require intent because information may be lost or the conversion may fail at runtime.</li>
</ul>
<h2 id="numeric-conversions">Numeric Conversions</h2>
<ul>
<li>Widening (safe): smaller range/precision to larger range/precision.</li>
<li>Narrowing (risky): larger to smaller; may overflow, truncate, or throw at runtime if checked.</li>
</ul>
<h2 id="reference-conversions">Reference Conversions</h2>
<ul>
<li>Upcast (derived to base) is safe conceptually.</li>
<li>Downcast (base to derived) requires runtime type compatibility.</li>
</ul>
<h2 id="boxingunboxing">Boxing/Unboxing</h2>
<ul>
<li>Boxing: wrapping a value type instance as an object to treat it as a reference type.</li>
<li>Unboxing: extracting the value type from an object; requires the exact original value type.</li>
<li>Performance note: boxing allocates on the heap and can pressure GC; avoid in hot paths.</li>
</ul>
<h2 id="best-practices-1">Best Practices</h2>
<ul>
<li>Prefer implicit conversions when they are guaranteed safe.</li>
<li>Be explicit and intentional with narrowing conversions; validate ranges.</li>
<li>Minimize boxing by using generics and avoiding APIs that require object.</li>
</ul>
<h2 id="examples-2">Examples</h2>
<p>Implicit vs explicit and overflow checking:</p>
<pre><code class="language-csharp">int small = 123;
long bigger = small; // implicit widening

double pi = 3.14;
int truncated = (int)pi; // explicit narrowing =&gt; 3

try
{
	checked
	{
		int max = int.MaxValue;
		int overflow = max + 1; // throws OverflowException in checked context
	}
}
catch (OverflowException)
{
	// handle
}

// Boxing/unboxing
object boxed = small;         // boxing
int unboxed = (int)boxed;     // unboxing
</code></pre>
<hr />
<h1 id="namespaces-in-c">Namespaces in C#</h1>
<h2 id="purpose-of-namespaces">Purpose of Namespaces</h2>
<p>Namespaces organize types and prevent naming collisions across libraries and projects.</p>
<h2 id="key-concepts">Key Concepts</h2>
<ul>
<li>Logical grouping: types with related purpose live together.</li>
<li>Disambiguation: identical type names can coexist in different namespaces.</li>
<li>Using directives: bring a namespace into scope to shorten type names.</li>
<li>Aliases: assign a local alias to a type or namespace to avoid ambiguity.</li>
</ul>
<h2 id="design-tips">Design Tips</h2>
<ul>
<li>Mirror folder structure with namespaces for clarity.</li>
<li>Use company/product root (e.g., Company.Product.Module).</li>
<li>Avoid deep nesting unless it communicates meaningful boundaries.</li>
</ul>
<h2 id="examples-3">Examples</h2>
<p>Using directives and aliases:</p>
<pre><code class="language-csharp">using System.Text;                 // bring types into scope
using Col = System.Collections.Generic; // alias

namespace Demo.Project;

public class Example
{
	public string JoinWords(Col.List&lt;string&gt; words)
		=&gt; string.Join(' ', words);
}
</code></pre>
<p>Disambiguation with fully-qualified names:</p>
<pre><code class="language-csharp">// If two types have the same name in different namespaces
global::System.Uri uri = new(&quot;https://example.com&quot;);
</code></pre>
<hr />
<h1 id="branching-in-c-ifelse-switch">Branching in C# (if/else, switch)</h1>
<h2 id="what-and-why">What and Why</h2>
<p>Branching lets a program choose different execution paths based on conditions. It’s fundamental to decision-making logic and input validation.</p>
<h2 id="if-else">if / else</h2>
<ul>
<li>Evaluate a boolean condition to choose a path.</li>
<li>Chain with else if for multiple cases; prefer early returns (guard clauses) for readability.</li>
</ul>
<p>Example:</p>
<pre><code class="language-csharp">int score = 78;
if (score &lt; 0 || score &gt; 100)
{
	throw new ArgumentOutOfRangeException(nameof(score));
}
else if (score &gt;= 90)
{
	Console.WriteLine(&quot;A&quot;);
}
else if (score &gt;= 80)
{
	Console.WriteLine(&quot;B&quot;);
}
else
{
	Console.WriteLine(&quot;C or below&quot;);
}
</code></pre>
<h2 id="switch">switch</h2>
<ul>
<li>Good for discrete choices based on a single value.</li>
<li>Pattern matching unlocks matching on types, ranges, and conditions.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-csharp">string GradeCategory(int score) =&gt; score switch
{
	&gt;= 90 =&gt; &quot;Excellent&quot;,
	&gt;= 80 =&gt; &quot;Good&quot;,
	&gt;= 70 =&gt; &quot;Fair&quot;,
	_ =&gt; &quot;Needs Improvement&quot;
};

// Type pattern example
string Describe(object o) =&gt; o switch
{
	null =&gt; &quot;null&quot;,
	string s when s.Length == 0 =&gt; &quot;empty string&quot;,
	string s =&gt; $&quot;string of length {s.Length}&quot;,
	int n =&gt; $&quot;int {n}&quot;,
	_ =&gt; o.GetType().Name
};
</code></pre>
<h2 id="best-practices-2">Best Practices</h2>
<ul>
<li>Keep conditions simple and intention-revealing.</li>
<li>Prefer switch for many discrete cases; avoid long if/else chains.</li>
<li>Extract complex conditions into well-named helpers for readability and reuse.</li>
<li>Avoid duplication: compute a value once and reuse it.</li>
<li>Use guard clauses to fail fast when inputs are invalid.</li>
</ul>
<hr />
<h1 id="looping-in-c-for-while-foreach">Looping in C# (for, while, foreach)</h1>
<h2 id="what-and-why-1">What and Why</h2>
<p>Loops repeat work over a sequence or until a condition changes. They help process collections, perform retries, and implement state machines.</p>
<h2 id="for-while">for / while</h2>
<ul>
<li>for: use when you control an index and have clear start/stop/step.</li>
<li>while: use when you loop until a condition becomes false.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-csharp">int total = 0;
for (int i = 1; i &lt;= 3; i++)
{
	total += i; // 1+2+3
}

int n = 3;
while (n &gt; 0)
{
	n--; // 3,2,1 -&gt; stop when 0
}
</code></pre>
<h2 id="foreach">foreach</h2>
<ul>
<li>Iterates elements of a collection in sequence order.</li>
<li>Emphasizes the element rather than index bookkeeping.</li>
</ul>
<pre><code class="language-csharp">var items = new[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; };
foreach (var it in items)
{
	Console.WriteLine(it);
}
</code></pre>
<h2 id="pitfalls-and-tips">Pitfalls and Tips</h2>
<ul>
<li>Avoid off-by-one errors by defining inclusive/exclusive bounds explicitly.</li>
<li>Ensure loop termination; mutate conditions correctly.</li>
<li>Prefer foreach for readability when indexing isn't needed.</li>
<li>Use break/continue judiciously; they can simplify control flow but overuse harms clarity.</li>
</ul>
<pre><code class="language-csharp">foreach (var word in words)
{
	if (string.IsNullOrWhiteSpace(word)) continue; // skip blanks
	if (word == &quot;STOP&quot;) break;                    // early exit
	Console.WriteLine(word);
}
</code></pre>
<hr />
<h1 id="iterators-and-yield">Iterators and <code>yield</code></h1>
<p>Iterators generate sequence elements on demand with minimal memory and clear code. In C#, you implement iterators with <code>yield return</code> and <code>yield break</code>, and the compiler builds the underlying state machine for <code>IEnumerable</code>/<code>IEnumerator</code>.</p>
<h2 id="when-to-use">When to use</h2>
<ul>
<li>Stream large or expensive data lazily (avoid loading everything into memory).</li>
<li>Compose pipelines (filter, map) without intermediate allocations.</li>
<li>Model infinite or open-ended sequences safely.</li>
</ul>
<h2 id="the-iterator-contract">The iterator contract</h2>
<ul>
<li><code>IEnumerable&lt;T&gt;.GetEnumerator()</code> returns an <code>IEnumerator&lt;T&gt;</code>.</li>
<li><code>IEnumerator&lt;T&gt;</code> has <code>bool MoveNext()</code>, <code>T Current { get; }</code>, and <code>void Reset()</code> (rarely used), plus <code>IDisposable</code>.</li>
<li>An iterator method that uses <code>yield</code> implicitly implements this contract for you.</li>
</ul>
<h2 id="basics-yield-return-and-yield-break">Basics: <code>yield return</code> and <code>yield break</code></h2>
<pre><code class="language-csharp">IEnumerable&lt;int&gt; FirstN(int count)
{
    for (int i = 1; i &lt;= count; i++)
        yield return i; // execution suspends here until next MoveNext()
}

// End a sequence early
IEnumerable&lt;int&gt; OddsUntil(int limit)
{
    for (int i = 1; ; i += 2)
    {
        if (i &gt; limit) yield break;
        yield return i;
    }
}
</code></pre>
<p>Usage:</p>
<pre><code class="language-csharp">foreach (var n in FirstN(3))
    Console.WriteLine(n); // 1 2 3

Console.WriteLine(string.Join(&quot;, &quot;, OddsUntil(7))); // 1, 3, 5, 7
</code></pre>
<h2 id="real-world-lazy-file-processing">Real-world: lazy file processing</h2>
<p>Prefer <code>File.ReadLines</code> (lazy) to <code>ReadAllLines</code> (eager) for large files.</p>
<pre><code class="language-csharp">IEnumerable&lt;string&gt; ErrorLines(string path)
{
    foreach (var line in File.ReadLines(path)) // streams lines lazily
        if (line.Contains(&quot;ERROR&quot;))
            yield return line;
}

// Consumers can bail early without reading the whole file
var firstError = ErrorLines(&quot;app.log&quot;).FirstOrDefault();
</code></pre>
<h2 id="composing-iterators">Composing iterators</h2>
<pre><code class="language-csharp">IEnumerable&lt;int&gt; Range(int start, int count)
{
    for (int i = 0; i &lt; count; i++)
        yield return start + i;
}

IEnumerable&lt;int&gt; Squares(IEnumerable&lt;int&gt; numbers)
{
    foreach (var n in numbers)
        yield return n * n;
}

var firstFiveSquares = Squares(Range(1, 5)); // 1, 4, 9, 16, 25
</code></pre>
<h2 id="state-exceptions-and-cleanup">State, exceptions, and cleanup</h2>
<ul>
<li>State machine: Local variables are preserved between <code>yield return</code>s.</li>
<li>Exceptions thrown inside the iterator surface at enumeration time (when <code>MoveNext()</code> runs).</li>
<li>Use <code>try/finally</code> to guarantee cleanup at the end of enumeration.</li>
</ul>
<pre><code class="language-csharp">IEnumerable&lt;string&gt; ReadLinesWithFooter(string path)
{
    using var reader = new StreamReader(path);
    string? line;
    try
    {
        while ((line = reader.ReadLine()) is not null)
            yield return line;
    }
    finally
    {
        yield return &quot;-- EOF --&quot;; // allowed: finally runs on normal or early termination
    }
}
</code></pre>
<p>Note: In iterators, <code>using</code> translates to <code>try/finally</code> so the resource is disposed when enumeration completes or is abandoned.</p>
<h2 id="common-pitfalls-and-tips">Common pitfalls and tips</h2>
<ul>
<li>Multiple enumeration repeats work. If you need to iterate multiple times, materialize once: <code>var cache = source.ToList();</code>.</li>
<li>Side effects happen on enumeration, not declaration. Be mindful when passing an <code>IEnumerable&lt;T&gt;</code> around.</li>
<li>Don’t capture mutable outer variables you later change; it can lead to confusing results.</li>
<li>Prefer returning <code>IEnumerable&lt;T&gt;</code> over concrete collections when laziness is desired.</li>
</ul>
<h2 id="async-streams-brief">Async streams (brief)</h2>
<p>For async producers/consumers, use <code>IAsyncEnumerable&lt;T&gt;</code> with <code>await foreach</code> and <code>yield return</code> in <code>async</code> iterator methods.</p>
<pre><code class="language-csharp">async IAsyncEnumerable&lt;int&gt; Tick(int intervalMs, [EnumeratorCancellation] CancellationToken ct = default)
{
    int i = 0;
    while (!ct.IsCancellationRequested)
    {
        await Task.Delay(intervalMs, ct);
        yield return ++i;
    }
}
</code></pre>
<hr />
<h1 id="common-language-runtime-clr">Common Language Runtime (CLR)</h1>
<p>The CLR is the virtual machine that runs .NET code. It loads assemblies, verifies IL, JIT-compiles methods to native code, and manages memory and execution.</p>
<h2 id="role-of-clr">Role of CLR</h2>
<ul>
<li>IL → native via Just-In-Time (JIT) compilation with tiered compilation (fast Tier0 → optimized Tier1).</li>
<li>Memory management with a generational, concurrent, compacting Garbage Collector.</li>
<li>Type safety, verification, security boundaries, exception handling.</li>
</ul>
<h2 id="key-services">Key Services</h2>
<ul>
<li>Garbage Collection: Generations (0/1/2), Large Object Heap (LOH), Server vs Workstation GC, Background GC.</li>
<li>JIT: Tiered JIT, ReadyToRun (AOT-like precompiled IL), PGO (profile-guided optimization).</li>
<li>Type System &amp; Metadata: reflection, attributes, runtime type info (RTTI).</li>
<li>Loading &amp; Isolation: Assemblies, AssemblyLoadContext (plugin isolation), single-file publish.</li>
</ul>
<h2 id="practical-effects">Practical effects</h2>
<ul>
<li>Startup vs throughput: tiered JIT improves startup with later optimizations.</li>
<li>Allocation patterns matter: short-lived objects die young (Gen0) → cheap; avoid LOH fragmentation.</li>
<li>Exceptions are expensive when thrown; using them for control flow hurts performance.</li>
</ul>
<h2 id="interop-brief">Interop (brief)</h2>
<ul>
<li>P/Invoke to call native functions; <code>DllImport</code> attribute defines the boundary.</li>
</ul>
<pre><code class="language-csharp">using System.Runtime.InteropServices;

static class Native
{
	[DllImport(&quot;kernel32.dll&quot;)]
	public static extern void Sleep(uint dwMilliseconds);
}

Native.Sleep(100);
</code></pre>
<h2 id="diagnostics-hooks">Diagnostics hooks</h2>
<ul>
<li>ETW/EventPipe (dotnet-trace), dotnet-counters, dotnet-gcdump, PerfView.</li>
<li>In-process: <code>GC.GetTotalMemory</code>, <code>GC.TryStartNoGCRegion</code>, <code>Activity</code> for tracing.</li>
</ul>
<h2 id="additional-theory">Additional theory</h2>
<h3 id="execution-model">Execution model</h3>
<ul>
<li>IL and metadata describe types/methods; JIT compiles methods on first execution.</li>
<li>Tiered compilation starts with fast code (Tier0) then re-JITs hot paths with optimizations (Tier1).</li>
<li>ReadyToRun (R2R) publishes precompiled native stubs to reduce startup JIT work.</li>
</ul>
<h3 id="gc-internals">GC internals</h3>
<ul>
<li>Generational GC with ephemeral segments for Gen0/Gen1 and a separate Gen2; LOH holds large objects (~85k+).</li>
<li>Finalizers run on a dedicated thread; objects with finalizers survive at least one extra collection.</li>
<li>Use <code>IDisposable</code> and <code>using</code> to release unmanaged resources deterministically.</li>
</ul>
<h3 id="type-safety-and-verification">Type safety and verification</h3>
<ul>
<li>The CLR verifies IL for type safety unless running fully trusted/unsafe code.</li>
<li>Unsafe code and stackalloc/pointers are available but opt-in and should be minimized.</li>
</ul>
<h3 id="loading-and-isolation">Loading and isolation</h3>
<ul>
<li>AssemblyLoadContext enables custom probing and dynamic plugin loading in .NET 5+.</li>
<li>Single-file publish bundles dependencies; trimming reduces unused IL where possible.</li>
</ul>
<hr />
<h1 id="net-framework-class-library-bclfcl">.NET Framework Class Library (BCL/FCL)</h1>
<p>The BCL/FCL is the standard library for .NET: collections, IO, networking, threading, numerics, etc. Learn its surface area to avoid reinventing wheels.</p>
<h2 id="common-namespaces-and-anchors">Common namespaces and anchors</h2>
<ul>
<li>System, System.Collections.Generic (List<T>, Dictionary&lt;TKey,TValue&gt;, HashSet<T>)</li>
<li>System.Linq (operators for querying in-memory collections)</li>
<li>System.IO (File, Directory, streams)</li>
<li>System.Net.Http (HttpClient)</li>
<li>System.Text.Json (JSON serialization)</li>
<li>System.Threading / Tasks (Task, CancellationToken)</li>
</ul>
<h2 id="handy-examples">Handy examples</h2>
<pre><code class="language-csharp">// Collections
var counts = new Dictionary&lt;string,int&gt;(StringComparer.OrdinalIgnoreCase);
foreach (var w in new[] { &quot;a&quot;, &quot;b&quot;, &quot;A&quot; }) counts[w] = counts.GetValueOrDefault(w) + 1;

// IO
File.WriteAllText(&quot;demo.txt&quot;, &quot;hello&quot;);
var text = File.ReadAllText(&quot;demo.txt&quot;);

// LINQ
var evens = Enumerable.Range(1, 10).Where(n =&gt; n % 2 == 0).ToArray();

// JSON
var json = System.Text.Json.JsonSerializer.Serialize(new { Name = &quot;Ada&quot; });
var obj = System.Text.Json.JsonSerializer.Deserialize&lt;Dictionary&lt;string,string&gt;&gt;(json);

// Tasks &amp; cancellation
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1));
try { await Task.Delay(5000, cts.Token); }
catch (TaskCanceledException) { /* expected */ }
</code></pre>
<h2 id="tips">Tips</h2>
<ul>
<li>Prefer BCL types first; they’re well-tested and supported across runtimes.</li>
<li>Check for <code>TryXxx</code> methods to avoid exceptions for common failure paths.</li>
</ul>
<hr />
<h1 id="ide-setup-visual-studio-vs-code">IDE Setup (Visual Studio / VS Code)</h1>
<h2 id="vs-code">VS Code</h2>
<ul>
<li>Install C# Dev Kit and .NET Runtime extension pack.</li>
<li>Ensure .NET SDK installed: <code>dotnet --info</code>.</li>
<li>Create a project: <code>dotnet new console -n Hello</code> → build/run: <code>dotnet run</code>.</li>
</ul>
<h2 id="visual-studio">Visual Studio</h2>
<ul>
<li>Workloads: “.NET desktop development”, “ASP.NET and web development”.</li>
<li>Use Solution Explorer, launch profiles, integrated test runner, and code analyzers.</li>
</ul>
<h2 id="project-configuration-tips">Project configuration tips</h2>
<ul>
<li>Nullable references: <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> for safer APIs.</li>
<li>Implicit usings: <code>&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;</code> reduces boilerplate.</li>
<li>Treat warnings as errors in CI: <code>&lt;TreatWarningsAsErrors&gt;true&lt;/TreatWarningsAsErrors&gt;</code>.</li>
<li>Add analyzers: StyleCop/IDEs, or enable Microsoft.CodeAnalysis.NetAnalyzers.</li>
</ul>
<h2 id="cli-essentials">CLI essentials</h2>
<ul>
<li><code>dotnet new</code>, <code>dotnet add package</code>, <code>dotnet build</code>, <code>dotnet test</code>, <code>dotnet publish</code>.</li>
<li><code>dotnet watch run</code> for hot reload during development.</li>
</ul>
<hr />
<h1 id="classes-and-objects">Classes and Objects</h1>
<p>Classes model state and behavior; objects are instances with their own state. Prefer small, cohesive classes with clear responsibilities.</p>
<h2 id="anatomy-of-a-class">Anatomy of a class</h2>
<pre><code class="language-csharp">public class BankAccount
{
	private decimal _balance;              // encapsulated field
	public string Owner { get; }           // init-only via constructor
	public decimal Balance =&gt; _balance;    // read-only property (expression-bodied)

	public BankAccount(string owner, decimal openingBalance = 0)
	{
		Owner = owner ?? throw new ArgumentNullException(nameof(owner));
		if (openingBalance &lt; 0) throw new ArgumentOutOfRangeException(nameof(openingBalance));
		_balance = openingBalance;
	}

	public void Deposit(decimal amount)
	{
		if (amount &lt;= 0) throw new ArgumentOutOfRangeException(nameof(amount));
		_balance += amount;
	}

	public bool TryWithdraw(decimal amount)
	{
		if (amount &lt;= 0) return false;
		if (amount &gt; _balance) return false;
		_balance -= amount;
		return true;
	}
}

// Usage
var acct = new BankAccount(&quot;Alice&quot;, 100m);
acct.Deposit(50m);
Console.WriteLine(acct.Balance); // 150
</code></pre>
<h2 id="properties-init-only-and-validation">Properties, init-only, and validation</h2>
<pre><code class="language-csharp">public class Person
{
	private int _age;
	public string FirstName { get; init; } = string.Empty; // init-only at construction
	public string LastName  { get; init; } = string.Empty;
	public int Age
	{
		get =&gt; _age;
		set =&gt; _age = value &gt;= 0 ? value : throw new ArgumentOutOfRangeException();
	}
}

var p = new Person { FirstName = &quot;Ada&quot;, LastName = &quot;Lovelace&quot;, Age = 28 };
</code></pre>
<h2 id="indexers-and-static-members">Indexers and static members</h2>
<pre><code class="language-csharp">public class WordBag
{
	private readonly Dictionary&lt;string,int&gt; _counts = new(StringComparer.OrdinalIgnoreCase);
	public int this[string word]
	{
		get =&gt; _counts.TryGetValue(word, out var c) ? c : 0;
		set =&gt; _counts[word] = value;
	}

	public static WordBag FromText(string text)
	{
		var bag = new WordBag();
		foreach (var w in text.Split(' ', StringSplitOptions.RemoveEmptyEntries))
			bag[w]++;
		return bag;
	}
}

var bag = WordBag.FromText(&quot;to be or not to be&quot;);
Console.WriteLine(bag[&quot;be&quot;]); // 1
</code></pre>
<h2 id="records-for-immutable-data-models">Records for immutable data models</h2>
<pre><code class="language-csharp">public record Customer(string Id, string Name);

var c1 = new Customer(&quot;42&quot;, &quot;Dana&quot;);
var c2 = c1 with { Name = &quot;Dana S.&quot; }; // non-destructive mutation
Console.WriteLine(c1 == c2); // false (value equality)
</code></pre>
<h2 id="object-initialization-and-deconstruction">Object initialization and deconstruction</h2>
<pre><code class="language-csharp">public class Point
{
	public int X { get; init; }
	public int Y { get; init; }
	public void Deconstruct(out int x, out int y) { x = X; y = Y; }
}

var pt = new Point { X = 3, Y = 4 };
var (x, y) = pt; // x=3, y=4
</code></pre>
<hr />
<h1 id="oop-principles">OOP Principles</h1>
<p>Core pillars: Encapsulation, Inheritance, Polymorphism, and Abstraction. Favor composition over deep inheritance chains.</p>
<h2 id="encapsulation">Encapsulation</h2>
<p>Hide state, expose behavior with invariants enforced inside the type.</p>
<pre><code class="language-csharp">public class Thermostat
{
	private double _temperature;
	public double Temperature
	{
		get =&gt; _temperature;
		set =&gt; _temperature = Math.Clamp(value, 10, 30); // keep within safe range
	}
}
</code></pre>
<h2 id="inheritance-use-sparingly">Inheritance (use sparingly)</h2>
<pre><code class="language-csharp">public abstract class Shape { public abstract double Area(); }
public class Rectangle : Shape
{
	public double Width { get; init; }
	public double Height { get; init; }
	public override double Area() =&gt; Width * Height;
}
public class Circle : Shape
{
	public double Radius { get; init; }
	public override double Area() =&gt; Math.PI * Radius * Radius;
}

Shape s = new Circle { Radius = 2 };
Console.WriteLine(s.Area());
</code></pre>
<h2 id="polymorphism">Polymorphism</h2>
<p>Overriding via virtual/abstract methods; interface-based polymorphism preferred for decoupling.</p>
<pre><code class="language-csharp">public interface IPrinter { void Print(string message); }
public class ConsolePrinter : IPrinter { public void Print(string m) =&gt; Console.WriteLine(m); }
public class UpperCasePrinter : IPrinter { public void Print(string m) =&gt; Console.WriteLine(m.ToUpperInvariant()); }

void Notify(IPrinter printer) =&gt; printer.Print(&quot;Hello&quot;);
</code></pre>
<h2 id="abstraction">Abstraction</h2>
<p>Express intent without committing to details.</p>
<pre><code class="language-csharp">public interface IRepository&lt;T&gt;
{
	T? Get(string id);
	void Add(T entity);
}
</code></pre>
<h2 id="composition-over-inheritance">Composition over inheritance</h2>
<pre><code class="language-csharp">public class CachedRepository&lt;T&gt; : IRepository&lt;T&gt;
{
	private readonly IRepository&lt;T&gt; _inner;
	private readonly Dictionary&lt;string,T&gt; _cache = new();
	public CachedRepository(IRepository&lt;T&gt; inner) =&gt; _inner = inner;

	public T? Get(string id)
	{
		if (_cache.TryGetValue(id, out var v)) return v;
		var e = _inner.Get(id);
		if (e is not null) _cache[id] = e;
		return e;
	}
	public void Add(T entity) =&gt; _inner.Add(entity);
}
</code></pre>
<hr />
<h1 id="advanced-oop">Advanced OOP</h1>
<p>Dive deeper into design choices and trade-offs.</p>
<h2 id="solid-at-a-glance">SOLID (at a glance)</h2>
<ul>
<li>Single Responsibility: one reason to change per module.</li>
<li>Open/Closed: extend via composition/abstractions, avoid modifying stable code.</li>
<li>Liskov Substitution: derived types must honor base contracts/invariants.</li>
<li>Interface Segregation: prefer small, focused interfaces.</li>
<li>Dependency Inversion: depend on abstractions, not concretions.</li>
</ul>
<h2 id="structs-vs-classes">Structs vs Classes</h2>
<ul>
<li>Structs are value types; copied by value, allocated inline when possible.</li>
<li>Prefer for small, immutable data (e.g., 2–3 fields). Avoid large or mutable structs.</li>
</ul>
<pre><code class="language-csharp">public readonly struct Money
{
	public decimal Amount { get; }
	public string Currency { get; }
	public Money(decimal amount, string currency) { Amount = amount; Currency = currency; }
	public override string ToString() =&gt; $&quot;{Amount} {Currency}&quot;;
}
</code></pre>
<h2 id="enums-flags">Enums &amp; Flags</h2>
<pre><code class="language-csharp">[Flags]
public enum FileAccessRights { None = 0, Read = 1, Write = 2, Execute = 4 }
var rights = FileAccessRights.Read | FileAccessRights.Write;
bool canWrite = rights.HasFlag(FileAccessRights.Write);
</code></pre>
<h2 id="nested-types">Nested types</h2>
<p>Keep helpers close to usage; avoid overexposure of internals.</p>
<pre><code class="language-csharp">public class Parser
{
	public sealed class Result { public bool Success { get; init; } public string? Error { get; init; } }
}
</code></pre>
<h2 id="partial-typesmembers">Partial types/members</h2>
<p>Split large types across files or generate parts via source generators.</p>
<pre><code class="language-csharp">public partial class UserService { partial void OnCreated(); }
public partial class UserService { partial void OnCreated() { /* hook */ } }
</code></pre>
<h2 id="operator-overloads-use-judiciously">Operator overloads (use judiciously)</h2>
<pre><code class="language-csharp">public readonly record struct Vector2(double X, double Y)
{
	public static Vector2 operator +(Vector2 a, Vector2 b) =&gt; new(a.X + b.X, a.Y + b.Y);
}
</code></pre>
<h2 id="equality-semantics">Equality semantics</h2>
<ul>
<li>Classes default to reference equality; override <code>Equals/GetHashCode</code> or use records for value semantics.</li>
</ul>
<pre><code class="language-csharp">public record Person(string First, string Last);
var a = new Person(&quot;Ada&quot;,&quot;Lovelace&quot;);
var b = new Person(&quot;Ada&quot;,&quot;Lovelace&quot;);
Console.WriteLine(a == b); // true (value-based)
</code></pre>
<h2 id="best-practices-3">Best practices</h2>
<ul>
<li>Favor immutability where practical.</li>
<li>Keep constructors simple; use factories/builders if setup is complex.</li>
<li>Keep inheritance shallow; prefer interfaces + composition.</li>
</ul>
<h2 id="virtual-dispatch-and-performance">Virtual dispatch and performance</h2>
<ul>
<li>Virtual/interface calls can inhibit inlining; sealing methods/types enables devirtualization.</li>
<li>Measure before optimizing; prefer clarity, optimize verified hot paths only.</li>
</ul>
<h2 id="domain-modeling-tips">Domain modeling tips</h2>
<ul>
<li>Keep entities small and cohesive; make invariants explicit.</li>
<li>Use aggregate roots to guard invariants; expose behavior, not settable state.</li>
<li>Persistence-ignorant domain: no data access in entities; use repositories/services for IO.</li>
</ul>
<hr />
<h1 id="built-in-collections">Built-in Collections</h1>
<p>Choose the right structure for performance and clarity. Know the complexity and common pitfalls.</p>
<h2 id="core-types-and-when-to-use">Core types and when to use</h2>
<ul>
<li>Array (T[]): fixed size, contiguous memory, fastest indexing.</li>
<li>List<T>: dynamic array, amortized O(1) append, O(1) index.</li>
<li>Dictionary&lt;TKey,TValue&gt;: hash map, O(1) average lookup/insert.</li>
<li>HashSet<T>: uniqueness set, O(1) average contains/add.</li>
<li>Queue<T>, Stack<T>: FIFO/LIFO with O(1) enqueue/dequeue/push/pop.</li>
<li>LinkedList<T>: O(1) insert/remove with node, O(n) indexing; niche use.</li>
<li>Concurrent collections: thread-safe data structures for multi-producer/consumer.</li>
</ul>
<h2 id="idiomatic-examples">Idiomatic examples</h2>
<pre><code class="language-csharp">// List
var nums = new List&lt;int&gt; { 1, 2, 3 };
nums.Add(4);
nums.RemoveAll(n =&gt; n % 2 == 0); // 1,3

// Dictionary
var counts = new Dictionary&lt;string,int&gt;(StringComparer.OrdinalIgnoreCase);
foreach (var w in new[] { &quot;A&quot;, &quot;b&quot;, &quot;a&quot; })
	counts[w] = counts.GetValueOrDefault(w) + 1;

// HashSet
var unique = new HashSet&lt;int&gt; { 1, 2, 2, 3 }; // 1,2,3

// Queue/Stack
var q = new Queue&lt;string&gt;(); q.Enqueue(&quot;first&quot;); q.Enqueue(&quot;second&quot;); var head = q.Dequeue();
var s = new Stack&lt;string&gt;(); s.Push(&quot;x&quot;); s.Push(&quot;y&quot;); var top = s.Pop();
</code></pre>
<h2 id="concurrent-collections">Concurrent collections</h2>
<pre><code class="language-csharp">var bag = new System.Collections.Concurrent.ConcurrentBag&lt;int&gt;();
Parallel.For(0, 1000, bag.Add);
int count = bag.Count; // thread-safe aggregation pattern differs

var queue = new System.Collections.Concurrent.BlockingCollection&lt;int&gt;();
var prod = Task.Run(() =&gt; { for (int i = 0; i &lt; 10; i++) queue.Add(i); queue.CompleteAdding(); });
var cons = Task.Run(() =&gt; { foreach (var item in queue.GetConsumingEnumerable()) Console.WriteLine(item); });
await Task.WhenAll(prod, cons);
</code></pre>
<p>When to use which:</p>
<ul>
<li>Use ConcurrentDictionary when multiple threads update shared counters/state per key.</li>
<li>Use BlockingCollection for producer/consumer pipelines with backpressure.</li>
<li>Prefer immutable snapshots (e.g., ImmutableArray) for many-readers/few-writers patterns.</li>
</ul>
<h2 id="complexity-cheatsheet-typical">Complexity cheatsheet (typical)</h2>
<ul>
<li>List<T>: index O(1), append amortized O(1), remove by value O(n).</li>
<li>Dictionary/HashSet: add/contains O(1) average; O(n) worst-case.</li>
<li>Queue/Stack: O(1) enqueue/dequeue/push/pop.</li>
</ul>
<h2 id="tips-1">Tips</h2>
<ul>
<li>Prefer <code>TryGetValue</code>/<code>GetValueOrDefault</code> to avoid exceptions on missing keys.</li>
<li>Use <code>StringComparer.OrdinalIgnoreCase</code> when keys are case-insensitive.</li>
<li>Avoid repeated <code>List&lt;T&gt;.Remove(item)</code> in a loop; filter with <code>Where</code>/<code>RemoveAll</code>.</li>
</ul>
<h2 id="further-reading-2">Further reading</h2>
<hr />
<h1 id="custom-collections">Custom Collections</h1>
<p>Implementing custom collections lets you enforce invariants and expose efficient operations. Prefer composition and interfaces.</p>
<h2 id="implementing-ienumerable">Implementing IEnumerable<T></h2>
<pre><code class="language-csharp">public sealed class EvenNumbers : IEnumerable&lt;int&gt;
{
	private readonly int _limit;
	public EvenNumbers(int limit) =&gt; _limit = limit;
	public IEnumerator&lt;int&gt; GetEnumerator() =&gt; Iterator();
	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() =&gt; GetEnumerator();
	private IEnumerator&lt;int&gt; Iterator()
	{
		for (int i = 0; i &lt;= _limit; i += 2)
			yield return i;
	}
}
</code></pre>
<h2 id="implementing-ilist-sketch">Implementing IList<T> (sketch)</h2>
<pre><code class="language-csharp">public class BoundedList&lt;T&gt; : IList&lt;T&gt;
{
	private readonly List&lt;T&gt; _inner = new();
	public int Capacity { get; }
	public BoundedList(int capacity) =&gt; Capacity = capacity;
	public T this[int index] { get =&gt; _inner[index]; set =&gt; _inner[index] = value; }
	public int Count =&gt; _inner.Count;
	public bool IsReadOnly =&gt; false;
	public void Add(T item) { if (Count &gt;= Capacity) throw new InvalidOperationException(&quot;Full&quot;); _inner.Add(item); }
	public void Clear() =&gt; _inner.Clear();
	public bool Contains(T item) =&gt; _inner.Contains(item);
	public void CopyTo(T[] array, int arrayIndex) =&gt; _inner.CopyTo(array, arrayIndex);
	public IEnumerator&lt;T&gt; GetEnumerator() =&gt; _inner.GetEnumerator();
	public int IndexOf(T item) =&gt; _inner.IndexOf(item);
	public void Insert(int index, T item) { if (Count &gt;= Capacity) throw new InvalidOperationException(&quot;Full&quot;); _inner.Insert(index, item); }
	public bool Remove(T item) =&gt; _inner.Remove(item);
	public void RemoveAt(int index) =&gt; _inner.RemoveAt(index);
	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() =&gt; _inner.GetEnumerator();
}
</code></pre>
<hr />
<h1 id="exception-handling">Exception Handling</h1>
<p>Exceptions represent exceptional, non-expected paths. Use them to signal failure, not for normal branching.</p>
<h2 id="basics-trycatchfinally">Basics: try/catch/finally</h2>
<pre><code class="language-csharp">try
{
	using var stream = File.OpenRead(&quot;config.json&quot;);
	// work with stream
}
catch (FileNotFoundException ex)
{
	Console.Error.WriteLine($&quot;Missing config: {ex.FileName}&quot;);
}
catch (IOException ex) when (ex.HResult == -2147024864) // example of filter (file in use)
{
	Console.Error.WriteLine(&quot;File is locked.&quot;);
}
catch (Exception ex)
{
	Console.Error.WriteLine($&quot;Unexpected: {ex}&quot;);
	throw; // rethrow preserving stack trace
}
finally
{
	// cleanup that must always run
}
</code></pre>
<h2 id="best-practices-4">Best practices</h2>
<ul>
<li>Catch narrowly; let higher layers handle what they own.</li>
<li>Use exception filters (<code>catch (X ex) when (...)</code>) to avoid partial state changes.</li>
<li>Don’t swallow exceptions silently; log with context.</li>
<li>Prefer <code>TryXxx</code> patterns (e.g., <code>int.TryParse</code>) when failure is expected.</li>
</ul>
<h2 id="creating-error-context">Creating error context</h2>
<pre><code class="language-csharp">try
{
	ProcessOrder(orderId);
}
catch (OrderStorageException ex)
{
	throw new OrderProcessingException($&quot;Could not process order {orderId}&quot;, ex);
}
</code></pre>
<h2 id="theory-reliability-and-observability">Theory: reliability and observability</h2>
<ul>
<li>Throwing is expensive; design for the happy path and throw only for truly exceptional cases.</li>
<li>Rethrow with <code>throw;</code> to preserve the original stack.</li>
<li>Avoid leaking secrets in messages; include useful IDs/correlation tokens.</li>
<li>Add global exception handling appropriate to the app type (ASP.NET Core middleware, WPF DispatcherUnhandledException).</li>
<li>Use first-chance exception settings when debugging to catch issues close to the source.</li>
</ul>
<hr />
<h1 id="custom-exceptions">Custom Exceptions</h1>
<p>Define custom exceptions to convey domain-specific failures and enable precise handling.</p>
<h2 id="template">Template</h2>
<pre><code class="language-csharp">[Serializable]
public class OrderProcessingException : Exception
{
	public string? OrderId { get; }
	public OrderProcessingException() { }
	public OrderProcessingException(string message) : base(message) { }
	public OrderProcessingException(string message, Exception inner) : base(message, inner) { }
	public OrderProcessingException(string message, string orderId) : base(message) =&gt; OrderId = orderId;
	protected OrderProcessingException(System.Runtime.Serialization.SerializationInfo info,
									   System.Runtime.Serialization.StreamingContext context)
		: base(info, context) { }
}
</code></pre>
<h2 id="tips-2">Tips</h2>
<ul>
<li>Name them clearly; include meaningful properties (like identifiers).</li>
<li>Preserve inner exceptions; they’re essential for root-cause analysis.</li>
<li>Avoid throwing exceptions for control flow; use <code>TryXxx</code> when failure is common.</li>
</ul>
<hr />
<h1 id="debugging-techniques">Debugging Techniques</h1>
<p>Debugging is about fast feedback and narrowing hypotheses.</p>
<h2 id="core-tools">Core tools</h2>
<ul>
<li>Breakpoints (conditions, hit counts), data tips, watch/locals, call stack, step-into/out/over.</li>
<li>Edit and Continue, exception settings (break on thrown/unhandled).</li>
</ul>
<h2 id="logging">Logging</h2>
<pre><code class="language-csharp">using Microsoft.Extensions.Logging;

using var loggerFactory = LoggerFactory.Create(b =&gt; b.AddSimpleConsole().SetMinimumLevel(LogLevel.Debug));
var logger = loggerFactory.CreateLogger(&quot;Demo&quot;);
logger.LogInformation(&quot;Starting module {Module}&quot;, &quot;X&quot;);
</code></pre>
<h2 id="tactics">Tactics</h2>
<ul>
<li>Reproduce deterministically; reduce the surface (disable concurrency, mock IO).</li>
<li>Bisect changes (git); add asserts for invariants.</li>
<li>Capture context: inputs, environment, timing, correlation IDs.</li>
</ul>
<h2 id="performance-debugging">Performance debugging</h2>
<ul>
<li>dotnet-trace/dotnet-counters; sampling profilers; memory dumps (dotnet-gcdump).</li>
</ul>
<hr />
<h1 id="delegates-and-events">Delegates and Events</h1>
<p>Delegates are type-safe function references; events build a publish/subscribe layer on top.</p>
<h2 id="delegates-and-built-ins">Delegates and built-ins</h2>
<pre><code class="language-csharp">// Custom delegate type
public delegate int BinaryOp(int a, int b);
int Add(int x, int y) =&gt; x + y;
BinaryOp op = Add;
int r = op(2, 3); // 5

// Built-ins
Action&lt;string&gt; log = Console.WriteLine;     // no return
Func&lt;int,int,int&gt; mul = (a,b) =&gt; a * b;     // returns int
Predicate&lt;int&gt; isEven = n =&gt; n % 2 == 0;    // bool-returning Func&lt;T,bool&gt;
</code></pre>
<h2 id="lambdas-and-closures">Lambdas and closures</h2>
<h3 id="theory-variance-and-closures">Theory: variance and closures</h3>
<ul>
<li>Delegates are type-safe function pointers that can be multicast (invocation list).</li>
<li>Variance: input parameters are contravariant, return types are covariant when compatible.</li>
<li>Closures capture variables by reference; modifying the captured variable affects all lambdas.</li>
</ul>
<pre><code class="language-csharp">int factor = 10;                  // captured variable
Func&lt;int,int&gt; times = n =&gt; n * factor;
factor = 20;                      // closure observes latest value
Console.WriteLine(times(2));      // 40
</code></pre>
<h2 id="multicast-delegates">Multicast delegates</h2>
<pre><code class="language-csharp">Action pipeline = () =&gt; Console.Write(&quot;A&quot;);
pipeline += () =&gt; Console.Write(&quot;B&quot;);
pipeline(); // prints AB
</code></pre>
<h2 id="events-eventhandler-pattern">Events (EventHandler pattern)</h2>
<h3 id="event-patterns">Event patterns</h3>
<ul>
<li>Prefer EventHandler/EventHandler<TEventArgs> for consistency.</li>
<li>Expose a protected virtual OnXyz method to allow derived classes to customize raising.</li>
<li>Consider weak references or explicit unsubscribe in long-lived publishers to prevent leaks.</li>
</ul>
<pre><code class="language-csharp">public class Counter
{
	public event EventHandler&lt;int&gt;? ThresholdReached; // payload via generic arg
	private int _count;
	public void Increment()
	{
		_count++;
		if (_count % 5 == 0)
			ThresholdReached?.Invoke(this, _count); // raise safely with null-conditional
	}
}

var c = new Counter();
c.ThresholdReached += (s, value) =&gt; Console.WriteLine($&quot;Hit {value}&quot;);
for (int i=0;i&lt;10;i++) c.Increment();
</code></pre>
<h2 id="custom-event-accessors-advanced">Custom event accessors (advanced)</h2>
<pre><code class="language-csharp">private EventHandler? _handlers;
public event EventHandler Something
{
	add { _handlers = (EventHandler?)Delegate.Combine(_handlers, value); }
	remove { _handlers = (EventHandler?)Delegate.Remove(_handlers, value); }
}
</code></pre>
<h2 id="tips-3">Tips</h2>
<ul>
<li>Prefer Action/Func over custom delegate types unless naming adds clarity.</li>
<li>Be careful with closures in loops; capture the loop variable into a local.</li>
<li>Unsubscribe from long-lived events to avoid memory leaks.</li>
</ul>
<hr />
<h1 id="linq">LINQ</h1>
<p>LINQ provides declarative querying for objects, XML, databases, and more.</p>
<h2 id="two-styles">Two styles</h2>
<pre><code class="language-csharp">// Query syntax
var q = from n in Enumerable.Range(1, 10)
		where n % 2 == 0
		select n * n;

// Method syntax
var m = Enumerable.Range(1,10).Where(n =&gt; n % 2 == 0).Select(n =&gt; n * n);
</code></pre>
<h2 id="core-operators">Core operators</h2>
<ul>
<li>Filtering: Where</li>
<li>Projection: Select, SelectMany</li>
<li>Sorting: OrderBy/ThenBy</li>
<li>Grouping: GroupBy</li>
<li>Joining: Join, GroupJoin</li>
<li>Set ops: Distinct, Union, Intersect, Except</li>
<li>Aggregates: Count, Sum, Min/Max, Average, Aggregate</li>
</ul>
<pre><code class="language-csharp">var people = new[] {
	new { Name = &quot;Ann&quot;, City = &quot;NY&quot;, Age = 30 },
	new { Name = &quot;Bob&quot;, City = &quot;SF&quot;, Age = 25 },
	new { Name = &quot;Cat&quot;, City = &quot;NY&quot;, Age = 40 },
};

var byCity = people.GroupBy(p =&gt; p.City)
				   .Select(g =&gt; new { City = g.Key, AvgAge = g.Average(p =&gt; p.Age) });

var orders = new[] { new { Id = 1, Customer = &quot;Ann&quot; } };
var customers = new[] { new { Name = &quot;Ann&quot; }, new { Name = &quot;Bob&quot; } };
var join = from o in orders
		   join c in customers on o.Customer equals c.Name
		   select new { o.Id, o.Customer };
</code></pre>
<h2 id="deferred-vs-immediate-execution">Deferred vs immediate execution</h2>
<ul>
<li>Deferred: Where/Select build a pipeline evaluated on enumeration.</li>
<li>Immediate: ToList/ToArray/Count materialize or compute immediately.</li>
</ul>
<pre><code class="language-csharp">var source = new List&lt;int&gt; { 1, 2 };
var seq = source.Select(n =&gt; n * 10); // deferred
source.Add(3);
var arr = seq.ToArray(); // 10, 20, 30
</code></pre>
<h2 id="ienumerable-vs-iqueryable">IEnumerable vs IQueryable</h2>
<ul>
<li>IEnumerable: in-memory; operators run as .NET delegates.</li>
<li>IQueryable: expression trees; provider can translate to SQL or other backends. Beware of unsupported methods.</li>
</ul>
<h2 id="tips-4">Tips</h2>
<ul>
<li>Push filters early (Where) and project only what you need (Select) to reduce work.</li>
<li>Avoid multiple enumeration if source is expensive; materialize once when needed.</li>
</ul>
<h2 id="practice">Practice</h2>
<ul>
<li>Given orders with a CustomerId, output the top 3 orders by total per customer.</li>
<li>Inner join vs group join: produce both and explain the shape differences.</li>
<li>Flatten nested collections (customers -&gt; orders -&gt; lines) and compute totals with SelectMany.</li>
</ul>
<hr />
<h1 id="asynchronous-programming">Asynchronous Programming</h1>
<p>Use async/await to free threads while work is pending (IO), improving scalability and responsiveness.</p>
<h2 id="asyncawait-basics">async/await basics</h2>
<pre><code class="language-csharp">async Task&lt;string&gt; DownloadAsync(HttpClient http, string url)
{
	var resp = await http.GetAsync(url); // awaits without blocking
	resp.EnsureSuccessStatusCode();
	return await resp.Content.ReadAsStringAsync();
}
</code></pre>
<h2 id="cancellation-and-timeouts">Cancellation and timeouts</h2>
<pre><code class="language-csharp">using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(2));
try
{
	await Task.Delay(5000, cts.Token);
}
catch (OperationCanceledException)
{
	// cancelled
}
</code></pre>
<h2 id="error-handling">Error handling</h2>
<pre><code class="language-csharp">try { await SomeAsync(); }
catch (HttpRequestException ex) { /* network failure */ }
</code></pre>
<h2 id="configureawait">ConfigureAwait</h2>
<p>In libraries, prefer <code>await task.ConfigureAwait(false)</code> to avoid capturing context. In apps (UI), default capture is usually fine.</p>
<h2 id="parallelism">Parallelism</h2>
<pre><code class="language-csharp">// CPU-bound parallel loop (data parallelism)
Parallel.ForEach(data, item =&gt; Process(item));

// Fire multiple IO tasks concurrently and await all
var tasks = urls.Select(http.GetStringAsync);
var pages = await Task.WhenAll(tasks);
</code></pre>
<h2 id="tips-5">Tips</h2>
<ul>
<li>Don’t block on async (no .Result/.Wait()); make your call chain async.</li>
<li>Use <code>ValueTask</code> for high-throughput hot paths when appropriate.</li>
</ul>
<h2 id="practice-1">Practice</h2>
<ul>
<li>Wrap an external API call with timeout and cancellation, surfacing a custom exception on failure.</li>
<li>Convert a synchronous file processing loop to async and ensure max 4 concurrent operations.</li>
<li>Explain ConfigureAwait(false) and where it’s appropriate; demonstrate a context-deadlock caused by .Result.</li>
</ul>
<hr />
<h1 id="ado.net">ADO.NET</h1>
<p>Low-level data access with explicit connections, commands, and readers. Great for tight control and performance.</p>
<h2 id="connected-commands-and-readers">Connected: commands and readers</h2>
<pre><code class="language-csharp">using var conn = new Microsoft.Data.Sqlite.SqliteConnection(&quot;Data Source=:memory:&quot;);
await conn.OpenAsync();
using var cmd = conn.CreateCommand();
cmd.CommandText = &quot;CREATE TABLE T(Id INTEGER PRIMARY KEY, Name TEXT); INSERT INTO T(Name) VALUES ('Ada'); SELECT Id, Name FROM T;&quot;;
using var reader = await cmd.ExecuteReaderAsync();
while (await reader.ReadAsync())
	Console.WriteLine($&quot;{reader.GetInt32(0)} {reader.GetString(1)}&quot;);
</code></pre>
<h2 id="disconnected-datatable">Disconnected: DataTable</h2>
<pre><code class="language-csharp">var table = new System.Data.DataTable();
using (var cmd = conn.CreateCommand())
{
	cmd.CommandText = &quot;SELECT 1 AS N UNION ALL SELECT 2&quot;;
	using var reader = await cmd.ExecuteReaderAsync();
	table.Load(reader); // Fast materialization without DataAdapter
}
</code></pre>
<p>Tips:</p>
<ul>
<li>Track RowState (Added/Modified/Deleted) to know what to persist.</li>
<li>Prefer <code>DataTable.Load(IDataReader)</code> for simple reads.</li>
<li>Keep ADO.NET for surgical control and batching; use EF/Dapper when object mapping productivity is needed.</li>
</ul>
<h2 id="transactions">Transactions</h2>
<pre><code class="language-csharp">using var tx = await conn.BeginTransactionAsync();
try
{
	using var c1 = conn.CreateCommand(); c1.Transaction = tx; c1.CommandText = &quot;INSERT INTO T(Name) VALUES ('Babbage')&quot;; await c1.ExecuteNonQueryAsync();
	using var c2 = conn.CreateCommand(); c2.Transaction = tx; c2.CommandText = &quot;INSERT INTO T(Name) VALUES ('Turing')&quot;; await c2.ExecuteNonQueryAsync();
	await tx.CommitAsync();
}
catch
{
	await tx.RollbackAsync();
	throw;
}
</code></pre>
<h2 id="further-reading-3">Further reading</h2>
<hr />
<h1 id="entity-framework-core">Entity Framework Core</h1>
<p>ORM for .NET with LINQ queries and change tracking.</p>
<h2 id="model-dbcontext">Model &amp; DbContext</h2>
<pre><code class="language-csharp">public class Blog { public int Id { get; set; } public string Title { get; set; } = &quot;&quot;; public List&lt;Post&gt; Posts { get; set; } = new(); }
public class Post { public int Id { get; set; } public string Content { get; set; } = &quot;&quot;; public int BlogId { get; set; } public Blog? Blog { get; set; } }

public class AppDb : DbContext
{
	public DbSet&lt;Blog&gt; Blogs =&gt; Set&lt;Blog&gt;();
	public DbSet&lt;Post&gt; Posts =&gt; Set&lt;Post&gt;();
	protected override void OnConfiguring(DbContextOptionsBuilder b) =&gt; b.UseSqlite(&quot;Data Source=app.db&quot;);
	protected override void OnModelCreating(ModelBuilder mb) =&gt; mb.Entity&lt;Post&gt;().HasIndex(p =&gt; p.BlogId);
}
</code></pre>
<h2 id="queries-and-tracking">Queries and tracking</h2>
<pre><code class="language-csharp">using var db = new AppDb();
db.Database.EnsureCreated();
db.Blogs.Add(new Blog { Title = &quot;Hello&quot; });
db.SaveChanges();

var blogs = await db.Blogs.AsNoTracking().Where(b =&gt; b.Title.Contains(&quot;H&quot;)).ToListAsync();
</code></pre>
<h2 id="migrations-concept">Migrations (concept)</h2>
<ul>
<li>Add: dotnet ef migrations add Initial</li>
<li>Update DB: dotnet ef database update</li>
<li>Track schema changes over time; commit migration files.</li>
</ul>
<h2 id="tips-6">Tips</h2>
<ul>
<li>Scope DbContext per unit of work (e.g., per web request).</li>
<li>Use AsNoTracking for read-only queries; include navigation properties with <code>.Include</code> when needed.</li>
</ul>
<h2 id="practice-2">Practice</h2>
<ul>
<li>Add a unique index to Blog.Title using Fluent API and verify the constraint.</li>
<li>Demonstrate tracking vs AsNoTracking and explain memory/perf impact in a list view.</li>
<li>Implement a one-to-many with cascade delete and write a test to verify.</li>
</ul>
<h2 id="theory">Theory</h2>
<h3 id="change-tracking-and-state">Change tracking and state</h3>
<ul>
<li>DbContext tracks entity instances with states: Added, Modified, Deleted, Unchanged.</li>
<li><code>DetectChanges</code> scans tracked entities; disable or minimize tracking for large read scenarios.</li>
<li>Use <code>AsNoTracking</code> for queries that don’t modify data; reattach entities with explicit states when updating detached graphs.</li>
</ul>
<h3 id="linq-translation">LINQ translation</h3>
<ul>
<li>Most query operators translate to SQL; some methods are client-evaluated—verify using <code>ToQueryString()</code>.</li>
<li>Prevent N+1 by using <code>Include</code>/<code>ThenInclude</code> or composing joins intentionally.</li>
</ul>
<h3 id="transactions-and-concurrency">Transactions and concurrency</h3>
<ul>
<li><code>SaveChanges</code> runs in a transaction by default; use explicit transactions for multiple SaveChanges or cross-context operations.</li>
<li>Implement optimistic concurrency with a rowversion/timestamp column; handle <code>DbUpdateConcurrencyException</code> by reloading/merging.</li>
</ul>
<h3 id="migrations-practices">Migrations practices</h3>
<ul>
<li>Keep migrations small, named, and reviewed; include data migrations when needed.</li>
<li>For destructive schema changes, back up and apply in maintenance windows.</li>
</ul>
<hr />
<h1 id="file-io">File I/O</h1>
<h2 id="streams">Streams</h2>
<pre><code class="language-csharp">await using var fs = new FileStream(&quot;data.bin&quot;, FileMode.Create, FileAccess.Write, FileShare.None, 8192, useAsync: true);
var bytes = Encoding.UTF8.GetBytes(&quot;hello&quot;);
await fs.WriteAsync(bytes);
</code></pre>
<h2 id="text-convenience">Text convenience</h2>
<pre><code class="language-csharp">File.WriteAllText(&quot;greet.txt&quot;, &quot;hi&quot;);
var text = File.ReadAllText(&quot;greet.txt&quot;);
</code></pre>
<h2 id="json-serialization">JSON serialization</h2>
<pre><code class="language-csharp">record Person(string Name, int Age);
var json = System.Text.Json.JsonSerializer.Serialize(new Person(&quot;Ada&quot;, 28));
var p = System.Text.Json.JsonSerializer.Deserialize&lt;Person&gt;(json);
</code></pre>
<h2 id="xml-serialization">XML serialization</h2>
<pre><code class="language-csharp">var xmlSer = new System.Xml.Serialization.XmlSerializer(typeof(Person));
await using var xfs = File.Create(&quot;person.xml&quot;);
xmlSer.Serialize(xfs, new Person(&quot;Ada&quot;, 28));
</code></pre>
<h2 id="tips-7">Tips</h2>
<ul>
<li>Prefer async IO for scalability in servers; sync is often fine for small local work.</li>
<li>Use File.ReadLines (lazy) over ReadAllLines (eager) for large files.</li>
</ul>
<hr />
<h1 id="wpf-xaml-basics">WPF: XAML Basics</h1>
<h2 id="layouts">Layouts</h2>
<pre><code class="language-xml">&lt;Grid&gt;
	&lt;Grid.RowDefinitions&gt;
		&lt;RowDefinition Height=&quot;Auto&quot;/&gt;
		&lt;RowDefinition Height=&quot;*&quot;/&gt;
	&lt;/Grid.RowDefinitions&gt;
	&lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;8&quot;&gt;
		&lt;TextBlock Text=&quot;Name:&quot; Margin=&quot;0,0,8,0&quot;/&gt;
		&lt;TextBox Width=&quot;200&quot; Text=&quot;{Binding Name, UpdateSourceTrigger=PropertyChanged}&quot;/&gt;
	&lt;/StackPanel&gt;
	&lt;ListBox Grid.Row=&quot;1&quot; ItemsSource=&quot;{Binding Items}&quot;/&gt;
	&lt;/Grid&gt;
</code></pre>
<h2 id="data-binding-with-inotifypropertychanged">Data Binding with INotifyPropertyChanged</h2>
<pre><code class="language-csharp">public class MainViewModel : INotifyPropertyChanged
{
		private string _name = string.Empty;
		public string Name { get =&gt; _name; set { if (_name!=value){ _name=value; OnPropertyChanged(); } } }
		public ObservableCollection&lt;string&gt; Items { get; } = new();
		public event PropertyChangedEventHandler? PropertyChanged;
		void OnPropertyChanged([CallerMemberName] string? n=null) =&gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(n));
}
</code></pre>
<h2 id="commands-basic">Commands (basic)</h2>
<pre><code class="language-csharp">public class RelayCommand : ICommand
{
		private readonly Action _exec; private readonly Func&lt;bool&gt;? _can;
		public RelayCommand(Action exec, Func&lt;bool&gt;? can=null){_exec=exec;_can=can;}
		public event EventHandler? CanExecuteChanged;
		public bool CanExecute(object? p)=&gt;_can?.Invoke()??true;
		public void Execute(object? p)=&gt;_exec();
		public void RaiseCanExecuteChanged()=&gt;CanExecuteChanged?.Invoke(this, EventArgs.Empty);
}
</code></pre>
<h2 id="binding-modes-and-validation">Binding modes and validation</h2>
<ul>
<li>Modes: OneTime, OneWay, TwoWay (default for TextBox.Text), OneWayToSource.</li>
<li>Validation: IDataErrorInfo/INotifyDataErrorInfo; ValidationRules on bindings.</li>
</ul>
<h2 id="practice-3">Practice</h2>
<ul>
<li>Bind a Slider to a numeric property (TwoWay) and display its value.</li>
<li>Add validation to disallow empty names and show a red adornment.</li>
</ul>
<hr />
<h1 id="wpf-advanced">WPF: Advanced</h1>
<h2 id="styles-and-templates">Styles and Templates</h2>
<pre><code class="language-xml">&lt;Window.Resources&gt;
	&lt;Style TargetType=&quot;Button&quot;&gt;
		&lt;Setter Property=&quot;Margin&quot; Value=&quot;4&quot;/&gt;
	&lt;/Style&gt;
	&lt;DataTemplate DataType=&quot;{x:Type vm:Person}&quot;&gt;
		&lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;
			&lt;TextBlock Text=&quot;{Binding First}&quot;/&gt;
			&lt;TextBlock Text=&quot; &quot;/&gt;
			&lt;TextBlock Text=&quot;{Binding Last}&quot;/&gt;
		&lt;/StackPanel&gt;
	&lt;/DataTemplate&gt;
 &lt;/Window.Resources&gt;
</code></pre>
<h2 id="commands-and-mvvm">Commands and MVVM</h2>
<pre><code class="language-csharp">public class MainViewModel
{
		public ObservableCollection&lt;Person&gt; People { get; } = new();
		public ICommand AddPerson { get; }
		public MainViewModel(){ AddPerson = new RelayCommand(() =&gt; People.Add(new Person(&quot;Ada&quot;,&quot;Lovelace&quot;))); }
}
</code></pre>
<h2 id="binding-diagnostics">Binding diagnostics</h2>
<ul>
<li>Use PresentationTraceSources for binding debug.</li>
<li>Enable exceptions on binding failures in dev.</li>
</ul>
<h2 id="theory-1">Theory</h2>
<h3 id="visual-vs-logical-tree">Visual vs Logical Tree</h3>
<ul>
<li>Logical tree is used by resources and data binding; visual tree shows rendered element composition.</li>
<li>Inspect with Live Visual Tree or tools like Snoop.</li>
</ul>
<h3 id="dependency-properties">Dependency Properties</h3>
<ul>
<li>Provide WPF-level property system: default values, change callbacks, styling/animation, value precedence.</li>
<li>Register via <code>DependencyProperty.Register</code> and expose CLR wrappers.</li>
</ul>
<h3 id="data-templates-virtualization">Data Templates &amp; Virtualization</h3>
<ul>
<li>Use DataTemplate to define item visuals; prefer virtualization for large item sources.</li>
<li>Enable <code>VirtualizingStackPanel.IsVirtualizing=&quot;True&quot;</code> and recycling mode for performance.</li>
</ul>
<h3 id="performance-tips">Performance tips</h3>
<ul>
<li>Freeze Freezables (Brush, Transform) when immutable.</li>
<li>Reduce layout complexity; flatten hierarchies; avoid heavy triggers.</li>
</ul>
<hr />
<h1 id="asp.net-core-fundamentals">ASP.NET Core Fundamentals</h1>
<h2 id="middleware-pipeline">Middleware pipeline</h2>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.Use(async (ctx, next) =&gt; { Console.WriteLine($&quot;{ctx.Request.Path}&quot;); await next(); });
app.MapGet(&quot;/hello&quot;, () =&gt; &quot;world&quot;);
app.Run();
</code></pre>
<h2 id="razor-pages-vs-mvc">Razor Pages vs MVC</h2>
<ul>
<li>Razor Pages: page-focused, good for simple apps.</li>
<li>MVC: controllers/views, better for larger apps and separation concerns.</li>
</ul>
<h2 id="minimal-apis">Minimal APIs</h2>
<pre><code class="language-csharp">app.MapPost(&quot;/sum&quot;, (int a, int b) =&gt; Results.Ok(new { sum = a + b }));
</code></pre>
<h2 id="web-api-essentials">Web API essentials</h2>
<ul>
<li>Model binding, validation attributes, filters, content negotiation (JSON by default).</li>
</ul>
<h2 id="theory-2">Theory</h2>
<h3 id="dependency-injection">Dependency Injection</h3>
<ul>
<li>Built-in DI supports Singleton, Scoped (per-request), and Transient lifetimes.</li>
<li>Prefer constructor injection; avoid static/service locator patterns.</li>
</ul>
<h3 id="model-binding-validation">Model Binding &amp; Validation</h3>
<ul>
<li>Binds from route, query, headers, and body. Use <code>[FromBody]</code>, <code>[FromQuery]</code> etc. to be explicit.</li>
<li>Validate with data annotations; check <code>ModelState.IsValid</code> or rely on automatic 400 with ApiController.</li>
</ul>
<h3 id="configuration-options">Configuration &amp; Options</h3>
<ul>
<li>Combine appsettings.json, environment variables, and secrets. Bind strongly-typed settings via <code>IOptions&lt;T&gt;</code>.</li>
</ul>
<h3 id="logging-observability">Logging &amp; Observability</h3>
<ul>
<li>Use <code>ILogger&lt;T&gt;</code> for structured logs. Add correlation IDs and health checks.</li>
<li>Consider OpenTelemetry for traces/metrics, and Serilog/Sinks for log shipping.</li>
</ul>
<hr />
<h1 id="blazor">Blazor</h1>
<h2 id="component-basics">Component basics</h2>
<pre><code class="language-razor">@page &quot;/counter&quot;
&lt;h3&gt;Counter&lt;/h3&gt;
&lt;p&gt;Current count: @count&lt;/p&gt;
&lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;Increment&quot;&gt;Click me&lt;/button&gt;
@code { int count; void Increment() =&gt; count++; }
</code></pre>
<h2 id="parameters-and-cascading-values">Parameters and cascading values</h2>
<pre><code class="language-razor">&lt;MyCard Title=&quot;Hello&quot;&gt;Content&lt;/MyCard&gt;

@code {
	[Parameter] public string Title { get; set; } = string.Empty;
}
</code></pre>
<h2 id="dependency-injection-1">Dependency injection</h2>
<pre><code class="language-razor">@inject HttpClient Http
@code {
	protected override async Task OnInitializedAsync() { var data = await Http.GetStringAsync(&quot;/api&quot;); }
}
</code></pre>
<h2 id="hosting-models">Hosting models</h2>
<ul>
<li>Server: thin client, low download, requires persistent connection.</li>
<li>WebAssembly: runs in browser, offline capable, larger download.</li>
</ul>
<h2 id="theory-3">Theory</h2>
<h3 id="rendering-model">Rendering model</h3>
<ul>
<li>Blazor uses a diffing renderer; components re-render when parameters or state change via <code>StateHasChanged</code>.</li>
<li>Server model sends UI diffs over SignalR; WebAssembly renders in the browser.</li>
</ul>
<h3 id="component-lifecycle">Component lifecycle</h3>
<ul>
<li>Hooks: <code>OnInitialized[Async]</code>, <code>OnParametersSet[Async]</code>, <code>OnAfterRender[Async]</code> (and Async variants) control setup and post-render work.</li>
<li>Implement <code>IDisposable</code> to clean up timers/subscriptions.</li>
</ul>
<h3 id="js-interop">JS interop</h3>
<ul>
<li>Use <code>IJSRuntime</code> and JS modules for interop; keep DOM-specific tasks in JS.</li>
<li>Prefer strongly-typed wrappers for maintainability.</li>
</ul>
<hr />
<h1 id="web-security">Web Security</h1>
<h2 id="authentication">Authentication</h2>
<ul>
<li>Cookies (server-rendered sites) vs JWT (APIs/SPAs). External providers via OAuth/OIDC.</li>
</ul>
<pre><code class="language-csharp">builder.Services.AddAuthentication(&quot;Bearer&quot;).AddJwtBearer();
</code></pre>
<h2 id="authorization">Authorization</h2>
<h2 id="security-checklist-practical">Security checklist (practical)</h2>
<ul>
<li>Enforce HTTPS; add HSTS in production.</li>
<li>Validate and encode all inputs/outputs to prevent XSS/SQLi.</li>
<li>Use ASP.NET Core Data Protection for key management.</li>
<li>Store secrets outside source control (User Secrets/Azure Key Vault).</li>
<li>Implement proper CORS policy (allow only known origins, methods, headers).</li>
<li>Add rate limiting for public endpoints.</li>
<li>Log auth failures and suspicious activities; monitor with alerts.</li>
<li>Roles: [Authorize(Roles = &quot;Admin&quot;)]</li>
<li>Policies: configure requirements centrally.</li>
</ul>
<pre><code class="language-csharp">builder.Services.AddAuthorization(o =&gt; o.AddPolicy(&quot;AdultOnly&quot;, p =&gt; p.RequireClaim(&quot;age&quot;, &quot;18+&quot;)));
app.MapGet(&quot;/secure&quot;, [Authorize(Policy=&quot;AdultOnly&quot;)] () =&gt; &quot;ok&quot;);
</code></pre>
<h2 id="https-cors">HTTPS &amp; CORS</h2>
<pre><code class="language-csharp">app.UseHttpsRedirection();
app.UseCors(p =&gt; p.WithOrigins(&quot;https://example.com&quot;).AllowAnyHeader().AllowAnyMethod());
</code></pre>
<hr />
<h1 id="razor-pages-vs-mvc-in-asp.net-core">Razor Pages vs MVC in ASP.NET Core</h1>
<p>Understand when to choose Razor Pages or MVC:</p>
<ul>
<li>Razor Pages: Page-focused, minimal ceremony, great for simple CRUD and forms. Files live side-by-side (.cshtml + PageModel).</li>
<li>MVC: Controller-centric, great for larger apps, strong separation of concerns, filters, and complex routing.</li>
</ul>
<p>Key differences:</p>
<ul>
<li>Handler methods (OnGet/OnPost) in Pages vs Controller actions.</li>
<li>Routing conventions: folder-based for Pages vs attribute/conventional for MVC.</li>
<li>View models: both support, MVC often uses dedicated DTOs and services.</li>
</ul>
<p>When to pick:</p>
<ul>
<li>Small to medium apps, internal tools → Razor Pages.</li>
<li>Complex APIs, multiple controllers, rich filters → MVC.</li>
</ul>
<p>Tip: You can mix both in one app.</p>
<hr />
<h1 id="xamarin.forms">Xamarin.Forms</h1>
<p>Note: .NET MAUI is the modern successor; concepts are similar.</p>
<h2 id="xaml-layouts">XAML Layouts</h2>
<pre><code class="language-xml">&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
						 xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
						 x:Class=&quot;Sample.MainPage&quot;&gt;
	&lt;StackLayout Padding=&quot;20&quot;&gt;
		&lt;Label Text=&quot;Hello&quot;/&gt;
		&lt;Entry Text=&quot;{Binding Name}&quot;/&gt;
		&lt;Button Text=&quot;Click&quot; Command=&quot;{Binding SayHello}&quot;/&gt;
	&lt;/StackLayout&gt;
 &lt;/ContentPage&gt;
</code></pre>
<h2 id="navigation">Navigation</h2>
<pre><code class="language-csharp">await Navigation.PushAsync(new DetailsPage());
</code></pre>
<h2 id="mvvm">MVVM</h2>
<ul>
<li>Bind View to ViewModel properties/commands via INotifyPropertyChanged and ICommand.</li>
</ul>
<hr />
<h1 id="mobile-features">Mobile Features</h1>
<h2 id="local-storage-sqlite.net">Local Storage (SQLite.NET)</h2>
<pre><code class="language-csharp">using SQLite;
public class Person { [PrimaryKey, AutoIncrement] public int Id { get; set; } public string Name { get; set; } = &quot;&quot;; }
var db = new SQLiteAsyncConnection(dbPath);
await db.CreateTableAsync&lt;Person&gt;();
await db.InsertAsync(new Person { Name = &quot;Ada&quot; });
</code></pre>
<h2 id="platform-specific-code">Platform-specific code</h2>
<pre><code class="language-csharp">public interface IDeviceInfo { string GetModel(); }
// Implement per platform and register with DependencyService or via MAUI handlers.
</code></pre>
<h2 id="oauth-2.0-oidc">OAuth 2.0 / OIDC</h2>
<ul>
<li>Use the system browser; follow the authorization code flow with PKCE.</li>
<li>Store tokens securely (Keychain/Keystore); refresh tokens carefully.</li>
</ul>
<hr />
<h1 id="net-maui-intro">.NET MAUI Intro</h1>
<p>Modern cross-platform UI framework (Windows, macOS, iOS, Android) succeeding Xamarin.Forms.</p>
<p>Concepts:</p>
<ul>
<li>Single project targeting multiple platforms</li>
<li>XAML UI with MVVM</li>
<li>Handlers (replacing renderers)</li>
<li>Essentials (device APIs)</li>
</ul>
<p>Quick start steps:</p>
<ol>
<li>Install .NET SDK with MAUI workload</li>
<li>Create a new MAUI app</li>
<li>Run on Windows or Android emulator</li>
</ol>
<p>Migration notes from Xamarin.Forms:</p>
<ul>
<li>Namespaces and APIs updated</li>
<li>Renderers → Handlers</li>
<li>Shell navigation remains, improved</li>
</ul>
<p>When to choose MAUI vs Xamarin:</p>
<ul>
<li>New apps: MAUI.</li>
<li>Existing Xamarin.Forms: plan for migration.</li>
</ul>
<hr />
<h1 id="cloud-deployment">Cloud Deployment</h1>
<h2 id="azure-app-service-typical-flow">Azure App Service (typical flow)</h2>
<ul>
<li>Publish from CLI: <code>dotnet publish -c Release</code> then deploy via Azure CLI or VS.</li>
<li>Configure app settings/environment variables in App Service (Key Vault for secrets).</li>
<li>Enable logging and Application Insights.</li>
</ul>
<h2 id="docker-containers">Docker containers</h2>
<pre><code class="language-dockerfile">FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 8080
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet publish -c Release -o /out
FROM base AS final
WORKDIR /app
COPY --from=build /out .
ENTRYPOINT [&quot;dotnet&quot;, &quot;WebApi.dll&quot;]
</code></pre>
<h2 id="configuration-secrets">Configuration &amp; secrets</h2>
<ul>
<li>Use appsettings..json + environment variables; never commit secrets.</li>
<li>For cloud, prefer managed secret stores (Azure Key Vault, AWS Secrets Manager).</li>
</ul>
<h2 id="scaling-health">Scaling &amp; health</h2>
<ul>
<li>Health checks endpoint; autoscaling rules; rolling deployments/slots.</li>
</ul>
<hr />
<h1 id="cicd-pipelines">CI/CD Pipelines</h1>
<p>Automate build, test, and deploy on every change.</p>
<h2 id="github-actions-example">GitHub Actions (example)</h2>
<pre><code class="language-yaml">name: build
on: [push, pull_request]
jobs:
	build:
		runs-on: windows-latest
		steps:
			- uses: actions/checkout@v4
			- uses: actions/setup-dotnet@v4
				with: { dotnet-version: '8.0.x' }
			- run: dotnet restore
			- run: dotnet build --no-restore -c Release
			- run: dotnet test --no-build -c Release
</code></pre>
<h2 id="practices">Practices</h2>
<ul>
<li>Build/test on every push and PR; enforce quality gates.</li>
<li>Cache dependencies where possible for speed.</li>
<li>Version artifacts and publish build outputs (e.g., to GitHub Releases).</li>
<li>Use environments and approvals for production.</li>
</ul>
<h2 id="theory-4">Theory</h2>
<ul>
<li>CI validates each change quickly; CD automates deployments with safety checks.</li>
<li>Use separate environments (dev/test/stage/prod) with required reviewers for protected deployments.</li>
<li>Store secrets in platform stores (GitHub Secrets, Azure Key Vault); never commit secrets.</li>
<li>Cache package restores and toolchains to speed up builds; pin versions for reproducibility.</li>
<li>Treat build outputs as artifacts for traceability; sign and checksum where appropriate.</li>
</ul>
<hr />
<h1 id="docker-containers-for.net-apps">Docker Containers for .NET Apps</h1>
<p>This guide shows how to containerize your .NET applications and run them locally. It pairs with the <code>examples/WebApi</code> project.</p>
<h2 id="why-containers">Why containers</h2>
<ul>
<li>Consistent runtime across machines</li>
<li>Fast deploys and easy rollbacks</li>
<li>Great fit for CI/CD and cloud platforms</li>
</ul>
<h2 id="minimal-dockerfile-asp.net-core">Minimal Dockerfile (ASP.NET Core)</h2>
<p>We include a ready-to-use Dockerfile in <code>examples/WebApi</code> targeting .NET 8.</p>
<p>Key points:</p>
<ul>
<li>Multi-stage build (restore/build/publish runtime image)</li>
<li>Non-root user for runtime (where supported)</li>
<li>Expose port 8080 inside the container</li>
</ul>
<h2 id="build-and-run">Build and run</h2>
<ol>
<li>Build image</li>
</ol>
<ul>
<li>Image name: <code>learning-webapi:dev</code></li>
</ul>
<ol start="2">
<li>Run container</li>
</ol>
<ul>
<li>Map host port 8080 to container 8080</li>
<li>Hit http://localhost:8080/swagger</li>
</ul>
<p>Troubleshooting:</p>
<ul>
<li>If the port is in use, change host mapping <code>-p 8081:8080</code> and browse 8081.</li>
<li>Ensure HTTPS is disabled or dev certs are handled inside container; our sample uses HTTP for simplicity.</li>
</ul>
<h2 id="next-steps">Next steps</h2>
<ul>
<li>Push to a registry (Docker Hub, GHCR, ACR)</li>
<li>Deploy to Azure Web App for Containers or Kubernetes</li>
</ul>
<hr />
<h1 id="exam-cram-c.net-quick-reference">Exam Cram: C#/.NET Quick Reference</h1>
<p>Use this as your last‑minute refresher. Practice from the section prompts in each chapter; this page is for recall.</p>
<h2 id="core-c">Core C#</h2>
<ul>
<li>Value vs reference: structs/enums vs classes/arrays/strings (string is reference/immutable). Passing ref type copies the reference.</li>
<li>Conversions: implicit (safe) vs explicit (cast); checked for overflow; boxing/unboxing for value types.</li>
<li>Flow: if/else, switch (patterns, when guards), loops (for/while/foreach), break/continue.</li>
<li>Iterators: <code>yield return</code> (lazy), <code>yield break</code> (stop). Side effects occur on enumeration.</li>
</ul>
<h2 id="oop-essentials">OOP essentials</h2>
<ul>
<li>Encapsulation: hide fields; validate in properties; keep invariants.</li>
<li>Inheritance: <code>virtual/override/abstract/sealed</code>; prefer composition for reuse.</li>
<li>Polymorphism: interfaces or virtual methods; favor interface‑first design.</li>
<li>Records: value semantics and with‑expressions; great for immutable DTOs.</li>
</ul>
<h2 id="collections-pick-fast">Collections: pick fast</h2>
<ul>
<li>List<T>: ordered, O(1) index, appends amortized O(1).</li>
<li>Dictionary&lt;TKey,TValue&gt;: O(1) avg lookup; use StringComparer for string keys.</li>
<li>HashSet<T>: fast uniqueness membership.</li>
<li>Queue/Stack: FIFO/LIFO O(1) ops; BlockingCollection/ConcurrentBag for threads.</li>
<li>Avoid repeated List.Remove in loops; prefer RemoveAll/filtering.</li>
</ul>
<h2 id="exceptions">Exceptions</h2>
<ul>
<li>Use exceptions for exceptional paths; not control flow.</li>
<li>Pattern: try → specific catch → generic catch (log) → finally. Filters: <code>catch (X ex) when (cond)</code>.</li>
<li>Rethrow with <code>throw;</code> to preserve stack; prefer <code>TryXxx</code> for expected failures.</li>
<li>Custom exception: serializable, useful properties, preserve inner.</li>
</ul>
<h2 id="delegates-events">Delegates &amp; events</h2>
<ul>
<li>Delegates: <code>Action</code>, <code>Func</code>, <code>Predicate</code> cover most needs. Lambdas can capture variables (closures).</li>
<li>Events: <code>event EventHandler&lt;T&gt;</code>; raise with null‑conditional; unsubscribe to avoid leaks.</li>
</ul>
<h2 id="linq-map">LINQ map</h2>
<ul>
<li>Filter: Where; Project: Select/SelectMany; Sort: OrderBy/ThenBy; Group: GroupBy; Join: Join/GroupJoin; Sets: Distinct/Union/Intersect/Except; Aggregates: Count/Sum/Average/Aggregate.</li>
<li>Deferred vs immediate: pipelines run on enumeration; materialize with ToList/ToArray when needed.</li>
<li>IEnumerable vs IQueryable: in‑memory vs provider‑translated; avoid client‑only methods in IQueryable.</li>
</ul>
<h2 id="asyncawait">Async/await</h2>
<ul>
<li>Don’t block (no .Result/.Wait); async all the way. Use <code>Task.WhenAll</code> for parallel async IO.</li>
<li>Cancellation: pass CancellationToken; catch OperationCanceledException. Timeouts via CTS.</li>
<li>Libraries: <code>ConfigureAwait(false)</code>; UI apps usually capture context.</li>
<li>Parallel: CPU‑bound → Parallel.ForEach/PLINQ; IO‑bound → async + WhenAll.</li>
</ul>
<h2 id="ado.net-vs-ef-core">ADO.NET vs EF Core</h2>
<ul>
<li>ADO.NET: explicit SqlConnection/Command/Reader; optimal control and perf.</li>
<li>EF Core: LINQ + change tracking; faster dev, migrations, relationships.</li>
<li>Transactions: <code>BeginTransaction</code> + commit/rollback. Parameters prevent SQL injection.</li>
<li>EF tips: scope DbContext per unit of work; <code>AsNoTracking</code> for read‑only; <code>Include</code> for navs; migrations: <code>add</code> then <code>update</code>.</li>
</ul>
<h2 id="file-io-1">File I/O</h2>
<ul>
<li>Use async IO on servers; <code>File.ReadLines</code> for lazy large files. JSON with System.Text.Json; XML with XmlSerializer.</li>
</ul>
<h2 id="wpf">WPF</h2>
<ul>
<li>Binding: INotifyPropertyChanged; modes (OneWay, TwoWay). Commands (ICommand) decouple UI.</li>
<li>Validation: IDataErrorInfo/INotifyDataErrorInfo or ValidationRules on bindings.</li>
</ul>
<h2 id="asp.net-core">ASP.NET Core</h2>
<ul>
<li>Pipeline order: UseRouting → UseAuthentication → UseAuthorization → Map endpoints.</li>
<li>Minimal API shape: <code>app.MapGet(&quot;/path&quot;, (deps, ...) =&gt; Results.Ok(...));</code></li>
<li>Model binding, validation attributes, content negotiation (JSON default).</li>
</ul>
<h2 id="blazor-1">Blazor</h2>
<ul>
<li>Server vs WASM: latency/connection vs offline/native‑like; same component model.</li>
<li>@inject DI for services; parameters via <code>[Parameter]</code>.</li>
</ul>
<h2 id="security">Security</h2>
<ul>
<li>Cookies (server pages) vs JWT (APIs/SPAs). HTTPS always; strict CORS.</li>
<li>Roles: <code>[Authorize(Roles=&quot;Admin&quot;)]</code>; Policies: central requirements; claims‑based.</li>
</ul>
<h2 id="clrbcl">CLR/BCL</h2>
<ul>
<li>GC: Gen0/1/2, LOH; allocations cheap when short‑lived. Exceptions are costly when thrown.</li>
<li>JIT: tiered compilation, ReadyToRun; diagnostics via dotnet‑trace/counters.</li>
<li>Prefer BCL types first (collections, IO, HttpClient, JsonSerializer).</li>
</ul>
<h2 id="devops">DevOps</h2>
<ul>
<li>CI: restore/build/test on push/PR. Cache deps. Fail fast on warnings.</li>
<li>Docker: multi‑stage build; environment via variables; health checks.</li>
<li>Cloud: config from env/Key Vault; enable logs and health probes; use slots for safe deploys.</li>
</ul>
<h2 id="lastminute-checks">Last‑minute checks</h2>
<ul>
<li>Nullable enabled; guard public APIs.</li>
<li>Dispose IDisposables (<code>using</code>/<code>await using</code>).</li>
<li>Avoid multiple enumeration of expensive sources.</li>
<li>Validate user input; parameterize SQL; never log secrets.</li>
</ul>

</body>
</html>