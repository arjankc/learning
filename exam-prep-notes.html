<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>C#/.NET Exam Preparation Notes</title>
    <style>
        :root { --ink: #111; --muted: #666; }
        body { color: var(--ink); font-family: -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.55; max-width: 900px; margin: 1rem auto; padding: 0 1rem; }
        code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        pre { background: #f6f8fa; padding: 12px; overflow: auto; border-radius: 6px; }
        h1 { font-size: 1.9rem; margin-top: 2.2rem; }
        h2 { font-size: 1.5rem; margin-top: 1.8rem; }
        h3 { font-size: 1.2rem; margin-top: 1.4rem; }
        hr { margin: 2rem 0; }
    /* page-break removed to allow continuous flow */
        .toc h1 { margin-top: 0; }
        @media print {
            @page { margin: 16mm 12mm; size: A4; }
            body { margin: 0; }
            header, footer { position: fixed; left: 0; right: 0; color: var(--muted); font-size: 10pt; }
            header { top: 0; }
            footer { bottom: 0; }
            footer .page:after { content: counter(page); }
            pre { white-space: pre-wrap; }
            /* Don't append URLs after links to save space */
            a[href]:after { content: ""; }
        }
    </style>
</head>
<body>
<header></header>
<footer><span class="page"></span></footer>
<h1 id="c.net-learning-notes">C#/.NET Learning Notes</h1>
<p>Compiled for offline study and printing. Start with the Study Guide.</p>
<ul>
<li><a href="00-exam-prep.md">C#/.NET Exam Preparation Notes</a></li>
</ul>
<h1 id="c.net-exam-preparation-notes">C#/.NET Exam Preparation Notes</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#visual-programming">Visual Programming</a></li>
<li><a href="#event-driven-programming">Event-Driven Programming</a></li>
<li><a href="#net-framework-architecture">.NET Framework Architecture</a></li>
<li><a href="#rad-tools">RAD Tools</a></li>
<li><a href="#type-conversion">Type Conversion</a></li>
<li><a href="#structures-vs-enumerations">Structures vs Enumerations</a></li>
<li><a href="#collections">Collections (Generic and Non-Generic)</a></li>
<li><a href="#regular-expressions">Regular Expressions</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
<li><a href="#abstract-classes-vs-interfaces">Abstract Classes vs Interfaces</a></li>
<li><a href="#inheritance-and-encapsulation">Inheritance and Encapsulation</a></li>
<li><a href="#exception-handling">Exception Handling</a></li>
<li><a href="#parallel-programming">Parallel Programming</a></li>
<li><a href="#adonet">ADO.NET</a></li>
<li><a href="#wpf">WPF</a></li>
<li><a href="#aspnet-aspnet-core">ASP.NET &amp; ASP.NET Core</a></li>
<li><a href="#blazor">Blazor</a></li>
<li><a href="#xamarin">Xamarin</a></li>
</ol>
<h2 id="visual-programming">Visual Programming</h2>
<h3 id="definition">Definition</h3>
<p>Visual programming is a programming paradigm that uses graphical elements rather than text to create programs. It allows developers to manipulate program elements graphically rather than textually.</p>
<h3 id="visual-programming-vs-text-based-programming">Visual Programming vs Text-Based Programming</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Visual Programming</th>
<th>Text-Based Programming</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Interface</strong></td>
<td>Drag-and-drop, visual components</td>
<td>Text editor, code writing</td>
</tr>
<tr>
<td><strong>Learning Curve</strong></td>
<td>Easier for beginners</td>
<td>Steeper learning curve</td>
</tr>
<tr>
<td><strong>Flexibility</strong></td>
<td>Limited by available components</td>
<td>Full control over code</td>
</tr>
<tr>
<td><strong>Debugging</strong></td>
<td>Visual debugging tools</td>
<td>Text-based debugging</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>May have overhead</td>
<td>Direct control over performance</td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>Visual Studio Designer, Scratch</td>
<td>C#, Java, Python</td>
</tr>
</tbody>
</table>
<h3 id="examples-in.net">Examples in .NET</h3>
<ul>
<li>[COVERED]<strong>Visual Studio Designer</strong>: For WPF, WinForms</li>
<li>[COVERED]<strong>XAML Designer</strong>: For WPF and UWP applications</li>
<li>[COVERED]<strong>Blazor Visual Designer</strong>: For web components</li>
</ul>
<pre><code class="language-csharp">// Text-based approach
Button myButton = new Button();
myButton.Text = &quot;Click Me&quot;;
myButton.Width = 100;
myButton.Height = 30;
myButton.Click += MyButton_Click;

// Visual approach (generated code from designer)
// Designer generates similar code but through visual manipulation
</code></pre>
<h2 id="event-driven-programming">Event-Driven Programming</h2>
<h3 id="definition-1">Definition</h3>
<p>Event-driven programming is a paradigm where program flow is determined by events such as user actions, sensor outputs, or message passing.</p>
<h3 id="key-concepts">Key Concepts</h3>
<ol>
<li><strong>Events</strong>: Notifications that something has happened</li>
<li><strong>Event Handlers</strong>: Methods that respond to events</li>
<li><strong>Event Loop</strong>: Continuously monitors for events</li>
<li><strong>Delegates</strong>: Type-safe function pointers in C#</li>
</ol>
<h3 id="example-in-c">Example in C#</h3>
<pre><code class="language-csharp">public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();

        // Subscribe to button click event
        myButton.Click += MyButton_Click;
    }

    // Event handler method
    private void MyButton_Click(object sender, RoutedEventArgs e)
    {
        MessageBox.Show(&quot;Button was clicked!&quot;);
    }
}

// Custom event example
public class Publisher
{
    // Declare event using delegate
    public event Action&lt;string&gt; OnMessagePublished;

    public void PublishMessage(string message)
    {
        // Raise the event
        OnMessagePublished?.Invoke(message);
    }
}

public class Subscriber
{
    public void Subscribe(Publisher pub)
    {
        // Subscribe to event
        pub.OnMessagePublished += HandleMessage;
    }

    private void HandleMessage(string message)
    {
        Console.WriteLine($&quot;Received: {message}&quot;);
    }
}
</code></pre>
<h2 id="net-framework-architecture">.NET Framework Architecture</h2>
<h3 id="key-components">Key Components</h3>
<h4 id="common-language-runtime-clr">1. Common Language Runtime (CLR)</h4>
<ul>
<li>[COVERED]<strong>Memory Management</strong>: Automatic garbage collection</li>
<li>[COVERED]<strong>Type Safety</strong>: Ensures type safety at runtime</li>
<li>[COVERED]<strong>Exception Handling</strong>: Unified exception handling</li>
<li>[COVERED]<strong>Thread Management</strong>: Manages application threads</li>
<li>[COVERED]<strong>Security</strong>: Code access security</li>
</ul>
<h4 id="base-class-library-bcl">2. Base Class Library (BCL)</h4>
<ul>
<li>[COVERED]<strong>System.Object</strong>: Root of all .NET types</li>
<li>[COVERED]<strong>Collections</strong>: Generic and non-generic collections</li>
<li>[COVERED]<strong>I/O</strong>: File and stream operations</li>
<li>[COVERED]<strong>Networking</strong>: Network communication classes</li>
</ul>
<h4 id="net-framework-vs.net-core-vs.net-5">3. .NET Framework vs .NET Core vs .NET 5+</h4>
<table>
<thead>
<tr>
<th>Feature</th>
<th>.NET Framework</th>
<th>.NET Core</th>
<th>.NET 5+</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Platform</strong></td>
<td>Windows only</td>
<td>Cross-platform</td>
<td>Cross-platform</td>
</tr>
<tr>
<td><strong>Open Source</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Good</td>
<td>Better</td>
<td>Best</td>
</tr>
<tr>
<td><strong>Deployment</strong></td>
<td>Framework dependent</td>
<td>Self-contained options</td>
<td>Self-contained options</td>
</tr>
</tbody>
</table>
<h3 id="architecture-diagram">Architecture Diagram</h3>
<pre><code>+-------------------------------------+
|        Your Application            |
+-------------------------------------+
|    Base Class Library (BCL)        |
+-------------------------------------+
|  Common Language Runtime (CLR)     |
+-------------------------------------+
|       Operating System             |
+-------------------------------------+
</code></pre>
<p><strong>Layer Description:</strong></p>
<ul>
<li>[COVERED]<strong>Your Application</strong>: C# code you write (WPF, Console, Web, etc.)</li>
<li>[COVERED]<strong>Base Class Library</strong>: Built-in .NET classes (System.*, Collections, etc.)</li>
<li>[COVERED]<strong>Common Language Runtime</strong>: Memory management, type safety, execution</li>
<li>[COVERED]<strong>Operating System</strong>: Windows, Linux, macOS platform services</li>
</ul>
<h2 id="rad-tools">RAD Tools</h2>
<h3 id="rapid-application-development-rad">Rapid Application Development (RAD)</h3>
<p>RAD is a software development methodology that prioritizes rapid prototyping and quick feedback over long planning cycles.</p>
<h3 id="rad-tools-in.net-ecosystem">RAD Tools in .NET Ecosystem</h3>
<h4 id="visual-studio">1. Visual Studio</h4>
<ul>
<li>[COVERED]<strong>IntelliSense</strong>: Code completion and suggestions</li>
<li>[COVERED]<strong>Debugging Tools</strong>: Breakpoints, watch windows</li>
<li>[COVERED]<strong>Designer Support</strong>: Visual designers for UI</li>
<li>[COVERED]<strong>Project Templates</strong>: Pre-built project structures</li>
</ul>
<h4 id="visual-studio-code">2. Visual Studio Code</h4>
<ul>
<li>[COVERED]<strong>Extensions</strong>: Rich ecosystem of extensions</li>
<li>[COVERED]<strong>Integrated Terminal</strong>: Built-in command line</li>
<li>[COVERED]<strong>Git Integration</strong>: Version control support</li>
</ul>
<h4 id="jetbrains-rider">3. JetBrains Rider</h4>
<ul>
<li>[COVERED]<strong>Advanced Refactoring</strong>: Powerful code transformation tools</li>
<li>[COVERED]<strong>Unit Testing</strong>: Integrated test runner</li>
<li>[COVERED]<strong>Database Tools</strong>: Built-in database support</li>
</ul>
<h3 id="example-quick-wpf-application">Example: Quick WPF Application</h3>
<pre><code class="language-csharp">// Program.cs - Entry point
using System;
using System.Windows;

namespace QuickApp
{
    public partial class App : Application
    {
        [STAThread]
        public static void Main()
        {
            App app = new App();
            app.Run(new MainWindow());
        }
    }
}

// MainWindow.xaml
&lt;Window x:Class=&quot;QuickApp.MainWindow&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        Title=&quot;Quick RAD App&quot; Height=&quot;200&quot; Width=&quot;300&quot;&gt;
    &lt;StackPanel Margin=&quot;10&quot;&gt;
        &lt;TextBox x:Name=&quot;InputText&quot; Margin=&quot;5&quot;/&gt;
        &lt;Button Content=&quot;Process&quot; Click=&quot;ProcessButton_Click&quot; Margin=&quot;5&quot;/&gt;
        &lt;TextBlock x:Name=&quot;OutputText&quot; Margin=&quot;5&quot;/&gt;
    &lt;/StackPanel&gt;
&lt;/Window&gt;

// MainWindow.xaml.cs
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }

    private void ProcessButton_Click(object sender, RoutedEventArgs e)
    {
        OutputText.Text = $&quot;Processed: {InputText.Text.ToUpper()}&quot;;
    }
}
</code></pre>
<h2 id="type-conversion">Type Conversion</h2>
<h3 id="types-of-conversion">Types of Conversion</h3>
<h4 id="implicit-conversion-automatic">1. Implicit Conversion (Automatic)</h4>
<pre><code class="language-csharp">int intValue = 42;
long longValue = intValue;    // Implicit conversion (safe)
double doubleValue = intValue; // Implicit conversion (safe)

// Implicit conversions for numeric types
byte b = 100;
short s = b;     // byte to short
int i = s;       // short to int
long l = i;      // int to long
float f = l;     // long to float
double d = f;    // float to double
</code></pre>
<h4 id="explicit-conversion-manual">2. Explicit Conversion (Manual)</h4>
<pre><code class="language-csharp">double doubleValue = 42.7;
int intValue = (int)doubleValue;  // Explicit cast (data loss possible)

// Explicit conversions
long longValue = 123456789;
int intValue2 = (int)longValue;   // Potential overflow

// Using Convert class
string numberString = &quot;123&quot;;
int converted = Convert.ToInt32(numberString);
double convertedDouble = Convert.ToDouble(&quot;123.45&quot;);
</code></pre>
<h4 id="boxing-and-unboxing">3. Boxing and Unboxing</h4>
<pre><code class="language-csharp">// Boxing: Value type to reference type
int value = 42;
object boxed = value;         // Boxing

// Unboxing: Reference type to value type
object boxedValue = 42;
int unboxed = (int)boxedValue; // Unboxing

// Performance consideration
List&lt;object&gt; mixedList = new List&lt;object&gt;();
mixedList.Add(42);           // Boxing occurs
mixedList.Add(&quot;Hello&quot;);      // No boxing (already reference type)
</code></pre>
<h4 id="parse-and-tryparse-methods">4. Parse and TryParse Methods</h4>
<pre><code class="language-csharp">// Parse (throws exception on failure)
string input = &quot;123&quot;;
int parsed = int.Parse(input);

// TryParse (returns false on failure)
string userInput = &quot;abc&quot;;
if (int.TryParse(userInput, out int result))
{
    Console.WriteLine($&quot;Parsed: {result}&quot;);
}
else
{
    Console.WriteLine(&quot;Invalid input&quot;);
}

// DateTime parsing
string dateString = &quot;2023-12-25&quot;;
if (DateTime.TryParse(dateString, out DateTime parsedDate))
{
    Console.WriteLine($&quot;Date: {parsedDate:yyyy-MM-dd}&quot;);
}
</code></pre>
<h2 id="structures-vs-enumerations">Structures vs Enumerations</h2>
<h3 id="structures-struct">Structures (struct)</h3>
<h4 id="definition-2">Definition</h4>
<p>Structures are value types that can contain data members and function members.</p>
<h4 id="key-characteristics">Key Characteristics</h4>
<ul>
<li>[COVERED]<strong>Value Type</strong>: Stored on stack</li>
<li>[COVERED]<strong>No Inheritance</strong>: Cannot inherit from other types</li>
<li>[COVERED]<strong>Immutable Recommended</strong>: Should be immutable for best practices</li>
<li>[COVERED]<strong>Default Constructor</strong>: Always available</li>
</ul>
<pre><code class="language-csharp">public struct Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    public double DistanceFromOrigin()
    {
        return Math.Sqrt(X * X + Y * Y);
    }

    public override string ToString()
    {
        return $&quot;({X}, {Y})&quot;;
    }
}

// Usage
Point p1 = new Point(3, 4);
Point p2 = new Point(); // Default constructor (0, 0)
Console.WriteLine(p1.DistanceFromOrigin()); // 5
</code></pre>
<h3 id="enumerations-enum">Enumerations (enum)</h3>
<h4 id="definition-3">Definition</h4>
<p>Enumerations define a set of named constants of the underlying integral numeric type.</p>
<h4 id="key-characteristics-1">Key Characteristics</h4>
<ul>
<li>[COVERED]<strong>Named Constants</strong>: Improve code readability</li>
<li>[COVERED]<strong>Type Safe</strong>: Prevents invalid values</li>
<li>[COVERED]<strong>Underlying Type</strong>: Default is int, can be changed</li>
<li>[COVERED]<strong>Flags Support</strong>: Can be combined using bitwise operations</li>
</ul>
<pre><code class="language-csharp">// Basic enumeration
public enum OrderStatus
{
    Pending,      // 0
    Processing,   // 1
    Shipped,      // 2
    Delivered,    // 3
    Cancelled     // 4
}

// Custom underlying type and values
public enum Priority : byte
{
    Low = 1,
    Medium = 5,
    High = 10,
    Critical = 20
}

// Flags enumeration
[Flags]
public enum FilePermissions
{
    None = 0,
    Read = 1,
    Write = 2,
    Execute = 4,
    ReadWrite = Read | Write,
    All = Read | Write | Execute
}

// Usage examples
OrderStatus status = OrderStatus.Processing;

// Enum methods
string statusName = status.ToString();              // &quot;Processing&quot;
OrderStatus parsed = Enum.Parse&lt;OrderStatus&gt;(&quot;Shipped&quot;);
bool isValid = Enum.IsDefined(typeof(OrderStatus), 3); // true

// Flags usage
FilePermissions permissions = FilePermissions.Read | FilePermissions.Write;
bool canRead = permissions.HasFlag(FilePermissions.Read);    // true
bool canExecute = permissions.HasFlag(FilePermissions.Execute); // false
</code></pre>
<h3 id="comparison-table">Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>struct</th>
<th>enum</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Purpose</strong></td>
<td>Data containers</td>
<td>Named constants</td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td>Value type</td>
<td>Value type (integral)</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>Stack</td>
<td>Constant value</td>
</tr>
<tr>
<td><strong>Inheritance</strong></td>
<td>No inheritance</td>
<td>No inheritance</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>Can have methods</td>
<td>Only predefined methods</td>
</tr>
<tr>
<td><strong>Mutability</strong></td>
<td>Should be immutable</td>
<td>Immutable</td>
</tr>
</tbody>
</table>
<h2 id="collections">Collections</h2>
<h3 id="generic-collections-recommended">Generic Collections (Recommended)</h3>
<h4 id="list">1. List<T></h4>
<pre><code class="language-csharp">// Dynamic array implementation
List&lt;string&gt; names = new List&lt;string&gt;();
names.Add(&quot;Alice&quot;);
names.Add(&quot;Bob&quot;);
names.AddRange(new[] { &quot;Charlie&quot;, &quot;David&quot; });

// Access and modification
names[0] = &quot;Alice Smith&quot;;
names.Insert(1, &quot;Betty&quot;);
names.Remove(&quot;Bob&quot;);
names.RemoveAt(2);

// Iteration
foreach (string name in names)
{
    Console.WriteLine(name);
}

// LINQ operations
var longNames = names.Where(n =&gt; n.Length &gt; 5).ToList();
</code></pre>
<h4 id="dictionarytkey-tvalue">2. Dictionary&lt;TKey, TValue&gt;</h4>
<pre><code class="language-csharp">Dictionary&lt;string, int&gt; ages = new Dictionary&lt;string, int&gt;
{
    [&quot;Alice&quot;] = 30,
    [&quot;Bob&quot;] = 25
};

// Adding and accessing
ages.Add(&quot;Charlie&quot;, 35);
ages[&quot;David&quot;] = 28; // Add or update

// Safe access
if (ages.TryGetValue(&quot;Alice&quot;, out int aliceAge))
{
    Console.WriteLine($&quot;Alice is {aliceAge} years old&quot;);
}

// Iteration
foreach (KeyValuePair&lt;string, int&gt; kvp in ages)
{
    Console.WriteLine($&quot;{kvp.Key}: {kvp.Value}&quot;);
}
</code></pre>
<h4 id="hashset">3. HashSet<T></h4>
<pre><code class="language-csharp">HashSet&lt;string&gt; uniqueNames = new HashSet&lt;string&gt;();
uniqueNames.Add(&quot;Alice&quot;);
uniqueNames.Add(&quot;Bob&quot;);
uniqueNames.Add(&quot;Alice&quot;); // Duplicate ignored

// Set operations
HashSet&lt;string&gt; otherNames = new HashSet&lt;string&gt; { &quot;Bob&quot;, &quot;Charlie&quot; };
uniqueNames.UnionWith(otherNames);        // Union
uniqueNames.IntersectWith(otherNames);    // Intersection
bool contains = uniqueNames.Contains(&quot;Alice&quot;);
</code></pre>
<h4 id="queue-and-stack">4. Queue<T> and Stack<T></h4>
<pre><code class="language-csharp">// Queue (FIFO - First In, First Out)
Queue&lt;string&gt; taskQueue = new Queue&lt;string&gt;();
taskQueue.Enqueue(&quot;Task 1&quot;);
taskQueue.Enqueue(&quot;Task 2&quot;);
string nextTask = taskQueue.Dequeue(); // &quot;Task 1&quot;

// Stack (LIFO - Last In, First Out)
Stack&lt;string&gt; undoStack = new Stack&lt;string&gt;();
undoStack.Push(&quot;Action 1&quot;);
undoStack.Push(&quot;Action 2&quot;);
string lastAction = undoStack.Pop(); // &quot;Action 2&quot;
</code></pre>
<h3 id="non-generic-collections-legacy">Non-Generic Collections (Legacy)</h3>
<h4 id="arraylist">ArrayList</h4>
<pre><code class="language-csharp">// Non-generic - boxing/unboxing occurs
ArrayList list = new ArrayList();
list.Add(42);        // Boxing
list.Add(&quot;Hello&quot;);   // Reference type
int value = (int)list[0]; // Unboxing + casting required

// Problems:
// 1. No compile-time type checking
// 2. Boxing/unboxing performance overhead
// 3. Runtime errors possible
</code></pre>
<h4 id="hashtable">Hashtable</h4>
<pre><code class="language-csharp">Hashtable table = new Hashtable();
table[&quot;key1&quot;] = &quot;value1&quot;;
table[42] = &quot;number key&quot;;  // Any type as key

// Type casting required
string value = (string)table[&quot;key1&quot;];
</code></pre>
<h3 id="collection-interfaces">Collection Interfaces</h3>
<pre><code class="language-csharp">// IEnumerable&lt;T&gt; - [COVERED]Basic iteration
public void ProcessItems(IEnumerable&lt;string&gt; items)
{
    foreach (string item in items)
    {
        Console.WriteLine(item);
    }
}

// ICollection&lt;T&gt; - [COVERED]Add/Remove operations
public void ModifyCollection(ICollection&lt;string&gt; items)
{
    items.Add(&quot;New Item&quot;);
    items.Remove(&quot;Old Item&quot;);
    Console.WriteLine($&quot;Count: {items.Count}&quot;);
}

// IList&lt;T&gt; - [COVERED]Indexed access
public void AccessByIndex(IList&lt;string&gt; items)
{
    items[0] = &quot;First Item&quot;;
    items.Insert(1, &quot;Second Item&quot;);
}
</code></pre>
<h2 id="regular-expressions">Regular Expressions</h2>
<h3 id="definition-4">Definition</h3>
<p>Regular expressions (regex) are patterns used to match character combinations in strings. They provide a powerful way to search, replace, and validate text.</p>
<h3 id="basic-syntax">Basic Syntax</h3>
<h4 id="metacharacters">Metacharacters</h4>
<ul>
<li>[COVERED]<code>.</code> - [COVERED]Any character except newline</li>
<li>[COVERED]<code>*</code> - [COVERED]Zero or more occurrences</li>
<li>[COVERED]<code>+</code> - [COVERED]One or more occurrences</li>
<li>[COVERED]<code>?</code> - [COVERED]Zero or one occurrence</li>
<li>[COVERED]<code>^</code> - [COVERED]Start of string</li>
<li>[COVERED]<code>$</code> - [COVERED]End of string</li>
<li>[COVERED]<code>|</code> - [COVERED]OR operator</li>
<li>[COVERED]<code>[]</code> - [COVERED]Character class</li>
<li>[COVERED]<code>()</code> - [COVERED]Grouping</li>
</ul>
<h3 id="c-regex-implementation">C# Regex Implementation</h3>
<pre><code class="language-csharp">using System.Text.RegularExpressions;

// Basic pattern matching
string text = &quot;The quick brown fox jumps over the lazy dog&quot;;
string pattern = @&quot;quick|lazy&quot;;
Regex regex = new Regex(pattern);

// Check if pattern exists
bool hasMatch = regex.IsMatch(text); // true

// Find all matches
MatchCollection matches = regex.Matches(text);
foreach (Match match in matches)
{
    Console.WriteLine($&quot;Found: '{match.Value}' at position {match.Index}&quot;);
}

// Replace text
string replaced = regex.Replace(text, &quot;REPLACED&quot;);
Console.WriteLine(replaced);
</code></pre>
<h3 id="common-patterns">Common Patterns</h3>
<h4 id="email-validation">Email Validation</h4>
<pre><code class="language-csharp">string emailPattern = @&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$&quot;;
Regex emailRegex = new Regex(emailPattern);

string[] emails = { &quot;user@example.com&quot;, &quot;invalid.email&quot;, &quot;test@domain.co.uk&quot; };
foreach (string email in emails)
{
    bool isValid = emailRegex.IsMatch(email);
    Console.WriteLine($&quot;{email}: {(isValid ? &quot;Valid&quot; : &quot;Invalid&quot;)}&quot;);
}
</code></pre>
<h4 id="phone-number-extraction">Phone Number Extraction</h4>
<pre><code class="language-csharp">string phonePattern = @&quot;\b\d{3}-\d{3}-\d{4}\b&quot;;
string text = &quot;Call me at 555-123-4567 or 555-987-6543&quot;;

MatchCollection phoneMatches = Regex.Matches(text, phonePattern);
foreach (Match match in phoneMatches)
{
    Console.WriteLine($&quot;Phone: {match.Value}&quot;);
}
</code></pre>
<h4 id="groups-and-capturing">Groups and Capturing</h4>
<pre><code class="language-csharp">string namePattern = @&quot;(\w+)\s+(\w+)&quot;; // First name, Last name
string input = &quot;John Doe, Jane Smith, Bob Johnson&quot;;

MatchCollection nameMatches = Regex.Matches(input, namePattern);
foreach (Match match in nameMatches)
{
    string firstName = match.Groups[1].Value;
    string lastName = match.Groups[2].Value;
    Console.WriteLine($&quot;Name: {firstName} {lastName}&quot;);
}
</code></pre>
<h3 id="advanced-features">Advanced Features</h3>
<h4 id="regex-options">Regex Options</h4>
<pre><code class="language-csharp">// Case-insensitive matching
Regex regex1 = new Regex(@&quot;hello&quot;, RegexOptions.IgnoreCase);

// Multiline mode
Regex regex2 = new Regex(@&quot;^Start&quot;, RegexOptions.Multiline);

// Compiled regex for performance
Regex regex3 = new Regex(@&quot;\d+&quot;, RegexOptions.Compiled);
</code></pre>
<h4 id="named-groups">Named Groups</h4>
<pre><code class="language-csharp">string pattern = @&quot;(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})&quot;;
string dateText = &quot;Today is 2023-12-25&quot;;

Match match = Regex.Match(dateText, pattern);
if (match.Success)
{
    string year = match.Groups[&quot;year&quot;].Value;
    string month = match.Groups[&quot;month&quot;].Value;
    string day = match.Groups[&quot;day&quot;].Value;
    Console.WriteLine($&quot;Date: {year}/{month}/{day}&quot;);
}
</code></pre>
<h2 id="polymorphism">Polymorphism</h2>
<h3 id="definition-5">Definition</h3>
<p>Polymorphism allows objects of different types to be treated as objects of a common base type, while maintaining their specific behavior.</p>
<h3 id="types-of-polymorphism">Types of Polymorphism</h3>
<h4 id="method-overloading-compile-time-polymorphism">1. Method Overloading (Compile-time Polymorphism)</h4>
<pre><code class="language-csharp">public class Calculator
{
    // Same method name, different parameters
    public int Add(int a, int b)
    {
        return a + b;
    }

    public double Add(double a, double b)
    {
        return a + b;
    }

    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }

    public string Add(string a, string b)
    {
        return a + b;
    }
}

// Usage
Calculator calc = new Calculator();
int result1 = calc.Add(5, 3);           // Calls int version
double result2 = calc.Add(5.5, 3.2);    // Calls double version
int result3 = calc.Add(1, 2, 3);        // Calls three-parameter version
string result4 = calc.Add(&quot;Hello&quot;, &quot; World&quot;); // Calls string version
</code></pre>
<h4 id="method-overriding-runtime-polymorphism">2. Method Overriding (Runtime Polymorphism)</h4>
<pre><code class="language-csharp">// Base class
public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine(&quot;The animal makes a sound&quot;);
    }

    public virtual void Move()
    {
        Console.WriteLine(&quot;The animal moves&quot;);
    }
}

// Derived classes
public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine(&quot;The dog barks: Woof!&quot;);
    }

    public override void Move()
    {
        Console.WriteLine(&quot;The dog runs&quot;);
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine(&quot;The cat meows: Meow!&quot;);
    }

    public override void Move()
    {
        Console.WriteLine(&quot;The cat prowls&quot;);
    }
}

// Polymorphic usage
Animal[] animals = { new Dog(), new Cat(), new Animal() };
foreach (Animal animal in animals)
{
    animal.MakeSound(); // Calls appropriate overridden method
    animal.Move();      // Runtime determines which method to call
}
</code></pre>
<h3 id="abstract-methods-and-classes">Abstract Methods and Classes</h3>
<pre><code class="language-csharp">public abstract class Shape
{
    // Abstract method - [COVERED]must be implemented by derived classes
    public abstract double CalculateArea();

    // Virtual method - [COVERED]can be overridden
    public virtual void Display()
    {
        Console.WriteLine($&quot;Area: {CalculateArea():F2}&quot;);
    }

    // Regular method - [COVERED]inherited as-is
    public void PrintInfo()
    {
        Console.WriteLine(&quot;This is a shape&quot;);
    }
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }

    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
    }

    public override double CalculateArea()
    {
        return Width * Height;
    }

    public override void Display()
    {
        Console.WriteLine($&quot;Rectangle - Width: {Width}, Height: {Height}, Area: {CalculateArea():F2}&quot;);
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }

    public Circle(double radius)
    {
        Radius = radius;
    }

    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
}
</code></pre>
<h3 id="interface-polymorphism">Interface Polymorphism</h3>
<pre><code class="language-csharp">public interface IDrawable
{
    void Draw();
    void Resize(double factor);
}

public interface IColorable
{
    string Color { get; set; }
    void ChangeColor(string newColor);
}

public class Button : IDrawable, IColorable
{
    public string Color { get; set; } = &quot;Gray&quot;;
    public string Text { get; set; }

    public void Draw()
    {
        Console.WriteLine($&quot;Drawing {Color} button with text: {Text}&quot;);
    }

    public void Resize(double factor)
    {
        Console.WriteLine($&quot;Resizing button by factor: {factor}&quot;);
    }

    public void ChangeColor(string newColor)
    {
        Color = newColor;
        Console.WriteLine($&quot;Button color changed to: {newColor}&quot;);
    }
}

// Polymorphic usage with interfaces
IDrawable[] drawables = { new Button { Text = &quot;OK&quot; }, new Button { Text = &quot;Cancel&quot; } };
foreach (IDrawable drawable in drawables)
{
    drawable.Draw();
    drawable.Resize(1.5);
}
</code></pre>
<h2 id="abstract-classes-vs-interfaces">Abstract Classes vs Interfaces</h2>
<h3 id="abstract-classes">Abstract Classes</h3>
<h4 id="definition-6">Definition</h4>
<p>An abstract class is a class that cannot be instantiated and may contain both abstract and concrete members.</p>
<h4 id="key-characteristics-2">Key Characteristics</h4>
<ul>
<li>[COVERED]Cannot be instantiated directly</li>
<li>[COVERED]Can contain both abstract and concrete methods</li>
<li>[COVERED]Can have constructors</li>
<li>[COVERED]Can have fields and properties</li>
<li>[COVERED]Supports single inheritance only</li>
<li>[COVERED]Can have access modifiers for members</li>
</ul>
<pre><code class="language-csharp">public abstract class Vehicle
{
    // Fields
    protected string brand;
    protected int year;

    // Constructor
    public Vehicle(string brand, int year)
    {
        this.brand = brand;
        this.year = year;
    }

    // Abstract method - [COVERED]must be implemented
    public abstract void Start();
    public abstract double CalculateFuelEfficiency();

    // Concrete method - [COVERED]inherited as-is
    public void DisplayInfo()
    {
        Console.WriteLine($&quot;{brand} {year}&quot;);
    }

    // Virtual method - [COVERED]can be overridden
    public virtual void Stop()
    {
        Console.WriteLine(&quot;Vehicle stopped&quot;);
    }

    // Properties
    public string Brand =&gt; brand;
    public int Year =&gt; year;
}

public class Car : Vehicle
{
    private double engineSize;

    public Car(string brand, int year, double engineSize)
        : base(brand, year)
    {
        this.engineSize = engineSize;
    }

    public override void Start()
    {
        Console.WriteLine($&quot;Car {brand} started with {engineSize}L engine&quot;);
    }

    public override double CalculateFuelEfficiency()
    {
        return 25.0 - (engineSize * 2); // Simplified calculation
    }

    public override void Stop()
    {
        Console.WriteLine(&quot;Car stopped with brake pedal&quot;);
    }
}
</code></pre>
<h3 id="interfaces">Interfaces</h3>
<h4 id="definition-7">Definition</h4>
<p>An interface defines a contract that implementing classes must follow. It contains only declarations.</p>
<h4 id="key-characteristics-3">Key Characteristics</h4>
<ul>
<li>[COVERED]Cannot be instantiated</li>
<li>[COVERED]Contains only method signatures, properties, events, indexers</li>
<li>[COVERED]No implementation (except default interface methods in C# 8+)</li>
<li>[COVERED]No fields or constructors</li>
<li>[COVERED]Supports multiple inheritance</li>
<li>[COVERED]All members are implicitly public</li>
</ul>
<pre><code class="language-csharp">public interface IVehicle
{
    // Properties
    string Brand { get; }
    int Year { get; }

    // Methods
    void Start();
    void Stop();
    double CalculateFuelEfficiency();
}

public interface IElectric
{
    int BatteryCapacity { get; }
    void Charge();
    double GetRemainingCharge();
}

public interface IGasoline
{
    double FuelTankCapacity { get; }
    void Refuel();
    double GetRemainingFuel();
}

// Class implementing multiple interfaces
public class HybridCar : IVehicle, IElectric, IGasoline
{
    public string Brand { get; private set; }
    public int Year { get; private set; }
    public int BatteryCapacity { get; private set; }
    public double FuelTankCapacity { get; private set; }

    private double currentCharge;
    private double currentFuel;

    public HybridCar(string brand, int year, int batteryCapacity, double fuelCapacity)
    {
        Brand = brand;
        Year = year;
        BatteryCapacity = batteryCapacity;
        FuelTankCapacity = fuelCapacity;
        currentCharge = batteryCapacity;
        currentFuel = fuelCapacity;
    }

    public void Start()
    {
        Console.WriteLine($&quot;Hybrid {Brand} started (using battery first)&quot;);
    }

    public void Stop()
    {
        Console.WriteLine(&quot;Hybrid car stopped&quot;);
    }

    public double CalculateFuelEfficiency()
    {
        return 50.0; // High efficiency due to hybrid nature
    }

    public void Charge()
    {
        currentCharge = BatteryCapacity;
        Console.WriteLine(&quot;Battery fully charged&quot;);
    }

    public double GetRemainingCharge()
    {
        return currentCharge;
    }

    public void Refuel()
    {
        currentFuel = FuelTankCapacity;
        Console.WriteLine(&quot;Fuel tank refilled&quot;);
    }

    public double GetRemainingFuel()
    {
        return currentFuel;
    }
}
</code></pre>
<h3 id="comparison-table-1">Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Abstract Class</th>
<th>Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Instantiation</strong></td>
<td>Cannot be instantiated</td>
<td>Cannot be instantiated</td>
</tr>
<tr>
<td><strong>Implementation</strong></td>
<td>Can have both abstract and concrete methods</td>
<td>Only method signatures (except default methods)</td>
</tr>
<tr>
<td><strong>Fields</strong></td>
<td>Can have fields</td>
<td>Cannot have fields</td>
</tr>
<tr>
<td><strong>Constructors</strong></td>
<td>Can have constructors</td>
<td>Cannot have constructors</td>
</tr>
<tr>
<td><strong>Access Modifiers</strong></td>
<td>Can use various access modifiers</td>
<td>Members are implicitly public</td>
</tr>
<tr>
<td><strong>Inheritance</strong></td>
<td>Single inheritance</td>
<td>Multiple inheritance</td>
</tr>
<tr>
<td><strong>When to Use</strong></td>
<td>When classes share common implementation</td>
<td>When classes share common behavior contract</td>
</tr>
</tbody>
</table>
<h3 id="when-to-use-which">When to Use Which?</h3>
<h4 id="use-abstract-class-when">Use Abstract Class When:</h4>
<ul>
<li>[COVERED]You want to share code among several closely related classes</li>
<li>[COVERED]You expect classes that extend your abstract class to have many common methods or fields</li>
<li>[COVERED]You want to declare non-public members</li>
<li>[COVERED]You need to provide a common constructor</li>
</ul>
<h4 id="use-interface-when">Use Interface When:</h4>
<ul>
<li>[COVERED]You expect unrelated classes to implement your interface</li>
<li>[COVERED]You want to specify the behavior of a particular data type, but not concerned about who implements it</li>
<li>[COVERED]You want to support multiple inheritance of type</li>
<li>[COVERED]You want to provide a contract for classes to follow</li>
</ul>
<pre><code class="language-csharp">// Example: When to use both
public abstract class DatabaseConnection
{
    protected string connectionString;

    protected DatabaseConnection(string connectionString)
    {
        this.connectionString = connectionString;
    }

    public abstract void Connect();
    public abstract void Disconnect();

    // Common implementation
    public void LogOperation(string operation)
    {
        Console.WriteLine($&quot;[{DateTime.Now}] {operation}&quot;);
    }
}

public interface IQueryable
{
    IEnumerable&lt;T&gt; Query&lt;T&gt;(string sql);
    void Execute(string sql);
}

public class SqlServerConnection : DatabaseConnection, IQueryable
{
    public SqlServerConnection(string connectionString)
        : base(connectionString) { }

    public override void Connect()
    {
        LogOperation(&quot;Connecting to SQL Server&quot;);
    }

    public override void Disconnect()
    {
        LogOperation(&quot;Disconnecting from SQL Server&quot;);
    }

    public IEnumerable&lt;T&gt; Query&lt;T&gt;(string sql)
    {
        LogOperation($&quot;Executing query: {sql}&quot;);
        // Implementation here
        return new List&lt;T&gt;();
    }

    public void Execute(string sql)
    {
        LogOperation($&quot;Executing command: {sql}&quot;);
        // Implementation here
    }
}
</code></pre>
<h2 id="inheritance-and-encapsulation">Inheritance and Encapsulation</h2>
<h3 id="inheritance">Inheritance</h3>
<h4 id="definition-8">Definition</h4>
<p>Inheritance allows a class to inherit properties and methods from another class, promoting code reuse and establishing an &quot;is-a&quot; relationship.</p>
<h4 id="types-of-inheritance-in-c">Types of Inheritance in C#</h4>
<pre><code class="language-csharp">// Base class (Parent)
public class Person
{
    protected string name;
    protected int age;

    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }

    public virtual void Introduce()
    {
        Console.WriteLine($&quot;Hi, I'm {name} and I'm {age} years old.&quot;);
    }

    public void Sleep()
    {
        Console.WriteLine($&quot;{name} is sleeping.&quot;);
    }
}

// Derived class (Child)
public class Student : Person
{
    private string studentId;
    private List&lt;string&gt; courses;

    public Student(string name, int age, string studentId)
        : base(name, age) // Call parent constructor
    {
        this.studentId = studentId;
        this.courses = new List&lt;string&gt;();
    }

    // Override parent method
    public override void Introduce()
    {
        Console.WriteLine($&quot;Hi, I'm {name}, a student with ID {studentId}.&quot;);
    }

    // New method specific to Student
    public void EnrollInCourse(string course)
    {
        courses.Add(course);
        Console.WriteLine($&quot;{name} enrolled in {course}&quot;);
    }

    public void Study()
    {
        Console.WriteLine($&quot;{name} is studying.&quot;);
    }
}

// Further inheritance
public class GraduateStudent : Student
{
    private string researchTopic;

    public GraduateStudent(string name, int age, string studentId, string researchTopic)
        : base(name, age, studentId)
    {
        this.researchTopic = researchTopic;
    }

    public override void Introduce()
    {
        Console.WriteLine($&quot;Hi, I'm {name}, a graduate student researching {researchTopic}.&quot;);
    }

    public void Conduct_Research()
    {
        Console.WriteLine($&quot;{name} is conducting research on {researchTopic}.&quot;);
    }
}
</code></pre>
<h4 id="method-hiding-vs-overriding">Method Hiding vs Overriding</h4>
<pre><code class="language-csharp">public class BaseClass
{
    public virtual void VirtualMethod()
    {
        Console.WriteLine(&quot;Base virtual method&quot;);
    }

    public void RegularMethod()
    {
        Console.WriteLine(&quot;Base regular method&quot;);
    }
}

public class DerivedClass : BaseClass
{
    // Method overriding (runtime polymorphism)
    public override void VirtualMethod()
    {
        Console.WriteLine(&quot;Derived overridden method&quot;);
    }

    // Method hiding (compile-time)
    public new void RegularMethod()
    {
        Console.WriteLine(&quot;Derived hidden method&quot;);
    }
}

// Usage demonstration
BaseClass baseRef = new DerivedClass();
baseRef.VirtualMethod();  // &quot;Derived overridden method&quot; (polymorphism)
baseRef.RegularMethod();  // &quot;Base regular method&quot; (no polymorphism)

DerivedClass derivedRef = new DerivedClass();
derivedRef.VirtualMethod(); // &quot;Derived overridden method&quot;
derivedRef.RegularMethod(); // &quot;Derived hidden method&quot;
</code></pre>
<h3 id="encapsulation">Encapsulation</h3>
<h4 id="definition-9">Definition</h4>
<p>Encapsulation is the bundling of data and methods that operate on that data within a single unit, while restricting access to some components.</p>
<h4 id="access-modifiers">Access Modifiers</h4>
<pre><code class="language-csharp">public class BankAccount
{
    // Private fields (encapsulated data)
    private string accountNumber;
    private decimal balance;
    private string ownerName;

    // Public constructor
    public BankAccount(string accountNumber, string ownerName, decimal initialBalance = 0)
    {
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        this.balance = initialBalance &gt;= 0 ? initialBalance : 0;
    }

    // Public properties (controlled access)
    public string AccountNumber
    {
        get { return accountNumber; }
        // No setter - [COVERED]read-only
    }

    public string OwnerName
    {
        get { return ownerName; }
        set
        {
            if (!string.IsNullOrWhiteSpace(value))
                ownerName = value;
        }
    }

    public decimal Balance
    {
        get { return balance; }
        // No public setter - [COVERED]controlled through methods
    }

    // Public methods (controlled operations)
    public bool Deposit(decimal amount)
    {
        if (amount &gt; 0)
        {
            balance += amount;
            LogTransaction($&quot;Deposited {amount:C}&quot;);
            return true;
        }
        return false;
    }

    public bool Withdraw(decimal amount)
    {
        if (amount &gt; 0 &amp;&amp; amount &lt;= balance)
        {
            balance -= amount;
            LogTransaction($&quot;Withdrew {amount:C}&quot;);
            return true;
        }
        return false;
    }

    // Private helper method (internal implementation)
    private void LogTransaction(string transaction)
    {
        Console.WriteLine($&quot;[{DateTime.Now}] {AccountNumber}: {transaction}. Balance: {balance:C}&quot;);
    }

    // Protected method (accessible to derived classes)
    protected virtual bool ValidateTransaction(decimal amount)
    {
        return amount &gt; 0 &amp;&amp; amount &lt;= balance;
    }
}

// Inheritance with encapsulation
public class SavingsAccount : BankAccount
{
    private decimal interestRate;
    private DateTime lastInterestDate;

    public SavingsAccount(string accountNumber, string ownerName, decimal interestRate, decimal initialBalance = 0)
        : base(accountNumber, ownerName, initialBalance)
    {
        this.interestRate = interestRate;
        this.lastInterestDate = DateTime.Now;
    }

    public decimal InterestRate
    {
        get { return interestRate; }
        set { interestRate = value &gt; 0 ? value : interestRate; }
    }

    public void ApplyInterest()
    {
        if (DateTime.Now.Month != lastInterestDate.Month)
        {
            decimal interest = Balance * (interestRate / 100 / 12);
            Deposit(interest); // Using inherited method
            lastInterestDate = DateTime.Now;
        }
    }

    // Override inherited behavior
    protected override bool ValidateTransaction(decimal amount)
    {
        // Savings account might have different validation rules
        return base.ValidateTransaction(amount) &amp;&amp; amount &lt;= 1000; // Daily limit
    }
}
</code></pre>
<h4 id="properties-and-auto-properties">Properties and Auto-Properties</h4>
<pre><code class="language-csharp">public class Product
{
    // Full property with backing field
    private decimal price;
    public decimal Price
    {
        get { return price; }
        set
        {
            if (value &gt;= 0)
                price = value;
            else
                throw new ArgumentException(&quot;Price cannot be negative&quot;);
        }
    }

    // Auto-property (compiler generates backing field)
    public string Name { get; set; }

    // Auto-property with private setter
    public DateTime CreatedDate { get; private set; }

    // Auto-property with default value
    public bool IsActive { get; set; } = true;

    // Read-only auto-property
    public int Id { get; }

    // Constructor
    public Product(int id, string name, decimal price)
    {
        Id = id; // Can only be set in constructor
        Name = name;
        Price = price;
        CreatedDate = DateTime.Now;
    }

    // Computed property
    public string DisplayName =&gt; $&quot;{Name} (${Price:F2})&quot;;
}
</code></pre>
<h2 id="exception-handling">Exception Handling</h2>
<h3 id="definition-10">Definition</h3>
<p>Exception handling is a programming construct that allows programs to respond to exceptional circumstances during execution.</p>
<h3 id="try-catch-finally-structure">Try-Catch-Finally Structure</h3>
<pre><code class="language-csharp">public class ExceptionHandlingExamples
{
    public static void BasicExceptionHandling()
    {
        try
        {
            // Code that might throw an exception
            Console.Write(&quot;Enter a number: &quot;);
            string input = Console.ReadLine();
            int number = int.Parse(input);
            int result = 100 / number;
            Console.WriteLine($&quot;Result: {result}&quot;);
        }
        catch (FormatException ex)
        {
            // Handle specific exception type
            Console.WriteLine($&quot;Invalid format: {ex.Message}&quot;);
        }
        catch (DivideByZeroException ex)
        {
            // Handle specific exception type
            Console.WriteLine($&quot;Division by zero: {ex.Message}&quot;);
        }
        catch (Exception ex)
        {
            // Handle any other exception
            Console.WriteLine($&quot;An error occurred: {ex.Message}&quot;);
        }
        finally
        {
            // Always executes (cleanup code)
            Console.WriteLine(&quot;Operation completed.&quot;);
        }
    }
}
</code></pre>
<h3 id="multiple-catch-blocks">Multiple Catch Blocks</h3>
<pre><code class="language-csharp">public class FileProcessor
{
    public void ProcessFile(string filePath)
    {
        FileStream fileStream = null;
        StreamReader reader = null;

        try
        {
            fileStream = new FileStream(filePath, FileMode.Open);
            reader = new StreamReader(fileStream);

            string content = reader.ReadToEnd();
            int lineCount = content.Split('\n').Length;

            Console.WriteLine($&quot;File processed. Line count: {lineCount}&quot;);
        }
        catch (FileNotFoundException ex)
        {
            Console.WriteLine($&quot;File not found: {ex.FileName}&quot;);
        }
        catch (UnauthorizedAccessException ex)
        {
            Console.WriteLine($&quot;Access denied: {ex.Message}&quot;);
        }
        catch (IOException ex)
        {
            Console.WriteLine($&quot;I/O error: {ex.Message}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Unexpected error: {ex.Message}&quot;);
            // Log the full exception for debugging
            Console.WriteLine($&quot;Stack trace: {ex.StackTrace}&quot;);
        }
        finally
        {
            // Cleanup resources
            reader?.Dispose();
            fileStream?.Dispose();
            Console.WriteLine(&quot;Resources cleaned up.&quot;);
        }
    }
}
</code></pre>
<h3 id="custom-exceptions">Custom Exceptions</h3>
<pre><code class="language-csharp">// Custom exception class
public class InsufficientFundsException : Exception
{
    public decimal RequiredAmount { get; }
    public decimal AvailableAmount { get; }

    public InsufficientFundsException() : base() { }

    public InsufficientFundsException(string message) : base(message) { }

    public InsufficientFundsException(string message, Exception innerException)
        : base(message, innerException) { }

    public InsufficientFundsException(decimal required, decimal available)
        : base($&quot;Insufficient funds. Required: {required:C}, Available: {available:C}&quot;)
    {
        RequiredAmount = required;
        AvailableAmount = available;
    }
}

// Usage of custom exception
public class BankAccountWithExceptions
{
    private decimal balance;

    public decimal Balance =&gt; balance;

    public void Withdraw(decimal amount)
    {
        if (amount &lt;= 0)
            throw new ArgumentException(&quot;Amount must be positive&quot;, nameof(amount));

        if (amount &gt; balance)
            throw new InsufficientFundsException(amount, balance);

        balance -= amount;
    }

    public void ProcessWithdrawal(decimal amount)
    {
        try
        {
            Withdraw(amount);
            Console.WriteLine($&quot;Withdrawal successful. New balance: {balance:C}&quot;);
        }
        catch (InsufficientFundsException ex)
        {
            Console.WriteLine($&quot;Withdrawal failed: {ex.Message}&quot;);
            Console.WriteLine($&quot;You need {ex.RequiredAmount - ex.AvailableAmount:C} more.&quot;);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($&quot;Invalid amount: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h3 id="exception-propagation-and-rethrowing">Exception Propagation and Rethrowing</h3>
<pre><code class="language-csharp">public class ExceptionPropagation
{
    public void MethodA()
    {
        try
        {
            MethodB();
        }
        catch (InvalidOperationException ex)
        {
            Console.WriteLine($&quot;Caught in MethodA: {ex.Message}&quot;);
            // Log and rethrow
            throw; // Preserves original stack trace
        }
    }

    public void MethodB()
    {
        try
        {
            MethodC();
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Caught in MethodB: {ex.Message}&quot;);
            // Wrap and throw new exception
            throw new InvalidOperationException(&quot;Error in MethodB&quot;, ex);
        }
    }

    public void MethodC()
    {
        throw new ArgumentException(&quot;Something went wrong in MethodC&quot;);
    }
}
</code></pre>
<h3 id="using-statement-for-resource-management">Using Statement for Resource Management</h3>
<pre><code class="language-csharp">public class ResourceManagement
{
    // Using statement automatically calls Dispose()
    public void ReadFileWithUsing(string filePath)
    {
        try
        {
            using (var fileStream = new FileStream(filePath, FileMode.Open))
            using (var reader = new StreamReader(fileStream))
            {
                string content = reader.ReadToEnd();
                Console.WriteLine($&quot;File content length: {content.Length}&quot;);
                // fileStream and reader are automatically disposed
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error reading file: {ex.Message}&quot;);
        }
    }

    // Multiple using statements (C# 8+ syntax)
    public void ReadFileWithMultipleUsing(string filePath)
    {
        try
        {
            using var fileStream = new FileStream(filePath, FileMode.Open);
            using var reader = new StreamReader(fileStream);

            string content = reader.ReadToEnd();
            Console.WriteLine($&quot;File content length: {content.Length}&quot;);
            // Automatic disposal at end of method
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error reading file: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h3 id="best-practices">Best Practices</h3>
<pre><code class="language-csharp">public class ExceptionBestPractices
{
    // DON'T: Catch and ignore exceptions
    public void BadExample1()
    {
        try
        {
            // Some operation
            int result = int.Parse(&quot;abc&quot;);
        }
        catch
        {
            // Silently ignoring exception - [COVERED]BAD!
        }
    }

    // DON'T: Catch Exception when you should catch specific types
    public void BadExample2()
    {
        try
        {
            // Some operation
        }
        catch (Exception ex)
        {
            // Too broad - [COVERED]might catch unexpected exceptions
            Console.WriteLine(&quot;Something went wrong&quot;);
        }
    }

    // DO: Catch specific exceptions and handle appropriately
    public bool TryParseNumber(string input, out int result)
    {
        result = 0;
        try
        {
            result = int.Parse(input);
            return true;
        }
        catch (FormatException)
        {
            return false;
        }
        catch (OverflowException)
        {
            return false;
        }
    }

    // DO: Use Try* methods when available
    public bool SafeParseNumber(string input, out int result)
    {
        return int.TryParse(input, out result); // No exception throwing
    }

    // DO: Provide meaningful error messages
    public void ValidateAge(int age)
    {
        if (age &lt; 0)
            throw new ArgumentOutOfRangeException(nameof(age), age, &quot;Age cannot be negative&quot;);

        if (age &gt; 150)
            throw new ArgumentOutOfRangeException(nameof(age), age, &quot;Age cannot exceed 150 years&quot;);
    }
}
</code></pre>
<h2 id="parallel-programming">Parallel Programming</h2>
<h3 id="definition-11">Definition</h3>
<p>Parallel programming involves executing multiple computations simultaneously to improve performance on multi-core processors.</p>
<h3 id="task-parallel-library-tpl">Task Parallel Library (TPL)</h3>
<h4 id="basic-task-usage">Basic Task Usage</h4>
<pre><code class="language-csharp">using System.Threading.Tasks;

public class TaskExamples
{
    public static async Task BasicTaskExample()
    {
        // Creating and starting a task
        Task task1 = Task.Run(() =&gt;
        {
            Console.WriteLine($&quot;Task 1 running on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            Thread.Sleep(2000);
            Console.WriteLine(&quot;Task 1 completed&quot;);
        });

        // Task with return value
        Task&lt;int&gt; task2 = Task.Run(() =&gt;
        {
            Console.WriteLine($&quot;Task 2 running on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            Thread.Sleep(1000);
            return 42;
        });

        // Wait for tasks to complete
        await task1;
        int result = await task2;
        Console.WriteLine($&quot;Task 2 result: {result}&quot;);

        // Alternative: Wait for all tasks
        await Task.WhenAll(task1, task2);
    }

    public static void TaskWithContinuation()
    {
        Task&lt;string&gt; downloadTask = Task.Run(() =&gt;
        {
            Thread.Sleep(2000);
            return &quot;Downloaded data&quot;;
        });

        // Continuation task
        Task processTask = downloadTask.ContinueWith(antecedent =&gt;
        {
            string data = antecedent.Result;
            Console.WriteLine($&quot;Processing: {data}&quot;);
        });

        processTask.Wait();
    }
}
</code></pre>
<h4 id="parallel-loops">Parallel Loops</h4>
<pre><code class="language-csharp">public class ParallelLoopExamples
{
    public static void ParallelForExample()
    {
        // Sequential version
        Console.WriteLine(&quot;Sequential processing:&quot;);
        var stopwatch = Stopwatch.StartNew();
        for (int i = 0; i &lt; 10; i++)
        {
            ProcessNumber(i);
        }
        stopwatch.Stop();
        Console.WriteLine($&quot;Sequential time: {stopwatch.ElapsedMilliseconds}ms&quot;);

        // Parallel version
        Console.WriteLine(&quot;\nParallel processing:&quot;);
        stopwatch.Restart();
        Parallel.For(0, 10, i =&gt;
        {
            ProcessNumber(i);
        });
        stopwatch.Stop();
        Console.WriteLine($&quot;Parallel time: {stopwatch.ElapsedMilliseconds}ms&quot;);
    }

    public static void ParallelForEachExample()
    {
        var numbers = Enumerable.Range(1, 1000).ToList();
        var results = new ConcurrentBag&lt;int&gt;();

        Parallel.ForEach(numbers, number =&gt;
        {
            int result = ExpensiveCalculation(number);
            results.Add(result);
        });

        Console.WriteLine($&quot;Processed {results.Count} numbers&quot;);
    }

    private static void ProcessNumber(int number)
    {
        Thread.Sleep(100); // Simulate work
        Console.WriteLine($&quot;Processed {number} on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
    }

    private static int ExpensiveCalculation(int number)
    {
        // Simulate expensive calculation
        Thread.Sleep(10);
        return number * number;
    }
}
</code></pre>
<h4 id="plinq-parallel-linq">PLINQ (Parallel LINQ)</h4>
<pre><code class="language-csharp">public class PLinqExamples
{
    public static void BasicPLinqExample()
    {
        var numbers = Enumerable.Range(1, 1000000).ToArray();

        // Sequential LINQ
        var sequentialStopwatch = Stopwatch.StartNew();
        var sequentialResult = numbers
            .Where(n =&gt; n % 2 == 0)
            .Select(n =&gt; n * n)
            .Sum();
        sequentialStopwatch.Stop();

        // Parallel LINQ
        var parallelStopwatch = Stopwatch.StartNew();
        var parallelResult = numbers
            .AsParallel()
            .Where(n =&gt; n % 2 == 0)
            .Select(n =&gt; n * n)
            .Sum();
        parallelStopwatch.Stop();

        Console.WriteLine($&quot;Sequential result: {sequentialResult}, Time: {sequentialStopwatch.ElapsedMilliseconds}ms&quot;);
        Console.WriteLine($&quot;Parallel result: {parallelResult}, Time: {parallelStopwatch.ElapsedMilliseconds}ms&quot;);
    }

    public static void PLinqWithOptions()
    {
        var data = Enumerable.Range(1, 1000).ToArray();

        var result = data
            .AsParallel()
            .WithDegreeOfParallelism(4) // Limit to 4 threads
            .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
            .Where(n =&gt; ExpensiveFilter(n))
            .Select(n =&gt; ExpensiveTransform(n))
            .OrderBy(n =&gt; n) // This forces sequential execution
            .ToArray();

        Console.WriteLine($&quot;Processed {result.Length} items&quot;);
    }

    private static bool ExpensiveFilter(int number)
    {
        Thread.Sleep(1); // Simulate work
        return number % 3 == 0;
    }

    private static int ExpensiveTransform(int number)
    {
        Thread.Sleep(1); // Simulate work
        return number * 2;
    }
}
</code></pre>
<h3 id="thread-safe-collections">Thread-Safe Collections</h3>
<pre><code class="language-csharp">public class ThreadSafeCollectionsExample
{
    public static void ConcurrentCollectionsExample()
    {
        // ConcurrentBag - [COVERED]Thread-safe collection of objects
        var bag = new ConcurrentBag&lt;int&gt;();

        Parallel.For(0, 100, i =&gt;
        {
            bag.Add(i);
        });

        Console.WriteLine($&quot;Bag contains {bag.Count} items&quot;);

        // ConcurrentDictionary - [COVERED]Thread-safe dictionary
        var dictionary = new ConcurrentDictionary&lt;string, int&gt;();

        Parallel.For(0, 100, i =&gt;
        {
            dictionary.TryAdd($&quot;key{i}&quot;, i);
        });

        // Safe operations
        dictionary.AddOrUpdate(&quot;key1&quot;, 1, (key, oldValue) =&gt; oldValue + 1);
        int value = dictionary.GetOrAdd(&quot;newKey&quot;, 999);

        Console.WriteLine($&quot;Dictionary contains {dictionary.Count} items&quot;);

        // ConcurrentQueue - [COVERED]Thread-safe FIFO collection
        var queue = new ConcurrentQueue&lt;string&gt;();

        Task producer = Task.Run(() =&gt;
        {
            for (int i = 0; i &lt; 10; i++)
            {
                queue.Enqueue($&quot;Item {i}&quot;);
                Thread.Sleep(100);
            }
        });

        Task consumer = Task.Run(() =&gt;
        {
            while (!producer.IsCompleted || !queue.IsEmpty)
            {
                if (queue.TryDequeue(out string item))
                {
                    Console.WriteLine($&quot;Consumed: {item}&quot;);
                }
                Thread.Sleep(50);
            }
        });

        Task.WaitAll(producer, consumer);
    }
}
</code></pre>
<h3 id="asyncawait-pattern">Async/Await Pattern</h3>
<pre><code class="language-csharp">public class AsyncAwaitExamples
{
    public static async Task AsyncMethodExample()
    {
        Console.WriteLine(&quot;Starting async operations...&quot;);

        // Start multiple async operations
        Task&lt;string&gt; download1 = DownloadDataAsync(&quot;https://api1.example.com&quot;);
        Task&lt;string&gt; download2 = DownloadDataAsync(&quot;https://api2.example.com&quot;);
        Task&lt;string&gt; download3 = DownloadDataAsync(&quot;https://api3.example.com&quot;);

        // Wait for all to complete
        string[] results = await Task.WhenAll(download1, download2, download3);

        foreach (string result in results)
        {
            Console.WriteLine($&quot;Downloaded: {result}&quot;);
        }
    }

    private static async Task&lt;string&gt; DownloadDataAsync(string url)
    {
        using (var client = new HttpClient())
        {
            // Simulate network delay
            await Task.Delay(Random.Shared.Next(1000, 3000));
            return $&quot;Data from {url}&quot;;
        }
    }

    public static async Task CancellationExample()
    {
        using var cts = new CancellationTokenSource();

        // Cancel after 5 seconds
        cts.CancelAfter(TimeSpan.FromSeconds(5));

        try
        {
            await LongRunningOperationAsync(cts.Token);
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine(&quot;Operation was cancelled&quot;);
        }
    }

    private static async Task LongRunningOperationAsync(CancellationToken cancellationToken)
    {
        for (int i = 0; i &lt; 100; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            // Simulate work
            await Task.Delay(100, cancellationToken);
            Console.WriteLine($&quot;Step {i + 1}/100&quot;);
        }
    }
}
</code></pre>
<h3 id="synchronization-primitives">Synchronization Primitives</h3>
<pre><code class="language-csharp">public class SynchronizationExamples
{
    private static readonly object lockObject = new object();
    private static int sharedCounter = 0;

    public static void LockExample()
    {
        Task[] tasks = new Task[10];

        for (int i = 0; i &lt; 10; i++)
        {
            tasks[i] = Task.Run(() =&gt;
            {
                for (int j = 0; j &lt; 1000; j++)
                {
                    lock (lockObject)
                    {
                        sharedCounter++;
                    }
                }
            });
        }

        Task.WaitAll(tasks);
        Console.WriteLine($&quot;Final counter value: {sharedCounter}&quot;); // Should be 10000
    }

    private static readonly SemaphoreSlim semaphore = new SemaphoreSlim(3); // Allow 3 concurrent operations

    public static async Task SemaphoreExample()
    {
        Task[] tasks = new Task[10];

        for (int i = 0; i &lt; 10; i++)
        {
            int taskId = i;
            tasks[i] = AccessResourceAsync(taskId);
        }

        await Task.WhenAll(tasks);
    }

    private static async Task AccessResourceAsync(int id)
    {
        await semaphore.WaitAsync();
        try
        {
            Console.WriteLine($&quot;Task {id} accessing resource at {DateTime.Now:HH:mm:ss.fff}&quot;);
            await Task.Delay(2000); // Simulate work
            Console.WriteLine($&quot;Task {id} finished at {DateTime.Now:HH:mm:ss.fff}&quot;);
        }
        finally
        {
            semaphore.Release();
        }
    }
}
</code></pre>
<h2 id="ado.net">ADO.NET</h2>
<h3 id="definition-12">Definition</h3>
<p>ADO.NET is a set of classes that expose data access services for .NET Framework programmers, providing access to relational databases, XML, and application data.</p>
<h3 id="ado.net-architecture">ADO.NET Architecture</h3>
<h4 id="core-components">Core Components</h4>
<ol>
<li><strong>Data Provider</strong> - [COVERED]Connects to database</li>
<li><strong>DataSet</strong> - [COVERED]In-memory representation of data</li>
<li><strong>DataAdapter</strong> - [COVERED]Bridge between DataSet and data source</li>
<li><strong>DataReader</strong> - [COVERED]Forward-only, read-only data stream</li>
</ol>
<pre><code>+----------------+    +------------------+    +----------------+
|   Application  |&lt;--&gt;|    DataSet       |&lt;--&gt;|  DataAdapter   |
|                |    |  (Disconnected)  |    |                |
+----------------+    +------------------+    +----------------+
                                                       |
+----------------+    +------------------+            |
|   Application  |&lt;--&gt;|   DataReader     |&lt;-----------+
|                |    |   (Connected)    |            |
+----------------+    +------------------+            |
                                                      |
                                             +----------------+
                                             |   Data Source  |
                                             |   (Database)   |
                                             +----------------+
</code></pre>
<p><strong>Connection Types:</strong></p>
<ul>
<li>[COVERED]<strong>DataSet</strong>: Disconnected - [COVERED]loads data into memory, works offline</li>
<li>[COVERED]<strong>DataReader</strong>: Connected - [COVERED]requires active connection, reads forward-only</li>
</ul>
<h3 id="datareader-vs-dataset">DataReader vs DataSet</h3>
<h4 id="datareader-connected-architecture">DataReader (Connected Architecture)</h4>
<pre><code class="language-csharp">public class DataReaderExample
{
    private string connectionString = &quot;Server=localhost;Database=TestDB;Integrated Security=true;&quot;;

    public void ReadDataWithDataReader()
    {
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            string sql = &quot;SELECT EmployeeId, FirstName, LastName, Salary FROM Employees&quot;;
            using (SqlCommand command = new SqlCommand(sql, connection))
            using (SqlDataReader reader = command.ExecuteReader())
            {
                Console.WriteLine(&quot;Employee Data:&quot;);
                Console.WriteLine(&quot;ID\tFirst Name\tLast Name\tSalary&quot;);
                Console.WriteLine(&quot;&quot;.PadRight(50, '-'));

                while (reader.Read())
                {
                    int id = reader.GetInt32(&quot;EmployeeId&quot;);
                    string firstName = reader.GetString(&quot;FirstName&quot;);
                    string lastName = reader.GetString(&quot;LastName&quot;);
                    decimal salary = reader.GetDecimal(&quot;Salary&quot;);

                    Console.WriteLine($&quot;{id}\t{firstName}\t\t{lastName}\t\t{salary:C}&quot;);
                }
            }
            // Connection automatically closed due to using statement
        }
    }

    public async Task ReadDataAsync()
    {
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            await connection.OpenAsync();

            string sql = &quot;SELECT * FROM Products WHERE CategoryId = @categoryId&quot;;
            using (SqlCommand command = new SqlCommand(sql, connection))
            {
                command.Parameters.AddWithValue(&quot;@categoryId&quot;, 1);

                using (SqlDataReader reader = await command.ExecuteReaderAsync())
                {
                    while (await reader.ReadAsync())
                    {
                        string productName = reader[&quot;ProductName&quot;].ToString();
                        decimal price = Convert.ToDecimal(reader[&quot;Price&quot;]);
                        Console.WriteLine($&quot;{productName}: {price:C}&quot;);
                    }
                }
            }
        }
    }
}
</code></pre>
<h4 id="dataset-disconnected-architecture">DataSet (Disconnected Architecture)</h4>
<pre><code class="language-csharp">public class DataSetExample
{
    private string connectionString = &quot;Server=localhost;Database=TestDB;Integrated Security=true;&quot;;

    public void WorkWithDataSet()
    {
        // Create DataSet and DataAdapter
        DataSet dataSet = new DataSet(&quot;EmployeeDataSet&quot;);

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            // Create DataAdapter
            string sql = &quot;SELECT EmployeeId, FirstName, LastName, DepartmentId FROM Employees&quot;;
            SqlDataAdapter adapter = new SqlDataAdapter(sql, connection);

            // Fill DataSet (connection opened and closed automatically)
            adapter.Fill(dataSet, &quot;Employees&quot;);

            // Work with data offline
            DataTable employeeTable = dataSet.Tables[&quot;Employees&quot;];

            // Display data
            foreach (DataRow row in employeeTable.Rows)
            {
                Console.WriteLine($&quot;{row[&quot;EmployeeId&quot;]}: {row[&quot;FirstName&quot;]} {row[&quot;LastName&quot;]}&quot;);
            }

            // Modify data
            DataRow newRow = employeeTable.NewRow();
            newRow[&quot;FirstName&quot;] = &quot;John&quot;;
            newRow[&quot;LastName&quot;] = &quot;Doe&quot;;
            newRow[&quot;DepartmentId&quot;] = 1;
            employeeTable.Rows.Add(newRow);

            // Update database
            SqlCommandBuilder commandBuilder = new SqlCommandBuilder(adapter);
            adapter.Update(dataSet, &quot;Employees&quot;);
        }
    }

    public void DataSetWithRelations()
    {
        DataSet dataSet = new DataSet();

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            // Fill Departments table
            SqlDataAdapter deptAdapter = new SqlDataAdapter(&quot;SELECT * FROM Departments&quot;, connection);
            deptAdapter.Fill(dataSet, &quot;Departments&quot;);

            // Fill Employees table
            SqlDataAdapter empAdapter = new SqlDataAdapter(&quot;SELECT * FROM Employees&quot;, connection);
            empAdapter.Fill(dataSet, &quot;Employees&quot;);

            // Create relationship
            DataRelation relation = new DataRelation(&quot;DeptEmployees&quot;,
                dataSet.Tables[&quot;Departments&quot;].Columns[&quot;DepartmentId&quot;],
                dataSet.Tables[&quot;Employees&quot;].Columns[&quot;DepartmentId&quot;]);
            dataSet.Relations.Add(relation);

            // Navigate relationship
            foreach (DataRow deptRow in dataSet.Tables[&quot;Departments&quot;].Rows)
            {
                Console.WriteLine($&quot;Department: {deptRow[&quot;DepartmentName&quot;]}&quot;);

                DataRow[] employees = deptRow.GetChildRows(relation);
                foreach (DataRow empRow in employees)
                {
                    Console.WriteLine($&quot;  Employee: {empRow[&quot;FirstName&quot;]} {empRow[&quot;LastName&quot;]}&quot;);
                }
            }
        }
    }
}
</code></pre>
<h3 id="steps-to-connect-to-sql-database">Steps to Connect to SQL Database</h3>
<pre><code class="language-csharp">public class DatabaseConnection
{
    // Step 1: Define connection string
    private readonly string connectionString =
        &quot;Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;&quot;;

    // Alternative with integrated security
    private readonly string integratedConnectionString =
        &quot;Server=myServerAddress;Database=myDataBase;Integrated Security=true;&quot;;

    public void ConnectToDatabase()
    {
        // Step 2: Create SqlConnection object
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Step 3: Open the connection
                connection.Open();
                Console.WriteLine(&quot;Connection opened successfully!&quot;);
                Console.WriteLine($&quot;Database: {connection.Database}&quot;);
                Console.WriteLine($&quot;Server Version: {connection.ServerVersion}&quot;);

                // Step 4: Create and execute command
                string sql = &quot;SELECT COUNT(*) FROM Employees&quot;;
                using (SqlCommand command = new SqlCommand(sql, connection))
                {
                    // Step 5: Execute command and get result
                    int employeeCount = (int)command.ExecuteScalar();
                    Console.WriteLine($&quot;Total employees: {employeeCount}&quot;);
                }

                // Step 6: Connection automatically closed by using statement
            }
            catch (SqlException ex)
            {
                Console.WriteLine($&quot;SQL Error: {ex.Message}&quot;);
            }
            catch (Exception ex)
            {
                Console.WriteLine($&quot;General Error: {ex.Message}&quot;);
            }
        }
    }

    // CRUD Operations Example
    public class EmployeeCRUD
    {
        private readonly string connectionString;

        public EmployeeCRUD(string connectionString)
        {
            this.connectionString = connectionString;
        }

        // CREATE
        public int CreateEmployee(string firstName, string lastName, decimal salary, int departmentId)
        {
            string sql = @&quot;INSERT INTO Employees (FirstName, LastName, Salary, DepartmentId)
                          VALUES (@firstName, @lastName, @salary, @departmentId);
                          SELECT SCOPE_IDENTITY();&quot;;

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(sql, connection))
                {
                    command.Parameters.AddWithValue(&quot;@firstName&quot;, firstName);
                    command.Parameters.AddWithValue(&quot;@lastName&quot;, lastName);
                    command.Parameters.AddWithValue(&quot;@salary&quot;, salary);
                    command.Parameters.AddWithValue(&quot;@departmentId&quot;, departmentId);

                    return Convert.ToInt32(command.ExecuteScalar());
                }
            }
        }

        // READ
        public Employee GetEmployee(int employeeId)
        {
            string sql = &quot;SELECT * FROM Employees WHERE EmployeeId = @employeeId&quot;;

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(sql, connection))
                {
                    command.Parameters.AddWithValue(&quot;@employeeId&quot;, employeeId);

                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            return new Employee
                            {
                                EmployeeId = reader.GetInt32(&quot;EmployeeId&quot;),
                                FirstName = reader.GetString(&quot;FirstName&quot;),
                                LastName = reader.GetString(&quot;LastName&quot;),
                                Salary = reader.GetDecimal(&quot;Salary&quot;),
                                DepartmentId = reader.GetInt32(&quot;DepartmentId&quot;)
                            };
                        }
                    }
                }
            }
            return null;
        }

        // UPDATE
        public bool UpdateEmployee(Employee employee)
        {
            string sql = @&quot;UPDATE Employees
                          SET FirstName = @firstName, LastName = @lastName,
                              Salary = @salary, DepartmentId = @departmentId
                          WHERE EmployeeId = @employeeId&quot;;

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(sql, connection))
                {
                    command.Parameters.AddWithValue(&quot;@firstName&quot;, employee.FirstName);
                    command.Parameters.AddWithValue(&quot;@lastName&quot;, employee.LastName);
                    command.Parameters.AddWithValue(&quot;@salary&quot;, employee.Salary);
                    command.Parameters.AddWithValue(&quot;@departmentId&quot;, employee.DepartmentId);
                    command.Parameters.AddWithValue(&quot;@employeeId&quot;, employee.EmployeeId);

                    return command.ExecuteNonQuery() &gt; 0;
                }
            }
        }

        // DELETE
        public bool DeleteEmployee(int employeeId)
        {
            string sql = &quot;DELETE FROM Employees WHERE EmployeeId = @employeeId&quot;;

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(sql, connection))
                {
                    command.Parameters.AddWithValue(&quot;@employeeId&quot;, employeeId);
                    return command.ExecuteNonQuery() &gt; 0;
                }
            }
        }
    }

    public class Employee
    {
        public int EmployeeId { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public decimal Salary { get; set; }
        public int DepartmentId { get; set; }
    }
}
</code></pre>
<h3 id="linq-to-sql">LINQ to SQL</h3>
<pre><code class="language-csharp">// Entity classes
[Table(Name = &quot;Employees&quot;)]
public class Employee
{
    [Column(IsPrimaryKey = true, IsDbGenerated = true)]
    public int EmployeeId { get; set; }

    [Column]
    public string FirstName { get; set; }

    [Column]
    public string LastName { get; set; }

    [Column]
    public decimal Salary { get; set; }

    [Column]
    public int DepartmentId { get; set; }
}

// DataContext
public class CompanyDataContext : DataContext
{
    public CompanyDataContext(string connectionString) : base(connectionString) { }

    public Table&lt;Employee&gt; Employees =&gt; GetTable&lt;Employee&gt;();
}

// Usage
public class LinqToSqlExample
{
    private string connectionString = &quot;Server=localhost;Database=Company;Integrated Security=true;&quot;;

    public void QueryWithLinqToSql()
    {
        using (var context = new CompanyDataContext(connectionString))
        {
            // Query syntax
            var highEarners = from emp in context.Employees
                             where emp.Salary &gt; 50000
                             orderby emp.Salary descending
                             select emp;

            Console.WriteLine(&quot;High earners:&quot;);
            foreach (var employee in highEarners)
            {
                Console.WriteLine($&quot;{employee.FirstName} {employee.LastName}: {employee.Salary:C}&quot;);
            }

            // Method syntax
            var topPerformers = context.Employees
                .Where(e =&gt; e.Salary &gt; 75000)
                .OrderByDescending(e =&gt; e.Salary)
                .Take(5)
                .ToList();

            // Insert new employee
            var newEmployee = new Employee
            {
                FirstName = &quot;Jane&quot;,
                LastName = &quot;Smith&quot;,
                Salary = 60000,
                DepartmentId = 1
            };

            context.Employees.InsertOnSubmit(newEmployee);
            context.SubmitChanges();
        }
    }
}
</code></pre>
<h2 id="wpf">WPF</h2>
<h3 id="definition-13">Definition</h3>
<p>Windows Presentation Foundation (WPF) is Microsoft's latest approach to a GUI framework, used with the .NET Framework and .NET Core/5+.</p>
<h3 id="xaml-basics">XAML Basics</h3>
<h4 id="basic-window-structure">Basic Window Structure</h4>
<pre><code class="language-xml">&lt;!-- MainWindow.xaml --&gt;
&lt;Window x:Class=&quot;WpfApp.MainWindow&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        Title=&quot;My WPF Application&quot;
        Height=&quot;450&quot;
        Width=&quot;800&quot;
        WindowStartupLocation=&quot;CenterScreen&quot;&gt;

    &lt;Grid&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height=&quot;Auto&quot;/&gt;
            &lt;RowDefinition Height=&quot;*&quot;/&gt;
            &lt;RowDefinition Height=&quot;Auto&quot;/&gt;
        &lt;/Grid.RowDefinitions&gt;

        &lt;!-- [COVERED]Header --&gt;
        &lt;TextBlock Grid.Row=&quot;0&quot;
                   Text=&quot;Welcome to WPF&quot;
                   FontSize=&quot;24&quot;
                   FontWeight=&quot;Bold&quot;
                   HorizontalAlignment=&quot;Center&quot;
                   Margin=&quot;10&quot;/&gt;

        &lt;!-- [COVERED]Content Area --&gt;
        &lt;StackPanel Grid.Row=&quot;1&quot;
                    Orientation=&quot;Vertical&quot;
                    Margin=&quot;20&quot;&gt;

            &lt;Label Content=&quot;Enter your name:&quot;
                   FontWeight=&quot;Bold&quot;/&gt;

            &lt;TextBox x:Name=&quot;NameTextBox&quot;
                     Width=&quot;200&quot;
                     HorizontalAlignment=&quot;Left&quot;
                     Margin=&quot;0,5,0,10&quot;/&gt;

            &lt;Button x:Name=&quot;GreetButton&quot;
                    Content=&quot;Greet Me&quot;
                    Width=&quot;100&quot;
                    HorizontalAlignment=&quot;Left&quot;
                    Click=&quot;GreetButton_Click&quot;/&gt;

            &lt;TextBlock x:Name=&quot;ResultTextBlock&quot;
                       FontSize=&quot;16&quot;
                       Margin=&quot;0,10,0,0&quot;
                       Foreground=&quot;Blue&quot;/&gt;

        &lt;/StackPanel&gt;

        &lt;!-- [COVERED]Status Bar --&gt;
        &lt;StatusBar Grid.Row=&quot;2&quot;&gt;
            &lt;StatusBarItem Content=&quot;Ready&quot;/&gt;
        &lt;/StatusBar&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>
<h4 id="code-behind">Code-Behind</h4>
<pre><code class="language-csharp">// MainWindow.xaml.cs
using System.Windows;

namespace WpfApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void GreetButton_Click(object sender, RoutedEventArgs e)
        {
            string name = NameTextBox.Text;
            if (string.IsNullOrWhiteSpace(name))
            {
                MessageBox.Show(&quot;Please enter your name!&quot;, &quot;Warning&quot;,
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            ResultTextBlock.Text = $&quot;Hello, {name}! Welcome to WPF.&quot;;
        }
    }
}
</code></pre>
<h3 id="wpf-data-binding">WPF Data Binding</h3>
<h4 id="simple-data-binding">Simple Data Binding</h4>
<pre><code class="language-csharp">// Person model
public class Person : INotifyPropertyChanged
{
    private string firstName;
    private string lastName;
    private int age;

    public string FirstName
    {
        get { return firstName; }
        set
        {
            firstName = value;
            OnPropertyChanged();
            OnPropertyChanged(nameof(FullName)); // Update computed property
        }
    }

    public string LastName
    {
        get { return lastName; }
        set
        {
            lastName = value;
            OnPropertyChanged();
            OnPropertyChanged(nameof(FullName));
        }
    }

    public int Age
    {
        get { return age; }
        set
        {
            age = value;
            OnPropertyChanged();
        }
    }

    public string FullName =&gt; $&quot;{FirstName} {LastName}&quot;;

    public event PropertyChangedEventHandler PropertyChanged;

    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</code></pre>
<pre><code class="language-xml">&lt;!-- [COVERED]Data Binding XAML --&gt;
&lt;Window x:Class=&quot;WpfApp.DataBindingWindow&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;

    &lt;StackPanel Margin=&quot;20&quot;&gt;

        &lt;!-- [COVERED]Two-way binding --&gt;
        &lt;Label Content=&quot;First Name:&quot;/&gt;
        &lt;TextBox Text=&quot;{Binding FirstName, UpdateSourceTrigger=PropertyChanged}&quot;
                 Margin=&quot;0,0,0,10&quot;/&gt;

        &lt;Label Content=&quot;Last Name:&quot;/&gt;
        &lt;TextBox Text=&quot;{Binding LastName, UpdateSourceTrigger=PropertyChanged}&quot;
                 Margin=&quot;0,0,0,10&quot;/&gt;

        &lt;Label Content=&quot;Age:&quot;/&gt;
        &lt;TextBox Text=&quot;{Binding Age, UpdateSourceTrigger=PropertyChanged}&quot;
                 Margin=&quot;0,0,0,10&quot;/&gt;

        &lt;!-- One-way binding (computed property) --&gt;
        &lt;Label Content=&quot;Full Name:&quot;/&gt;
        &lt;TextBlock Text=&quot;{Binding FullName}&quot;
                   FontWeight=&quot;Bold&quot;
                   FontSize=&quot;16&quot;
                   Margin=&quot;0,0,0,10&quot;/&gt;

        &lt;!-- [COVERED]Binding with conversion --&gt;
        &lt;TextBlock Margin=&quot;0,10,0,0&quot;&gt;
            &lt;TextBlock.Text&gt;
                &lt;MultiBinding StringFormat=&quot;Person: {0}, Age: {1}&quot;&gt;
                    &lt;Binding Path=&quot;FullName&quot;/&gt;
                    &lt;Binding Path=&quot;Age&quot;/&gt;
                &lt;/MultiBinding&gt;
            &lt;/TextBlock.Text&gt;
        &lt;/TextBlock&gt;

    &lt;/StackPanel&gt;
&lt;/Window&gt;
</code></pre>
<pre><code class="language-csharp">// Code-behind for data binding
public partial class DataBindingWindow : Window
{
    public DataBindingWindow()
    {
        InitializeComponent();

        // Set DataContext
        DataContext = new Person
        {
            FirstName = &quot;John&quot;,
            LastName = &quot;Doe&quot;,
            Age = 30
        };
    }
}
</code></pre>
<h4 id="collection-binding-with-listbox">Collection Binding with ListBox</h4>
<pre><code class="language-xml">&lt;Window x:Class=&quot;WpfApp.EmployeeListWindow&quot;&gt;
    &lt;Grid&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width=&quot;300&quot;/&gt;
            &lt;ColumnDefinition Width=&quot;*&quot;/&gt;
        &lt;/Grid.ColumnDefinitions&gt;

        &lt;!-- [COVERED]Employee List --&gt;
        &lt;ListBox Grid.Column=&quot;0&quot;
                 ItemsSource=&quot;{Binding Employees}&quot;
                 SelectedItem=&quot;{Binding SelectedEmployee}&quot;
                 DisplayMemberPath=&quot;FullName&quot;
                 Margin=&quot;10&quot;/&gt;

        &lt;!-- [COVERED]Employee Details --&gt;
        &lt;StackPanel Grid.Column=&quot;1&quot;
                    DataContext=&quot;{Binding SelectedEmployee}&quot;
                    Margin=&quot;10&quot;&gt;

            &lt;Label Content=&quot;Employee Details&quot;
                   FontWeight=&quot;Bold&quot;
                   FontSize=&quot;16&quot;/&gt;

            &lt;Label Content=&quot;First Name:&quot;/&gt;
            &lt;TextBox Text=&quot;{Binding FirstName, UpdateSourceTrigger=PropertyChanged}&quot;/&gt;

            &lt;Label Content=&quot;Last Name:&quot;/&gt;
            &lt;TextBox Text=&quot;{Binding LastName, UpdateSourceTrigger=PropertyChanged}&quot;/&gt;

            &lt;Label Content=&quot;Department:&quot;/&gt;
            &lt;ComboBox ItemsSource=&quot;{Binding DataContext.Departments,
                                   RelativeSource={RelativeSource AncestorType=Window}}&quot;
                      SelectedItem=&quot;{Binding Department}&quot;
                      DisplayMemberPath=&quot;Name&quot;/&gt;

            &lt;Label Content=&quot;Salary:&quot;/&gt;
            &lt;TextBox Text=&quot;{Binding Salary, StringFormat=C, UpdateSourceTrigger=PropertyChanged}&quot;/&gt;

        &lt;/StackPanel&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>
<h3 id="commands-and-mvvm-pattern">Commands and MVVM Pattern</h3>
<h4 id="relaycommand-implementation">RelayCommand Implementation</h4>
<pre><code class="language-csharp">public class RelayCommand : ICommand
{
    private readonly Action&lt;object&gt; execute;
    private readonly Func&lt;object, bool&gt; canExecute;

    public RelayCommand(Action&lt;object&gt; execute, Func&lt;object, bool&gt; canExecute = null)
    {
        this.execute = execute ?? throw new ArgumentNullException(nameof(execute));
        this.canExecute = canExecute;
    }

    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }

    public bool CanExecute(object parameter)
    {
        return canExecute == null || canExecute(parameter);
    }

    public void Execute(object parameter)
    {
        execute(parameter);
    }
}
</code></pre>
<h4 id="viewmodel-example">ViewModel Example</h4>
<pre><code class="language-csharp">public class MainViewModel : INotifyPropertyChanged
{
    private ObservableCollection&lt;Employee&gt; employees;
    private Employee selectedEmployee;
    private string searchText;

    public MainViewModel()
    {
        Employees = new ObservableCollection&lt;Employee&gt;();
        LoadEmployees();

        // Initialize commands
        AddEmployeeCommand = new RelayCommand(AddEmployee);
        DeleteEmployeeCommand = new RelayCommand(DeleteEmployee, CanDeleteEmployee);
        SearchCommand = new RelayCommand(Search);
    }

    public ObservableCollection&lt;Employee&gt; Employees
    {
        get { return employees; }
        set
        {
            employees = value;
            OnPropertyChanged();
        }
    }

    public Employee SelectedEmployee
    {
        get { return selectedEmployee; }
        set
        {
            selectedEmployee = value;
            OnPropertyChanged();
            CommandManager.InvalidateRequerySuggested(); // Update command states
        }
    }

    public string SearchText
    {
        get { return searchText; }
        set
        {
            searchText = value;
            OnPropertyChanged();
        }
    }

    // Commands
    public ICommand AddEmployeeCommand { get; }
    public ICommand DeleteEmployeeCommand { get; }
    public ICommand SearchCommand { get; }

    private void AddEmployee(object parameter)
    {
        var newEmployee = new Employee
        {
            FirstName = &quot;New&quot;,
            LastName = &quot;Employee&quot;,
            Salary = 50000
        };
        Employees.Add(newEmployee);
        SelectedEmployee = newEmployee;
    }

    private void DeleteEmployee(object parameter)
    {
        if (SelectedEmployee != null)
        {
            Employees.Remove(SelectedEmployee);
            SelectedEmployee = null;
        }
    }

    private bool CanDeleteEmployee(object parameter)
    {
        return SelectedEmployee != null;
    }

    private void Search(object parameter)
    {
        // Implement search logic
        if (string.IsNullOrWhiteSpace(SearchText))
        {
            LoadEmployees(); // Show all
        }
        else
        {
            var filtered = employees.Where(e =&gt;
                e.FirstName.Contains(SearchText, StringComparison.OrdinalIgnoreCase) ||
                e.LastName.Contains(SearchText, StringComparison.OrdinalIgnoreCase)).ToList();

            Employees.Clear();
            foreach (var emp in filtered)
            {
                Employees.Add(emp);
            }
        }
    }

    private void LoadEmployees()
    {
        // Load from database or service
        Employees.Clear();
        // Add sample data
        Employees.Add(new Employee { FirstName = &quot;John&quot;, LastName = &quot;Doe&quot;, Salary = 60000 });
        Employees.Add(new Employee { FirstName = &quot;Jane&quot;, LastName = &quot;Smith&quot;, Salary = 65000 });
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</code></pre>
<h2 id="asp.net-asp.net-core">ASP.NET &amp; ASP.NET Core</h2>
<h3 id="asp.net-core-mvc-architecture">ASP.NET Core MVC Architecture</h3>
<h4 id="model-view-controller-pattern">Model-View-Controller Pattern</h4>
<pre><code>+-------------+    +-------------+    +-------------+
|   Browser   |---&gt;| Controller  |---&gt;|    Model    |
|             |    |             |    |             |
+-------------+    +-------------+    +-------------+
       ^                   |                  |
       |                   V                  |
       |            +-------------+           |
       +------------+    View     +&lt;----------+
                    |             |
                    +-------------+
</code></pre>
<p><strong>MVC Flow:</strong></p>
<ol>
<li><strong>Browser</strong> sends request to <strong>Controller</strong></li>
<li><strong>Controller</strong> processes request, interacts with <strong>Model</strong></li>
<li><strong>Model</strong> returns data to <strong>Controller</strong></li>
<li><strong>Controller</strong> passes data to <strong>View</strong> for rendering</li>
<li><strong>View</strong> sends rendered HTML back to <strong>Browser</strong></li>
</ol>
<h4 id="model-example">Model Example</h4>
<pre><code class="language-csharp">public class Product
{
    public int Id { get; set; }

    [Required(ErrorMessage = &quot;Product name is required&quot;)]
    [StringLength(100, ErrorMessage = &quot;Product name cannot exceed 100 characters&quot;)]
    public string Name { get; set; }

    [Required(ErrorMessage = &quot;Description is required&quot;)]
    public string Description { get; set; }

    [Required(ErrorMessage = &quot;Price is required&quot;)]
    [Range(0.01, double.MaxValue, ErrorMessage = &quot;Price must be greater than 0&quot;)]
    [DataType(DataType.Currency)]
    public decimal Price { get; set; }

    [Required(ErrorMessage = &quot;Category is required&quot;)]
    public int CategoryId { get; set; }

    public Category Category { get; set; }

    [DataType(DataType.Date)]
    public DateTime CreatedDate { get; set; } = DateTime.Now;

    public bool IsActive { get; set; } = true;
}

public class Category
{
    public int Id { get; set; }
    public string Name { get; set; }
    public List&lt;Product&gt; Products { get; set; } = new List&lt;Product&gt;();
}
</code></pre>
<h4 id="controller-example">Controller Example</h4>
<pre><code class="language-csharp">[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ProductsController : ControllerBase
{
    private readonly IProductService productService;
    private readonly ILogger&lt;ProductsController&gt; logger;

    public ProductsController(IProductService productService, ILogger&lt;ProductsController&gt; logger)
    {
        this.productService = productService;
        this.logger = logger;
    }

    // GET: api/products
    [HttpGet]
    public async Task&lt;ActionResult&lt;IEnumerable&lt;Product&gt;&gt;&gt; GetProducts()
    {
        try
        {
            var products = await productService.GetAllProductsAsync();
            return Ok(products);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, &quot;Error retrieving products&quot;);
            return StatusCode(500, &quot;Internal server error&quot;);
        }
    }

    // GET: api/products/5
    [HttpGet(&quot;{id}&quot;)]
    public async Task&lt;ActionResult&lt;Product&gt;&gt; GetProduct(int id)
    {
        var product = await productService.GetProductByIdAsync(id);

        if (product == null)
        {
            return NotFound($&quot;Product with ID {id} not found&quot;);
        }

        return Ok(product);
    }

    // POST: api/products
    [HttpPost]
    public async Task&lt;ActionResult&lt;Product&gt;&gt; CreateProduct(Product product)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        try
        {
            var createdProduct = await productService.CreateProductAsync(product);
            return CreatedAtAction(nameof(GetProduct),
                new { id = createdProduct.Id }, createdProduct);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, &quot;Error creating product&quot;);
            return StatusCode(500, &quot;Internal server error&quot;);
        }
    }

    // PUT: api/products/5
    [HttpPut(&quot;{id}&quot;)]
    public async Task&lt;IActionResult&gt; UpdateProduct(int id, Product product)
    {
        if (id != product.Id)
        {
            return BadRequest(&quot;Product ID mismatch&quot;);
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        try
        {
            await productService.UpdateProductAsync(product);
            return NoContent();
        }
        catch (NotFoundException)
        {
            return NotFound($&quot;Product with ID {id} not found&quot;);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, &quot;Error updating product&quot;);
            return StatusCode(500, &quot;Internal server error&quot;);
        }
    }

    // DELETE: api/products/5
    [HttpDelete(&quot;{id}&quot;)]
    public async Task&lt;IActionResult&gt; DeleteProduct(int id)
    {
        try
        {
            await productService.DeleteProductAsync(id);
            return NoContent();
        }
        catch (NotFoundException)
        {
            return NotFound($&quot;Product with ID {id} not found&quot;);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, &quot;Error deleting product&quot;);
            return StatusCode(500, &quot;Internal server error&quot;);
        }
    }
}
</code></pre>
<h3 id="middleware-in-asp.net-core">Middleware in ASP.NET Core</h3>
<h4 id="definition-14">Definition</h4>
<p>Middleware is software that's assembled into an app pipeline to handle requests and responses.</p>
<h4 id="custom-middleware">Custom Middleware</h4>
<pre><code class="language-csharp">// Custom middleware class
public class RequestLoggingMiddleware
{
    private readonly RequestDelegate next;
    private readonly ILogger&lt;RequestLoggingMiddleware&gt; logger;

    public RequestLoggingMiddleware(RequestDelegate next, ILogger&lt;RequestLoggingMiddleware&gt; logger)
    {
        this.next = next;
        this.logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var startTime = DateTime.UtcNow;
        var requestId = Guid.NewGuid().ToString();

        // Log request
        logger.LogInformation($&quot;[{requestId}] Request started: {context.Request.Method} {context.Request.Path}&quot;);

        try
        {
            // Call the next middleware in the pipeline
            await next(context);
        }
        finally
        {
            var duration = DateTime.UtcNow - startTime;
            logger.LogInformation($&quot;[{requestId}] Request completed: {context.Response.StatusCode} in {duration.TotalMilliseconds:F2}ms&quot;);
        }
    }
}

// Extension method for easier registration
public static class RequestLoggingMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestLogging(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;RequestLoggingMiddleware&gt;();
    }
}
</code></pre>
<h4 id="startupprogram-configuration">Startup/Program Configuration</h4>
<pre><code class="language-csharp">// Program.cs (ASP.NET Core 6+)
var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
    options.UseSqlServer(builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));

// Add custom services
builder.Services.AddScoped&lt;IProductService, ProductService&gt;();

// Add authentication
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt;
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration[&quot;Jwt:Issuer&quot;],
            ValidAudience = builder.Configuration[&quot;Jwt:Audience&quot;],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration[&quot;Jwt:Key&quot;]))
        };
    });

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
    app.UseSwagger();
    app.UseSwaggerUI();
}
else
{
    app.UseExceptionHandler(&quot;/Error&quot;);
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

// Custom middleware
app.UseRequestLogging();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

app.Run();
</code></pre>
<h3 id="crud-operations-using-razor-pages">CRUD Operations using Razor Pages</h3>
<h4 id="page-model">Page Model</h4>
<pre><code class="language-csharp">// Pages/Products/Index.cshtml.cs
public class IndexModel : PageModel
{
    private readonly IProductService productService;

    public IndexModel(IProductService productService)
    {
        this.productService = productService;
    }

    public IList&lt;Product&gt; Products { get; set; }

    [BindProperty(SupportsGet = true)]
    public string SearchString { get; set; }

    public async Task OnGetAsync()
    {
        Products = await productService.GetProductsAsync(SearchString);
    }
}
</code></pre>
<pre><code class="language-html">&lt;!-- Pages/Products/Index.cshtml --&gt;
@page
@model IndexModel
@{
    ViewData[&quot;Title&quot;] = &quot;Products&quot;;
}

&lt;h1&gt;Products&lt;/h1&gt;

&lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-md-6&quot;&gt;
        &lt;a asp-page=&quot;Create&quot; class=&quot;btn btn-primary&quot;&gt;Create New Product&lt;/a&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-6&quot;&gt;
        &lt;form method=&quot;get&quot;&gt;
            &lt;div class=&quot;input-group&quot;&gt;
                &lt;input asp-for=&quot;SearchString&quot; class=&quot;form-control&quot; placeholder=&quot;Search products...&quot;/&gt;
                &lt;div class=&quot;input-group-append&quot;&gt;
                    &lt;button class=&quot;btn btn-outline-secondary&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;table class=&quot;table table-striped mt-3&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Description&lt;/th&gt;
            &lt;th&gt;Price&lt;/th&gt;
            &lt;th&gt;Category&lt;/th&gt;
            &lt;th&gt;Actions&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        @foreach (var product in Model.Products)
        {
            &lt;tr&gt;
                &lt;td&gt;@product.Name&lt;/td&gt;
                &lt;td&gt;@product.Description&lt;/td&gt;
                &lt;td&gt;@product.Price.ToString(&quot;C&quot;)&lt;/td&gt;
                &lt;td&gt;@product.Category?.Name&lt;/td&gt;
                &lt;td&gt;
                    &lt;a asp-page=&quot;Details&quot; asp-route-id=&quot;@product.Id&quot; class=&quot;btn btn-sm btn-info&quot;&gt;Details&lt;/a&gt;
                    &lt;a asp-page=&quot;Edit&quot; asp-route-id=&quot;@product.Id&quot; class=&quot;btn btn-sm btn-warning&quot;&gt;Edit&lt;/a&gt;
                    &lt;a asp-page=&quot;Delete&quot; asp-route-id=&quot;@product.Id&quot; class=&quot;btn btn-sm btn-danger&quot;&gt;Delete&lt;/a&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        }
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<h4 id="create-page">Create Page</h4>
<pre><code class="language-csharp">// Pages/Products/Create.cshtml.cs
public class CreateModel : PageModel
{
    private readonly IProductService productService;

    public CreateModel(IProductService productService)
    {
        this.productService = productService;
    }

    [BindProperty]
    public Product Product { get; set; }

    public SelectList Categories { get; set; }

    public async Task&lt;IActionResult&gt; OnGetAsync()
    {
        await LoadCategoriesAsync();
        return Page();
    }

    public async Task&lt;IActionResult&gt; OnPostAsync()
    {
        if (!ModelState.IsValid)
        {
            await LoadCategoriesAsync();
            return Page();
        }

        await productService.CreateProductAsync(Product);

        TempData[&quot;SuccessMessage&quot;] = &quot;Product created successfully!&quot;;
        return RedirectToPage(&quot;./Index&quot;);
    }

    private async Task LoadCategoriesAsync()
    {
        var categories = await productService.GetCategoriesAsync();
        Categories = new SelectList(categories, &quot;Id&quot;, &quot;Name&quot;);
    }
}
</code></pre>
<h3 id="authentication-and-authorization">Authentication and Authorization</h3>
<h4 id="jwt-authentication">JWT Authentication</h4>
<pre><code class="language-csharp">// Services/AuthService.cs
public class AuthService : IAuthService
{
    private readonly IConfiguration configuration;
    private readonly IUserService userService;

    public AuthService(IConfiguration configuration, IUserService userService)
    {
        this.configuration = configuration;
        this.userService = userService;
    }

    public async Task&lt;AuthResult&gt; LoginAsync(LoginModel model)
    {
        var user = await userService.ValidateUserAsync(model.Email, model.Password);
        if (user == null)
        {
            return new AuthResult { Success = false, Message = &quot;Invalid credentials&quot; };
        }

        var token = GenerateJwtToken(user);
        return new AuthResult
        {
            Success = true,
            Token = token,
            User = user
        };
    }

    private string GenerateJwtToken(User user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(configuration[&quot;Jwt:Key&quot;]);

        var claims = new List&lt;Claim&gt;
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Email),
            new Claim(ClaimTypes.Email, user.Email)
        };

        // Add role claims
        foreach (var role in user.Roles)
        {
            claims.Add(new Claim(ClaimTypes.Role, role));
        }

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddHours(24),
            Issuer = configuration[&quot;Jwt:Issuer&quot;],
            Audience = configuration[&quot;Jwt:Audience&quot;],
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };

        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}
</code></pre>
<h4 id="authorization-policies">Authorization Policies</h4>
<pre><code class="language-csharp">// Program.cs - [COVERED]Authorization setup
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy(&quot;AdminOnly&quot;, policy =&gt;
        policy.RequireRole(&quot;Admin&quot;));

    options.AddPolicy(&quot;ManageProducts&quot;, policy =&gt;
        policy.RequireClaim(&quot;Permission&quot;, &quot;ManageProducts&quot;));

    options.AddPolicy(&quot;MinimumAge&quot;, policy =&gt;
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
});

// Custom authorization requirement
public class MinimumAgeRequirement : IAuthorizationRequirement
{
    public int MinimumAge { get; }

    public MinimumAgeRequirement(int minimumAge)
    {
        MinimumAge = minimumAge;
    }
}

public class MinimumAgeHandler : AuthorizationHandler&lt;MinimumAgeRequirement&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        MinimumAgeRequirement requirement)
    {
        var birthDate = context.User.FindFirst(ClaimTypes.DateOfBirth)?.Value;

        if (DateTime.TryParse(birthDate, out DateTime dateOfBirth))
        {
            var age = DateTime.Today.Year - dateOfBirth.Year;
            if (dateOfBirth.Date &gt; DateTime.Today.AddYears(-age))
                age--;

            if (age &gt;= requirement.MinimumAge)
            {
                context.Succeed(requirement);
            }
        }

        return Task.CompletedTask;
    }
}
</code></pre>
<h3 id="deployment-methods">Deployment Methods</h3>
<h4 id="docker-deployment">Docker Deployment</h4>
<pre><code class="language-dockerfile"># Dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build
WORKDIR /src
COPY [&quot;MyApp/MyApp.csproj&quot;, &quot;MyApp/&quot;]
RUN dotnet restore &quot;MyApp/MyApp.csproj&quot;
COPY . .
WORKDIR &quot;/src/MyApp&quot;
RUN dotnet build &quot;MyApp.csproj&quot; -c Release -o /app/build

FROM build AS publish
RUN dotnet publish &quot;MyApp.csproj&quot; -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT [&quot;dotnet&quot;, &quot;MyApp.dll&quot;]
</code></pre>
<pre><code class="language-yaml"># docker-compose.yml
version: '3.8'
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - [COVERED]&quot;8080:80&quot;
    environment:
      - ConnectionStrings__DefaultConnection=Server=db;Database=MyAppDb;User=sa;Password=YourPassword123;
      - [COVERED]ASPNETCORE_ENVIRONMENT=Production
    depends_on:
      - [COVERED]db

  db:
    image: mcr.microsoft.com/mssql/server:2019-latest
    environment:
      - [COVERED]ACCEPT_EULA=Y
      - [COVERED]SA_PASSWORD=YourPassword123
    ports:
      - [COVERED]&quot;1433:1433&quot;
    volumes:
      - [COVERED]sqldata:/var/opt/mssql

volumes:
  sqldata:
</code></pre>
<h2 id="blazor">Blazor</h2>
<h3 id="definition-15">Definition</h3>
<p>Blazor is a free and open-source web framework that enables developers to create web apps using C# and HTML, running either on the server or in the browser via WebAssembly.</p>
<h3 id="server-side-vs-client-side-blazor">Server-side vs Client-side Blazor</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Blazor Server</th>
<th>Blazor WebAssembly</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Execution</strong></td>
<td>Runs on server</td>
<td>Runs in browser</td>
</tr>
<tr>
<td><strong>Connection</strong></td>
<td>Requires SignalR connection</td>
<td>Works offline</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Fast startup, server processing</td>
<td>Slow startup, client processing</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>Limited by server resources</td>
<td>Scales with client devices</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>Code stays on server</td>
<td>Code downloaded to client</td>
</tr>
<tr>
<td><strong>Network</strong></td>
<td>Requires constant connection</td>
<td>Works with intermittent connection</td>
</tr>
</tbody>
</table>
<h3 id="blazor-components">Blazor Components</h3>
<h4 id="basic-component-structure">Basic Component Structure</h4>
<pre><code class="language-csharp">@* Components/Counter.razor *@
@page &quot;/counter&quot;

&lt;PageTitle&gt;Counter&lt;/PageTitle&gt;

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p role=&quot;status&quot;&gt;Current count: @currentCount&lt;/p&gt;

&lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&gt;Click me&lt;/button&gt;

@code {
    private int currentCount = 0;

    private void IncrementCount()
    {
        currentCount++;
    }
}
</code></pre>
<h4 id="component-with-parameters">Component with Parameters</h4>
<pre><code class="language-csharp">@* Components/ProductCard.razor *@
&lt;div class=&quot;card&quot; style=&quot;width: 18rem;&quot;&gt;
    &lt;div class=&quot;card-body&quot;&gt;
        &lt;h5 class=&quot;card-title&quot;&gt;@Product.Name&lt;/h5&gt;
        &lt;p class=&quot;card-text&quot;&gt;@Product.Description&lt;/p&gt;
        &lt;p class=&quot;card-text&quot;&gt;
            &lt;strong&gt;Price: @Product.Price.ToString(&quot;C&quot;)&lt;/strong&gt;
        &lt;/p&gt;
        &lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;OnPurchaseClick&quot;&gt;
            Buy Now
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;

@code {
    [Parameter] public Product Product { get; set; }
    [Parameter] public EventCallback&lt;Product&gt; OnPurchase { get; set; }

    private async Task OnPurchaseClick()
    {
        await OnPurchase.InvokeAsync(Product);
    }
}
</code></pre>
<h4 id="component-creating-process">Component Creating Process</h4>
<pre><code class="language-csharp">// 1. Define the component class
@inherits ComponentBase
@implements IDisposable

// 2. Add parameters and properties
@code {
    [Parameter] public string Title { get; set; }
    [Parameter] public RenderFragment ChildContent { get; set; }
    [Parameter] public EventCallback&lt;string&gt; OnValueChanged { get; set; }

    [Inject] public IJSRuntime JSRuntime { get; set; }
    [Inject] public IProductService ProductService { get; set; }

    private string inputValue = &quot;&quot;;
    private List&lt;Product&gt; products = new();
    private Timer timer;

    // 3. Lifecycle methods
    protected override async Task OnInitializedAsync()
    {
        products = await ProductService.GetProductsAsync();
        timer = new Timer(UpdateTime, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
    }

    protected override async Task OnParametersSetAsync()
    {
        // Called when parameters change
        if (!string.IsNullOrEmpty(Title))
        {
            await JSRuntime.InvokeVoidAsync(&quot;console.log&quot;, $&quot;Title changed to: {Title}&quot;);
        }
    }

    protected override bool ShouldRender()
    {
        // Control when component re-renders
        return !string.IsNullOrEmpty(Title);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync(&quot;initializeComponent&quot;);
        }
    }

    // 4. Event handlers
    private async Task OnInputChange(ChangeEventArgs e)
    {
        inputValue = e.Value?.ToString() ?? &quot;&quot;;
        await OnValueChanged.InvokeAsync(inputValue);
    }

    private void UpdateTime(object state)
    {
        InvokeAsync(StateHasChanged); // Re-render component
    }

    // 5. Cleanup
    public void Dispose()
    {
        timer?.Dispose();
    }
}
</code></pre>
<h3 id="data-binding-in-blazor">Data Binding in Blazor</h3>
<h4 id="one-way-and-two-way-binding">One-way and Two-way Binding</h4>
<pre><code class="language-csharp">@* Pages/DataBindingDemo.razor *@
@page &quot;/databinding&quot;

&lt;h3&gt;Data Binding Demo&lt;/h3&gt;

&lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-md-6&quot;&gt;
        &lt;!-- [COVERED]One-way binding --&gt;
        &lt;h4&gt;One-way Binding&lt;/h4&gt;
        &lt;p&gt;Current time: @DateTime.Now.ToString(&quot;HH:mm:ss&quot;)&lt;/p&gt;
        &lt;p&gt;User name: @user.Name&lt;/p&gt;
        &lt;p&gt;Is active: @user.IsActive&lt;/p&gt;

        &lt;!-- [COVERED]Two-way binding --&gt;
        &lt;h4&gt;Two-way Binding&lt;/h4&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label&gt;Name:&lt;/label&gt;
            &lt;input @bind=&quot;user.Name&quot; class=&quot;form-control&quot; /&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label&gt;Email:&lt;/label&gt;
            &lt;input @bind=&quot;user.Email&quot; @bind:event=&quot;oninput&quot; class=&quot;form-control&quot; /&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label&gt;Age:&lt;/label&gt;
            &lt;input @bind=&quot;user.Age&quot; type=&quot;number&quot; class=&quot;form-control&quot; /&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label&gt;
                &lt;input type=&quot;checkbox&quot; @bind=&quot;user.IsActive&quot; /&gt;
                Is Active
            &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label&gt;Country:&lt;/label&gt;
            &lt;select @bind=&quot;user.Country&quot; class=&quot;form-control&quot;&gt;
                &lt;option value=&quot;&quot;&gt;Select Country&lt;/option&gt;
                &lt;option value=&quot;US&quot;&gt;United States&lt;/option&gt;
                &lt;option value=&quot;CA&quot;&gt;Canada&lt;/option&gt;
                &lt;option value=&quot;UK&quot;&gt;United Kingdom&lt;/option&gt;
            &lt;/select&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;col-md-6&quot;&gt;
        &lt;h4&gt;Live Preview&lt;/h4&gt;
        &lt;div class=&quot;card&quot;&gt;
            &lt;div class=&quot;card-body&quot;&gt;
                &lt;h5&gt;@user.Name&lt;/h5&gt;
                &lt;p&gt;Email: @user.Email&lt;/p&gt;
                &lt;p&gt;Age: @user.Age&lt;/p&gt;
                &lt;p&gt;Country: @user.Country&lt;/p&gt;
                &lt;p&gt;Status: @(user.IsActive ? &quot;Active&quot; : &quot;Inactive&quot;)&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

@code {
    private User user = new User { Name = &quot;John Doe&quot;, Age = 30, IsActive = true };

    public class User
    {
        public string Name { get; set; } = &quot;&quot;;
        public string Email { get; set; } = &quot;&quot;;
        public int Age { get; set; }
        public bool IsActive { get; set; }
        public string Country { get; set; } = &quot;&quot;;
    }
}
</code></pre>
<h4 id="form-validation">Form Validation</h4>
<pre><code class="language-csharp">@* Pages/UserForm.razor *@
@page &quot;/userform&quot;
@using System.ComponentModel.DataAnnotations

&lt;EditForm Model=&quot;user&quot; OnValidSubmit=&quot;HandleValidSubmit&quot; OnInvalidSubmit=&quot;HandleInvalidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;ValidationSummary /&gt;

    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;First Name:&lt;/label&gt;
        &lt;InputText @bind-Value=&quot;user.FirstName&quot; class=&quot;form-control&quot; /&gt;
        &lt;ValidationMessage For=&quot;@(() =&gt; user.FirstName)&quot; /&gt;
    &lt;/div&gt;

    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;InputText @bind-Value=&quot;user.Email&quot; class=&quot;form-control&quot; /&gt;
        &lt;ValidationMessage For=&quot;@(() =&gt; user.Email)&quot; /&gt;
    &lt;/div&gt;

    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;Birth Date:&lt;/label&gt;
        &lt;InputDate @bind-Value=&quot;user.BirthDate&quot; class=&quot;form-control&quot; /&gt;
        &lt;ValidationMessage For=&quot;@(() =&gt; user.BirthDate)&quot; /&gt;
    &lt;/div&gt;

    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;Salary:&lt;/label&gt;
        &lt;InputNumber @bind-Value=&quot;user.Salary&quot; class=&quot;form-control&quot; /&gt;
        &lt;ValidationMessage For=&quot;@(() =&gt; user.Salary)&quot; /&gt;
    &lt;/div&gt;

    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;
&lt;/EditForm&gt;

@if (isSubmitted)
{
    &lt;div class=&quot;alert alert-success mt-3&quot;&gt;
        Form submitted successfully!
    &lt;/div&gt;
}

@code {
    private UserModel user = new UserModel();
    private bool isSubmitted = false;

    private void HandleValidSubmit()
    {
        isSubmitted = true;
        // Process valid form
    }

    private void HandleInvalidSubmit()
    {
        isSubmitted = false;
        // Handle invalid form
    }

    public class UserModel
    {
        [Required(ErrorMessage = &quot;First name is required&quot;)]
        [StringLength(50, ErrorMessage = &quot;First name cannot exceed 50 characters&quot;)]
        public string FirstName { get; set; } = &quot;&quot;;

        [Required(ErrorMessage = &quot;Email is required&quot;)]
        [EmailAddress(ErrorMessage = &quot;Invalid email format&quot;)]
        public string Email { get; set; } = &quot;&quot;;

        [Required(ErrorMessage = &quot;Birth date is required&quot;)]
        [DataType(DataType.Date)]
        public DateTime BirthDate { get; set; } = DateTime.Today.AddYears(-18);

        [Range(0, double.MaxValue, ErrorMessage = &quot;Salary must be positive&quot;)]
        public decimal Salary { get; set; }
    }
}
</code></pre>
<h3 id="javascript-interop">JavaScript Interop</h3>
<pre><code class="language-csharp">@* Components/JSInteropDemo.razor *@
@inject IJSRuntime JSRuntime

&lt;h3&gt;JavaScript Interop Demo&lt;/h3&gt;

&lt;button @onclick=&quot;ShowAlert&quot;&gt;Show Alert&lt;/button&gt;
&lt;button @onclick=&quot;CallJSFunction&quot;&gt;Call JS Function&lt;/button&gt;
&lt;button @onclick=&quot;GetUserLocation&quot;&gt;Get Location&lt;/button&gt;

&lt;div id=&quot;map&quot; style=&quot;height: 300px; width: 100%; margin-top: 20px;&quot;&gt;&lt;/div&gt;

@code {
    private async Task ShowAlert()
    {
        await JSRuntime.InvokeVoidAsync(&quot;alert&quot;, &quot;Hello from Blazor!&quot;);
    }

    private async Task CallJSFunction()
    {
        var result = await JSRuntime.InvokeAsync&lt;string&gt;(&quot;prompt&quot;, &quot;Enter your name:&quot;);
        if (!string.IsNullOrEmpty(result))
        {
            await JSRuntime.InvokeVoidAsync(&quot;console.log&quot;, $&quot;User entered: {result}&quot;);
        }
    }

    private async Task GetUserLocation()
    {
        try
        {
            var location = await JSRuntime.InvokeAsync&lt;LocationData&gt;(&quot;getUserLocation&quot;);
            await JSRuntime.InvokeVoidAsync(&quot;initializeMap&quot;, location.Latitude, location.Longitude);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync(&quot;console.error&quot;, $&quot;Error getting location: {ex.Message}&quot;);
        }
    }

    public class LocationData
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
    }
}
</code></pre>
<pre><code class="language-javascript">// wwwroot/js/site.js
window.getUserLocation = () =&gt; {
    return new Promise((resolve, reject) =&gt; {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                position =&gt; {
                    resolve({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude
                    });
                },
                error =&gt; reject(error)
            );
        } else {
            reject(new Error(&quot;Geolocation is not supported&quot;));
        }
    });
};

window.initializeMap = (lat, lng) =&gt; {
    // Initialize map with given coordinates
    console.log(`Initializing map at ${lat}, ${lng}`);
};
</code></pre>
<h3 id="razor-class-library">Razor Class Library</h3>
<h4 id="creating-a-razor-class-library">Creating a Razor Class Library</h4>
<pre><code class="language-xml">&lt;!-- MyBlazorLibrary.csproj --&gt;
&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Razor&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;SupportedPlatform Include=&quot;browser&quot; /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Components.Web&quot; Version=&quot;6.0.0&quot; /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<h4 id="shared-components-in-library">Shared Components in Library</h4>
<pre><code class="language-csharp">@* Components/SharedButton.razor *@
@namespace MyBlazorLibrary.Components

&lt;button class=&quot;btn @CssClass&quot; @onclick=&quot;OnClick&quot;&gt;
    @if (!string.IsNullOrEmpty(Icon))
    {
        &lt;i class=&quot;@Icon&quot;&gt;&lt;/i&gt;
    }
    @Text
&lt;/button&gt;

@code {
    [Parameter] public string Text { get; set; } = &quot;Button&quot;;
    [Parameter] public string Icon { get; set; } = &quot;&quot;;
    [Parameter] public string CssClass { get; set; } = &quot;btn-primary&quot;;
    [Parameter] public EventCallback OnClick { get; set; }
}
</code></pre>
<h4 id="using-library-in-main-project">Using Library in Main Project</h4>
<pre><code class="language-csharp">@* Add to _Imports.razor *@
@using MyBlazorLibrary.Components

@* Use in components *@
&lt;SharedButton Text=&quot;Save&quot;
              Icon=&quot;fas fa-save&quot;
              CssClass=&quot;btn-success&quot;
              OnClick=&quot;SaveData&quot; /&gt;
</code></pre>
<h3 id="state-management">State Management</h3>
<pre><code class="language-csharp">// Services/AppStateService.cs
public class AppStateService
{
    private string currentUser = &quot;&quot;;
    private Dictionary&lt;string, object&gt; state = new();

    public event Action OnChange;

    public string CurrentUser
    {
        get =&gt; currentUser;
        set
        {
            currentUser = value;
            NotifyStateChanged();
        }
    }

    public T GetState&lt;T&gt;(string key, T defaultValue = default)
    {
        if (state.TryGetValue(key, out var value) &amp;&amp; value is T)
        {
            return (T)value;
        }
        return defaultValue;
    }

    public void SetState&lt;T&gt;(string key, T value)
    {
        state[key] = value;
        NotifyStateChanged();
    }

    private void NotifyStateChanged() =&gt; OnChange?.Invoke();
}

// Program.cs
builder.Services.AddScoped&lt;AppStateService&gt;();

// Component usage
@inject AppStateService AppState
@implements IDisposable

@code {
    protected override void OnInitialized()
    {
        AppState.OnChange += StateHasChanged;
    }

    public void Dispose()
    {
        AppState.OnChange -= StateHasChanged;
    }
}
</code></pre>
<h2 id="xamarin">Xamarin</h2>
<h3 id="xamarin-vs-xamarin.forms">Xamarin vs Xamarin.Forms</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Xamarin.iOS/Android</th>
<th>Xamarin.Forms</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UI</strong></td>
<td>Platform-specific UI</td>
<td>Shared UI across platforms</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Native performance</td>
<td>Near-native performance</td>
</tr>
<tr>
<td><strong>Code Sharing</strong></td>
<td>Business logic only</td>
<td>UI + Business logic</td>
</tr>
<tr>
<td><strong>Learning Curve</strong></td>
<td>Requires platform knowledge</td>
<td>Easier for beginners</td>
</tr>
<tr>
<td><strong>Customization</strong></td>
<td>Full platform control</td>
<td>Limited to Forms controls</td>
</tr>
<tr>
<td><strong>Use Case</strong></td>
<td>Complex, platform-specific apps</td>
<td>Cross-platform business apps</td>
</tr>
</tbody>
</table>
<h3 id="mvc-and-mvvm-design-patterns">MVC and MVVM Design Patterns</h3>
<h4 id="mvc-pattern-in-xamarin">MVC Pattern in Xamarin</h4>
<pre><code class="language-csharp">// Model
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Description { get; set; }
}

// Controller (in Xamarin, this is often the Page code-behind)
public partial class ProductListPage : ContentPage
{
    private readonly ProductService productService;
    private List&lt;Product&gt; products;

    public ProductListPage()
    {
        InitializeComponent();
        productService = new ProductService();
        LoadProducts();
    }

    private async void LoadProducts()
    {
        try
        {
            products = await productService.GetProductsAsync();
            ProductListView.ItemsSource = products;
        }
        catch (Exception ex)
        {
            await DisplayAlert(&quot;Error&quot;, $&quot;Failed to load products: {ex.Message}&quot;, &quot;OK&quot;);
        }
    }

    private async void OnProductSelected(object sender, SelectedItemChangedEventArgs e)
    {
        if (e.SelectedItem is Product product)
        {
            await Navigation.PushAsync(new ProductDetailPage(product));
        }
    }
}
</code></pre>
<h4 id="mvvm-pattern-in-xamarin.forms">MVVM Pattern in Xamarin.Forms</h4>
<pre><code class="language-csharp">// ViewModel
public class ProductListViewModel : INotifyPropertyChanged
{
    private readonly ProductService productService;
    private ObservableCollection&lt;Product&gt; products;
    private Product selectedProduct;
    private bool isLoading;
    private string searchText;

    public ProductListViewModel()
    {
        productService = DependencyService.Get&lt;ProductService&gt;();
        Products = new ObservableCollection&lt;Product&gt;();

        LoadProductsCommand = new Command(async () =&gt; await LoadProducts());
        SearchCommand = new Command&lt;string&gt;(async (searchText) =&gt; await SearchProducts(searchText));
        SelectProductCommand = new Command&lt;Product&gt;(async (product) =&gt; await SelectProduct(product));

        LoadProductsCommand.Execute(null);
    }

    public ObservableCollection&lt;Product&gt; Products
    {
        get =&gt; products;
        set
        {
            products = value;
            OnPropertyChanged();
        }
    }

    public Product SelectedProduct
    {
        get =&gt; selectedProduct;
        set
        {
            selectedProduct = value;
            OnPropertyChanged();
        }
    }

    public bool IsLoading
    {
        get =&gt; isLoading;
        set
        {
            isLoading = value;
            OnPropertyChanged();
        }
    }

    public string SearchText
    {
        get =&gt; searchText;
        set
        {
            searchText = value;
            OnPropertyChanged();
            SearchCommand.Execute(value);
        }
    }

    public ICommand LoadProductsCommand { get; }
    public ICommand SearchCommand { get; }
    public ICommand SelectProductCommand { get; }

    private async Task LoadProducts()
    {
        IsLoading = true;
        try
        {
            var productList = await productService.GetProductsAsync();
            Products.Clear();
            foreach (var product in productList)
            {
                Products.Add(product);
            }
        }
        catch (Exception ex)
        {
            // Handle error
            await Application.Current.MainPage.DisplayAlert(&quot;Error&quot;, ex.Message, &quot;OK&quot;);
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task SearchProducts(string searchText)
    {
        if (string.IsNullOrWhiteSpace(searchText))
        {
            await LoadProducts();
            return;
        }

        var filtered = await productService.SearchProductsAsync(searchText);
        Products.Clear();
        foreach (var product in filtered)
        {
            Products.Add(product);
        }
    }

    private async Task SelectProduct(Product product)
    {
        if (product != null)
        {
            await Shell.Current.GoToAsync($&quot;productdetail?productId={product.Id}&quot;);
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</code></pre>
<h3 id="xaml-and-key-elements">XAML and Key Elements</h3>
<h4 id="basic-xaml-structure">Basic XAML Structure</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;MyApp.Views.ProductListPage&quot;
             Title=&quot;Products&quot;&gt;

    &lt;ContentPage.BindingContext&gt;
        &lt;vm:ProductListViewModel /&gt;
    &lt;/ContentPage.BindingContext&gt;

    &lt;ContentPage.ToolbarItems&gt;
        &lt;ToolbarItem Text=&quot;Add&quot;
                     IconImageSource=&quot;add_icon.png&quot;
                     Command=&quot;{Binding AddProductCommand}&quot; /&gt;
    &lt;/ContentPage.ToolbarItems&gt;

    &lt;Grid&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height=&quot;Auto&quot; /&gt;
            &lt;RowDefinition Height=&quot;*&quot; /&gt;
        &lt;/Grid.RowDefinitions&gt;

        &lt;!-- [COVERED]Search Bar --&gt;
        &lt;SearchBar Grid.Row=&quot;0&quot;
                   Placeholder=&quot;Search products...&quot;
                   Text=&quot;{Binding SearchText}&quot;
                   SearchCommand=&quot;{Binding SearchCommand}&quot;
                   Margin=&quot;10&quot; /&gt;

        &lt;!-- [COVERED]Product List --&gt;
        &lt;CollectionView Grid.Row=&quot;1&quot;
                        ItemsSource=&quot;{Binding Products}&quot;
                        SelectedItem=&quot;{Binding SelectedProduct}&quot;
                        SelectionMode=&quot;Single&quot;&gt;

            &lt;CollectionView.ItemTemplate&gt;
                &lt;DataTemplate&gt;
                    &lt;Grid Padding=&quot;15&quot;&gt;
                        &lt;Grid.ColumnDefinitions&gt;
                            &lt;ColumnDefinition Width=&quot;80&quot; /&gt;
                            &lt;ColumnDefinition Width=&quot;*&quot; /&gt;
                            &lt;ColumnDefinition Width=&quot;Auto&quot; /&gt;
                        &lt;/Grid.ColumnDefinitions&gt;

                        &lt;Image Grid.Column=&quot;0&quot;
                               Source=&quot;{Binding ImageUrl}&quot;
                               Aspect=&quot;AspectFill&quot;
                               HeightRequest=&quot;60&quot;
                               WidthRequest=&quot;60&quot; /&gt;

                        &lt;StackLayout Grid.Column=&quot;1&quot;
                                     Spacing=&quot;5&quot;
                                     Margin=&quot;10,0&quot;&gt;
                            &lt;Label Text=&quot;{Binding Name}&quot;
                                   FontSize=&quot;16&quot;
                                   FontAttributes=&quot;Bold&quot; /&gt;
                            &lt;Label Text=&quot;{Binding Description}&quot;
                                   FontSize=&quot;14&quot;
                                   TextColor=&quot;Gray&quot; /&gt;
                        &lt;/StackLayout&gt;

                        &lt;Label Grid.Column=&quot;2&quot;
                               Text=&quot;{Binding Price, StringFormat='{0:C}'}&quot;
                               FontSize=&quot;16&quot;
                               FontAttributes=&quot;Bold&quot;
                               VerticalOptions=&quot;Center&quot; /&gt;
                    &lt;/Grid&gt;
                &lt;/DataTemplate&gt;
            &lt;/CollectionView.ItemTemplate&gt;
        &lt;/CollectionView&gt;

        &lt;!-- [COVERED]Loading Indicator --&gt;
        &lt;ActivityIndicator Grid.RowSpan=&quot;2&quot;
                          IsVisible=&quot;{Binding IsLoading}&quot;
                          IsRunning=&quot;{Binding IsLoading}&quot;
                          Color=&quot;Blue&quot;
                          HorizontalOptions=&quot;Center&quot;
                          VerticalOptions=&quot;Center&quot; /&gt;
    &lt;/Grid&gt;
&lt;/ContentPage&gt;
</code></pre>
<h3 id="sqlite.net-in-xamarin-apps">SQLite.NET in Xamarin Apps</h3>
<h4 id="database-model">Database Model</h4>
<pre><code class="language-csharp">[Table(&quot;Products&quot;)]
public class Product
{
    [PrimaryKey, AutoIncrement]
    public int Id { get; set; }

    [MaxLength(100), NotNull]
    public string Name { get; set; }

    public string Description { get; set; }

    [NotNull]
    public decimal Price { get; set; }

    [MaxLength(50)]
    public string Category { get; set; }

    public DateTime CreatedDate { get; set; } = DateTime.Now;

    public bool IsActive { get; set; } = true;

    // Foreign key
    public int CategoryId { get; set; }
}

[Table(&quot;Categories&quot;)]
public class Category
{
    [PrimaryKey, AutoIncrement]
    public int Id { get; set; }

    [MaxLength(50), NotNull]
    public string Name { get; set; }

    public string Description { get; set; }
}
</code></pre>
<h4 id="database-service">Database Service</h4>
<pre><code class="language-csharp">public class DatabaseService
{
    private SQLiteAsyncConnection database;
    private readonly string databasePath;

    public DatabaseService()
    {
        databasePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), &quot;Products.db3&quot;);
    }

    private async Task InitializeDatabaseAsync()
    {
        if (database is not null)
            return;

        database = new SQLiteAsyncConnection(databasePath);

        await database.CreateTableAsync&lt;Product&gt;();
        await database.CreateTableAsync&lt;Category&gt;();

        // Seed data if needed
        await SeedDataAsync();
    }

    // CRUD Operations for Products
    public async Task&lt;List&lt;Product&gt;&gt; GetProductsAsync()
    {
        await InitializeDatabaseAsync();
        return await database.Table&lt;Product&gt;()
            .Where(p =&gt; p.IsActive)
            .OrderBy(p =&gt; p.Name)
            .ToListAsync();
    }

    public async Task&lt;Product&gt; GetProductByIdAsync(int id)
    {
        await InitializeDatabaseAsync();
        return await database.Table&lt;Product&gt;()
            .Where(p =&gt; p.Id == id)
            .FirstOrDefaultAsync();
    }

    public async Task&lt;int&gt; SaveProductAsync(Product product)
    {
        await InitializeDatabaseAsync();

        if (product.Id != 0)
        {
            return await database.UpdateAsync(product);
        }
        else
        {
            return await database.InsertAsync(product);
        }
    }

    public async Task&lt;int&gt; DeleteProductAsync(Product product)
    {
        await InitializeDatabaseAsync();
        return await database.DeleteAsync(product);
    }

    public async Task&lt;List&lt;Product&gt;&gt; SearchProductsAsync(string searchText)
    {
        await InitializeDatabaseAsync();
        return await database.Table&lt;Product&gt;()
            .Where(p =&gt; p.IsActive &amp;&amp;
                   (p.Name.Contains(searchText) || p.Description.Contains(searchText)))
            .ToListAsync();
    }

    // Category operations
    public async Task&lt;List&lt;Category&gt;&gt; GetCategoriesAsync()
    {
        await InitializeDatabaseAsync();
        return await database.Table&lt;Category&gt;().ToListAsync();
    }

    private async Task SeedDataAsync()
    {
        var categoryCount = await database.Table&lt;Category&gt;().CountAsync();
        if (categoryCount == 0)
        {
            var categories = new List&lt;Category&gt;
            {
                new Category { Name = &quot;Electronics&quot;, Description = &quot;Electronic devices&quot; },
                new Category { Name = &quot;Clothing&quot;, Description = &quot;Apparel and accessories&quot; },
                new Category { Name = &quot;Books&quot;, Description = &quot;Books and literature&quot; }
            };

            await database.InsertAllAsync(categories);
        }
    }
}
</code></pre>
<h3 id="navigation-patterns-in-xamarin.forms">Navigation Patterns in Xamarin.Forms</h3>
<h4 id="shell-navigation">Shell Navigation</h4>
<pre><code class="language-csharp">// AppShell.xaml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Shell xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
       xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
       xmlns:views=&quot;clr-namespace:MyApp.Views&quot;
       x:Class=&quot;MyApp.AppShell&quot;&gt;

    &lt;TabBar&gt;
        &lt;ShellContent Title=&quot;Products&quot;
                      Icon=&quot;products_icon.png&quot;
                      ContentTemplate=&quot;{DataTemplate views:ProductListPage}&quot; /&gt;

        &lt;ShellContent Title=&quot;Categories&quot;
                      Icon=&quot;categories_icon.png&quot;
                      ContentTemplate=&quot;{DataTemplate views:CategoriesPage}&quot; /&gt;

        &lt;ShellContent Title=&quot;Profile&quot;
                      Icon=&quot;profile_icon.png&quot;
                      ContentTemplate=&quot;{DataTemplate views:ProfilePage}&quot; /&gt;
    &lt;/TabBar&gt;

&lt;/Shell&gt;
</code></pre>
<pre><code class="language-csharp">// Registering routes
public partial class AppShell : Shell
{
    public AppShell()
    {
        InitializeComponent();

        // Register routes for navigation
        Routing.RegisterRoute(&quot;productdetail&quot;, typeof(ProductDetailPage));
        Routing.RegisterRoute(&quot;editproduct&quot;, typeof(EditProductPage));
        Routing.RegisterRoute(&quot;addproduct&quot;, typeof(AddProductPage));
    }
}

// Navigation in ViewModels
public class ProductListViewModel : BaseViewModel
{
    private async Task NavigateToProductDetail(Product product)
    {
        var route = $&quot;productdetail?productId={product.Id}&quot;;
        await Shell.Current.GoToAsync(route);
    }

    private async Task NavigateToAddProduct()
    {
        await Shell.Current.GoToAsync(&quot;addproduct&quot;);
    }

    private async Task NavigateBack()
    {
        await Shell.Current.GoToAsync(&quot;..&quot;);
    }
}

// Receiving parameters
[QueryProperty(nameof(ProductId), &quot;productId&quot;)]
public partial class ProductDetailPage : ContentPage
{
    public string ProductId
    {
        set
        {
            if (int.TryParse(value, out int id))
            {
                ((ProductDetailViewModel)BindingContext).LoadProduct(id);
            }
        }
    }
}
</code></pre>
<h4 id="traditional-navigation">Traditional Navigation</h4>
<pre><code class="language-csharp">public class NavigationService : INavigationService
{
    public async Task NavigateToAsync(string pageName, object parameter = null)
    {
        Page page = pageName switch
        {
            &quot;ProductDetail&quot; =&gt; new ProductDetailPage(),
            &quot;EditProduct&quot; =&gt; new EditProductPage(),
            &quot;AddProduct&quot; =&gt; new AddProductPage(),
            _ =&gt; throw new ArgumentException($&quot;Unknown page: {pageName}&quot;)
        };

        if (page.BindingContext is BaseViewModel viewModel &amp;&amp; parameter != null)
        {
            await viewModel.InitializeAsync(parameter);
        }

        await Application.Current.MainPage.Navigation.PushAsync(page);
    }

    public async Task NavigateBackAsync()
    {
        await Application.Current.MainPage.Navigation.PopAsync();
    }

    public async Task NavigateToModalAsync(string pageName, object parameter = null)
    {
        Page page = CreatePage(pageName);

        if (page.BindingContext is BaseViewModel viewModel &amp;&amp; parameter != null)
        {
            await viewModel.InitializeAsync(parameter);
        }

        await Application.Current.MainPage.Navigation.PushModalAsync(new NavigationPage(page));
    }
}
</code></pre>
<h2 id="summary-and-quick-reference">Summary and Quick Reference</h2>
<h3 id="key-concepts-checklist">Key Concepts Checklist</h3>
<h4 id="programming-fundamentals">Programming Fundamentals</h4>
<ul>
<li>[COVERED]â€¦ <strong>Visual vs Text Programming</strong>: Visual uses drag-drop; Text uses code</li>
<li>[COVERED]â€¦ <strong>Event-Driven Programming</strong>: Program flow controlled by events (clicks, input)</li>
<li>[COVERED]â€¦ <strong>.NET Architecture</strong>: CLR + BCL + Your App</li>
<li>[COVERED]â€¦ <strong>RAD Tools</strong>: Visual Studio, IntelliSense, designers for rapid development</li>
</ul>
<h4 id="c-language-features">C# Language Features</h4>
<ul>
<li>[COVERED]â€¦ <strong>Type Conversion</strong>: Implicit (safe), Explicit (cast), Boxing/Unboxing</li>
<li>[COVERED]â€¦ <strong>Structures</strong>: Value types, immutable, no inheritance</li>
<li>[COVERED]â€¦ <strong>Enumerations</strong>: Named constants, type-safe, can use flags</li>
<li>[COVERED]â€¦ <strong>Collections</strong>: Generic (List<T>, Dictionary&lt;K,V&gt;) vs Non-generic (ArrayList)</li>
<li>[COVERED]â€¦ <strong>Regex</strong>: Pattern matching with <code>Regex</code> class</li>
</ul>
<h4 id="oop-principles">OOP Principles</h4>
<ul>
<li>[COVERED]â€¦ <strong>Polymorphism</strong>: Overloading (compile-time) vs Overriding (runtime)</li>
<li>[COVERED]â€¦ <strong>Abstract vs Interface</strong>: Abstract has implementation; Interface is contract</li>
<li>[COVERED]â€¦ <strong>Inheritance</strong>: IS-A relationship, virtual/override for polymorphism</li>
<li>[COVERED]â€¦ <strong>Encapsulation</strong>: Private fields, public properties, controlled access</li>
</ul>
<h4 id="advanced-topics">Advanced Topics</h4>
<ul>
<li>[COVERED]â€¦ <strong>Exception Handling</strong>: try-catch-finally, custom exceptions, proper cleanup</li>
<li>[COVERED]â€¦ <strong>Parallel Programming</strong>: Tasks, Parallel.For, PLINQ, async/await</li>
<li>[COVERED]â€¦ <strong>ADO.NET</strong>: DataReader (connected) vs DataSet (disconnected)</li>
<li>[COVERED]â€¦ <strong>LINQ to SQL</strong>: Object-relational mapping with strongly-typed queries</li>
</ul>
<h4 id="ui-technologies">UI Technologies</h4>
<ul>
<li>[COVERED]â€¦ <strong>WPF</strong>: XAML + C#, data binding, MVVM pattern, rich desktop apps</li>
<li>[COVERED]â€¦ <strong>ASP.NET Core</strong>: MVC pattern, middleware pipeline, Razor Pages</li>
<li>[COVERED]â€¦ <strong>Blazor</strong>: C# in browser, Server vs WebAssembly, component-based</li>
<li>[COVERED]â€¦ <strong>Xamarin</strong>: Cross-platform mobile, XAML UI, SQLite data, Shell navigation</li>
</ul>
<h2 id="exam-questions-and-answers">Exam Questions and Answers</h2>
<h3 id="question-1-explain-the-value-type-and-reference-type-in-c-with-example">Question 1: Explain the value type and reference type in C# with example.</h3>
<h4 id="value-types">Value Types</h4>
<p>Value types store data directly in memory (usually on the stack). When you assign a value type to another variable, a copy of the data is created.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Stored on stack (for local variables)</li>
<li>Direct memory allocation</li>
<li>Assignment creates a copy</li>
<li>Cannot be null (except nullable types)</li>
<li>Examples: int, float, double, bool, char, struct, enum</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">// Value type example
int a = 10;
int b = a;    // Copy of 'a' is created
a = 20;       // Only 'a' changes, 'b' remains 10

Console.WriteLine($&quot;a = {a}&quot;); // Output: a = 20
Console.WriteLine($&quot;b = {b}&quot;); // Output: b = 10

// Struct example (value type)
public struct Point
{
    public int X, Y;
    public Point(int x, int y) { X = x; Y = y; }
}

Point p1 = new Point(5, 10);
Point p2 = p1;    // Copy created
p1.X = 15;        // Only p1 changes
Console.WriteLine($&quot;p1.X = {p1.X}, p2.X = {p2.X}&quot;); // Output: p1.X = 15, p2.X = 5
</code></pre>
<h4 id="reference-types">Reference Types</h4>
<p>Reference types store a reference (address) to the actual data location in memory (heap). When you assign a reference type, both variables point to the same memory location.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Stored on heap</li>
<li>Assignment copies the reference, not the data</li>
<li>Multiple variables can reference the same object</li>
<li>Can be null</li>
<li>Examples: string, object, class, interface, delegate, array</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">// Reference type example
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

Person person1 = new Person { Name = &quot;John&quot;, Age = 25 };
Person person2 = person1;    // Both variables reference same object

person1.Age = 30;            // Changes affect both references
Console.WriteLine($&quot;person1.Age = {person1.Age}&quot;); // Output: person1.Age = 30
Console.WriteLine($&quot;person2.Age = {person2.Age}&quot;); // Output: person2.Age = 30

// Array example (reference type)
int[] array1 = { 1, 2, 3 };
int[] array2 = array1;       // Both reference same array
array1[0] = 10;              // Changes affect both
Console.WriteLine($&quot;array2[0] = {array2[0]}&quot;); // Output: array2[0] = 10
</code></pre>
<h4 id="memory-allocation-comparison">Memory Allocation Comparison</h4>
<pre><code class="language-csharp">public void CompareTypes()
{
    // Value type - stored on stack
    int valueType = 42;

    // Reference type - reference on stack, object on heap
    string referenceType = &quot;Hello&quot;;

    // Nullable value type
    int? nullableInt = null;  // Can be null

    // Boxing: value type -&gt; reference type
    object boxed = valueType;  // valueType copied to heap

    // Unboxing: reference type -&gt; value type
    int unboxed = (int)boxed;  // Copy from heap to stack
}
</code></pre>
<h3 id="question-2-what-is-an-event-in-c-explain-how-to-implement-event-using-delegate-in-c.net">Question 2: What is an event in C#? Explain how to implement event using delegate in C#.NET?</h3>
<h4 id="what-is-an-event">What is an Event?</h4>
<p>An event in C# is a special kind of multicast delegate that provides notifications when something of interest happens. Events enable a class to notify other classes when something occurs, following the publisher-subscriber pattern.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li>Based on delegates</li>
<li>Encapsulated (cannot be directly invoked from outside the class)</li>
<li>Supports multiple subscribers</li>
<li>Provides loose coupling between publisher and subscriber</li>
</ul>
<h4 id="event-implementation-using-delegates">Event Implementation Using Delegates</h4>
<p><strong>Step 1: Define Delegate and Event</strong></p>
<pre><code class="language-csharp">// Define delegate for event handler
public delegate void NotificationEventHandler(string message);

public class Publisher
{
    // Declare event based on delegate
    public event NotificationEventHandler OnNotification;

    // Method to raise the event
    protected virtual void RaiseNotification(string message)
    {
        // Check if there are subscribers before raising event
        OnNotification?.Invoke(message);
    }

    // Method that triggers the event
    public void DoSomething()
    {
        Console.WriteLine(&quot;Publisher: Doing some work...&quot;);

        // Trigger the event
        RaiseNotification(&quot;Work completed successfully!&quot;);
    }
}
</code></pre>
<p><strong>Step 2: Create Subscribers</strong></p>
<pre><code class="language-csharp">public class Subscriber1
{
    public void Subscribe(Publisher pub)
    {
        // Subscribe to the event
        pub.OnNotification += HandleNotification;
    }

    public void Unsubscribe(Publisher pub)
    {
        // Unsubscribe from the event
        pub.OnNotification -= HandleNotification;
    }

    private void HandleNotification(string message)
    {
        Console.WriteLine($&quot;Subscriber1 received: {message}&quot;);
    }
}

public class Subscriber2
{
    public void Subscribe(Publisher pub)
    {
        pub.OnNotification += HandleNotification;
    }

    private void HandleNotification(string message)
    {
        Console.WriteLine($&quot;Subscriber2 received: {message}&quot;);
    }
}
</code></pre>
<p><strong>Step 3: Usage Example</strong></p>
<pre><code class="language-csharp">public class EventDemo
{
    public static void Main()
    {
        // Create publisher and subscribers
        Publisher publisher = new Publisher();
        Subscriber1 sub1 = new Subscriber1();
        Subscriber2 sub2 = new Subscriber2();

        // Subscribe to events
        sub1.Subscribe(publisher);
        sub2.Subscribe(publisher);

        // Trigger event
        publisher.DoSomething();

        // Output:
        // Publisher: Doing some work...
        // Subscriber1 received: Work completed successfully!
        // Subscriber2 received: Work completed successfully!

        // Unsubscribe one subscriber
        sub1.Unsubscribe(publisher);

        // Trigger event again
        publisher.DoSomething();

        // Output:
        // Publisher: Doing some work...
        // Subscriber2 received: Work completed successfully!
    }
}
</code></pre>
<h4 id="advanced-event-example-with-eventargs">Advanced Event Example with EventArgs</h4>
<pre><code class="language-csharp">// Custom EventArgs class
public class OrderEventArgs : EventArgs
{
    public string OrderId { get; set; }
    public decimal Amount { get; set; }
    public DateTime OrderDate { get; set; }
}

// Publisher class
public class OrderProcessor
{
    // Event using EventHandler&lt;T&gt; generic delegate
    public event EventHandler&lt;OrderEventArgs&gt; OrderProcessed;

    public void ProcessOrder(string orderId, decimal amount)
    {
        Console.WriteLine($&quot;Processing order {orderId}...&quot;);

        // Simulate processing
        Thread.Sleep(1000);

        // Raise event with custom data
        OnOrderProcessed(new OrderEventArgs
        {
            OrderId = orderId,
            Amount = amount,
            OrderDate = DateTime.Now
        });
    }

    protected virtual void OnOrderProcessed(OrderEventArgs e)
    {
        OrderProcessed?.Invoke(this, e);
    }
}

// Subscriber classes
public class EmailNotificationService
{
    public void Subscribe(OrderProcessor processor)
    {
        processor.OrderProcessed += OnOrderProcessed;
    }

    private void OnOrderProcessed(object sender, OrderEventArgs e)
    {
        Console.WriteLine($&quot;Email: Order {e.OrderId} for ${e.Amount} processed at {e.OrderDate}&quot;);
    }
}

public class InventoryService
{
    public void Subscribe(OrderProcessor processor)
    {
        processor.OrderProcessed += OnOrderProcessed;
    }

    private void OnOrderProcessed(object sender, OrderEventArgs e)
    {
        Console.WriteLine($&quot;Inventory: Updating stock for order {e.OrderId}&quot;);
    }
}
</code></pre>
<h3 id="question-3-what-is-deferred-evaluation-discuss-different-standard-linq-operators">Question 3: What is deferred evaluation? Discuss different standard LINQ operators.</h3>
<h4 id="deferred-evaluation">Deferred Evaluation</h4>
<p>Deferred evaluation (also called lazy evaluation) means that the execution of a LINQ query is delayed until the results are actually needed. The query is not executed when it's defined, but when it's enumerated.</p>
<p><strong>Key Points:</strong></p>
<ul>
<li>Query execution is postponed until results are accessed</li>
<li>Allows for query optimization</li>
<li>Enables composition of multiple queries</li>
<li>Results reflect current data state when enumerated</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void DeferredEvaluationExample()
{
    List&lt;int&gt; numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5 };

    // Query is defined but NOT executed yet
    var evenNumbers = numbers.Where(n =&gt; n % 2 == 0);

    Console.WriteLine(&quot;Before adding new numbers:&quot;);
    foreach (int num in evenNumbers)  // Query executes HERE
    {
        Console.WriteLine(num);  // Output: 2, 4
    }

    // Add more numbers
    numbers.AddRange(new[] { 6, 7, 8 });

    Console.WriteLine(&quot;After adding new numbers:&quot;);
    foreach (int num in evenNumbers)  // Query executes AGAIN with new data
    {
        Console.WriteLine(num);  // Output: 2, 4, 6, 8
    }
}
</code></pre>
<h4 id="standard-linq-operators">Standard LINQ Operators</h4>
<p><strong>1. Filtering Operators</strong></p>
<pre><code class="language-csharp">var numbers = Enumerable.Range(1, 20);

// Where - filters based on predicate
var evenNumbers = numbers.Where(n =&gt; n % 2 == 0);

// OfType - filters by type
object[] mixed = { 1, &quot;hello&quot;, 3.14, &quot;world&quot;, 42 };
var strings = mixed.OfType&lt;string&gt;();
</code></pre>
<p><strong>2. Projection Operators</strong></p>
<pre><code class="language-csharp">var people = new[]
{
    new { Name = &quot;John&quot;, Age = 25 },
    new { Name = &quot;Jane&quot;, Age = 30 },
    new { Name = &quot;Bob&quot;, Age = 35 }
};

// Select - transforms each element
var names = people.Select(p =&gt; p.Name);
var upperNames = people.Select(p =&gt; p.Name.ToUpper());

// SelectMany - flattens nested collections
var sentences = new[] { &quot;Hello world&quot;, &quot;LINQ is powerful&quot; };
var words = sentences.SelectMany(s =&gt; s.Split(' '));
</code></pre>
<p><strong>3. Ordering Operators</strong></p>
<pre><code class="language-csharp">var products = new[]
{
    new { Name = &quot;Laptop&quot;, Price = 1200 },
    new { Name = &quot;Mouse&quot;, Price = 25 },
    new { Name = &quot;Keyboard&quot;, Price = 80 }
};

// OrderBy - ascending order
var byPrice = products.OrderBy(p =&gt; p.Price);

// OrderByDescending - descending order
var byPriceDesc = products.OrderByDescending(p =&gt; p.Price);

// ThenBy - secondary sorting
var sorted = products.OrderBy(p =&gt; p.Name).ThenBy(p =&gt; p.Price);

// Reverse - reverses order
var reversed = products.Reverse();
</code></pre>
<p><strong>4. Grouping Operators</strong></p>
<pre><code class="language-csharp">var students = new[]
{
    new { Name = &quot;John&quot;, Grade = &quot;A&quot;, Subject = &quot;Math&quot; },
    new { Name = &quot;Jane&quot;, Grade = &quot;B&quot;, Subject = &quot;Math&quot; },
    new { Name = &quot;Bob&quot;, Grade = &quot;A&quot;, Subject = &quot;Science&quot; }
};

// GroupBy - groups elements by key
var byGrade = students.GroupBy(s =&gt; s.Grade);
foreach (var group in byGrade)
{
    Console.WriteLine($&quot;Grade {group.Key}:&quot;);
    foreach (var student in group)
    {
        Console.WriteLine($&quot;  {student.Name}&quot;);
    }
}
</code></pre>
<p><strong>5. Aggregation Operators</strong></p>
<pre><code class="language-csharp">var scores = new[] { 85, 92, 78, 96, 88 };

// Count - number of elements
int totalCount = scores.Count();
int highScores = scores.Count(s =&gt; s &gt; 90);

// Sum, Average, Min, Max
int total = scores.Sum();
double average = scores.Average();
int minimum = scores.Min();
int maximum = scores.Max();

// Aggregate - custom aggregation
int product = scores.Aggregate((a, b) =&gt; a * b);
</code></pre>
<p><strong>6. Set Operators</strong></p>
<pre><code class="language-csharp">var list1 = new[] { 1, 2, 3, 4, 5 };
var list2 = new[] { 4, 5, 6, 7, 8 };

// Distinct - removes duplicates
var duplicates = new[] { 1, 2, 2, 3, 3, 4 };
var unique = duplicates.Distinct();

// Union - combines and removes duplicates
var union = list1.Union(list2);

// Intersect - common elements
var common = list1.Intersect(list2);

// Except - elements in first but not in second
var difference = list1.Except(list2);
</code></pre>
<p><strong>7. Element Operators</strong></p>
<pre><code class="language-csharp">var numbers = new[] { 1, 2, 3, 4, 5 };

// First, FirstOrDefault
int first = numbers.First();
int firstEven = numbers.First(n =&gt; n % 2 == 0);
int firstOrDefault = numbers.FirstOrDefault(n =&gt; n &gt; 10); // returns 0

// Last, LastOrDefault
int last = numbers.Last();

// Single, SingleOrDefault - exactly one element
var singleNumbers = new[] { 42 };
int single = singleNumbers.Single();

// ElementAt
int thirdElement = numbers.ElementAt(2); // zero-based index
</code></pre>
<p><strong>8. Quantifier Operators</strong></p>
<pre><code class="language-csharp">var numbers = new[] { 2, 4, 6, 8, 10 };

// All - checks if all elements satisfy condition
bool allEven = numbers.All(n =&gt; n % 2 == 0); // true

// Any - checks if any element satisfies condition
bool hasLarge = numbers.Any(n =&gt; n &gt; 5); // true

// Contains - checks if collection contains element
bool containsFive = numbers.Contains(5); // false
</code></pre>
<p><strong>9. Join Operators</strong></p>
<pre><code class="language-csharp">var customers = new[]
{
    new { Id = 1, Name = &quot;John&quot; },
    new { Id = 2, Name = &quot;Jane&quot; }
};

var orders = new[]
{
    new { CustomerId = 1, Product = &quot;Laptop&quot; },
    new { CustomerId = 1, Product = &quot;Mouse&quot; },
    new { CustomerId = 2, Product = &quot;Keyboard&quot; }
};

// Join - inner join
var customerOrders = customers.Join(
    orders,
    customer =&gt; customer.Id,
    order =&gt; order.CustomerId,
    (customer, order) =&gt; new { customer.Name, order.Product }
);

// GroupJoin - left outer join
var customerOrderGroups = customers.GroupJoin(
    orders,
    customer =&gt; customer.Id,
    order =&gt; order.CustomerId,
    (customer, orderGroup) =&gt; new { customer.Name, Orders = orderGroup }
);
</code></pre>
<h3 id="question-4-why-serialization-is-required-write-a-program-to-write-user-input-into-file-and-display-file-content-using-stream">Question 4: Why serialization is required? Write a program to write user input into file and display file content using stream.</h3>
<h4 id="why-serialization-is-required">Why Serialization is Required</h4>
<p><strong>Serialization</strong> is the process of converting an object into a format that can be stored or transmitted, and later reconstructed. It's required for:</p>
<ol>
<li><strong>Data Persistence</strong>: Store object state to disk, database, or other storage</li>
<li><strong>Network Communication</strong>: Send objects between applications over network</li>
<li><strong>Caching</strong>: Store objects in memory or external cache systems</li>
<li><strong>Deep Copying</strong>: Create exact copies of complex objects</li>
<li><strong>Interoperability</strong>: Exchange data between different platforms/languages</li>
<li><strong>State Management</strong>: Save and restore application state</li>
</ol>
<p><strong>Types of Serialization:</strong></p>
<ul>
<li><strong>Binary Serialization</strong>: Compact, fast, .NET specific</li>
<li><strong>XML Serialization</strong>: Human-readable, cross-platform</li>
<li><strong>JSON Serialization</strong>: Lightweight, web-friendly, cross-platform</li>
</ul>
<h4 id="file-io-program-with-streams">File I/O Program with Streams</h4>
<pre><code class="language-csharp">using System;
using System.IO;
using System.Text;
using System.Text.Json;

// Class to demonstrate serialization
[Serializable]
public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Department { get; set; }
    public decimal Salary { get; set; }
    public DateTime JoiningDate { get; set; }

    public override string ToString()
    {
        return $&quot;ID: {Id}, Name: {Name}, Department: {Department}, Salary: {Salary:C}, Joining: {JoiningDate:yyyy-MM-dd}&quot;;
    }
}

public class FileOperationsProgram
{
    private const string TextFileName = &quot;employee_data.txt&quot;;
    private const string JsonFileName = &quot;employee_data.json&quot;;

    public static void Main()
    {
        Console.WriteLine(&quot;=== File Operations with Streams Demo ===\n&quot;);

        // Get user input
        Employee employee = GetEmployeeFromUser();

        // Demonstrate different file operations
        WriteToTextFile(employee);
        ReadFromTextFile();

        WriteToJsonFile(employee);
        ReadFromJsonFile();

        // Stream operations demonstration
        DemonstrateStreamOperations();

        Console.WriteLine(&quot;\nPress any key to exit...&quot;);
        Console.ReadKey();
    }

    // Get employee data from user input
    private static Employee GetEmployeeFromUser()
    {
        Console.WriteLine(&quot;Enter Employee Details:&quot;);

        Console.Write(&quot;ID: &quot;);
        int id = int.Parse(Console.ReadLine());

        Console.Write(&quot;Name: &quot;);
        string name = Console.ReadLine();

        Console.Write(&quot;Department: &quot;);
        string department = Console.ReadLine();

        Console.Write(&quot;Salary: &quot;);
        decimal salary = decimal.Parse(Console.ReadLine());

        Console.Write(&quot;Joining Date (yyyy-mm-dd): &quot;);
        DateTime joiningDate = DateTime.Parse(Console.ReadLine());

        return new Employee
        {
            Id = id,
            Name = name,
            Department = department,
            Salary = salary,
            JoiningDate = joiningDate
        };
    }

    // Write to text file using StreamWriter
    private static void WriteToTextFile(Employee employee)
    {
        try
        {
            using (FileStream fileStream = new FileStream(TextFileName, FileMode.Create))
            using (StreamWriter writer = new StreamWriter(fileStream, Encoding.UTF8))
            {
                writer.WriteLine(&quot;=== Employee Information ===&quot;);
                writer.WriteLine($&quot;ID: {employee.Id}&quot;);
                writer.WriteLine($&quot;Name: {employee.Name}&quot;);
                writer.WriteLine($&quot;Department: {employee.Department}&quot;);
                writer.WriteLine($&quot;Salary: {employee.Salary:C}&quot;);
                writer.WriteLine($&quot;Joining Date: {employee.JoiningDate:yyyy-MM-dd}&quot;);
                writer.WriteLine($&quot;File Created: {DateTime.Now}&quot;);
            }

            Console.WriteLine($&quot;\nâœ“ Employee data written to {TextFileName}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error writing to file: {ex.Message}&quot;);
        }
    }

    // Read from text file using StreamReader
    private static void ReadFromTextFile()
    {
        try
        {
            using (FileStream fileStream = new FileStream(TextFileName, FileMode.Open))
            using (StreamReader reader = new StreamReader(fileStream, Encoding.UTF8))
            {
                Console.WriteLine($&quot;\n=== Contents of {TextFileName} ===&quot;);
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    Console.WriteLine(line);
                }
            }
        }
        catch (FileNotFoundException)
        {
            Console.WriteLine($&quot;File {TextFileName} not found.&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error reading file: {ex.Message}&quot;);
        }
    }

    // Write to JSON file (serialization)
    private static void WriteToJsonFile(Employee employee)
    {
        try
        {
            using (FileStream fileStream = new FileStream(JsonFileName, FileMode.Create))
            {
                JsonSerializer.Serialize(fileStream, employee, new JsonSerializerOptions
                {
                    WriteIndented = true // Pretty formatting
                });
            }

            Console.WriteLine($&quot;\nâœ“ Employee data serialized to {JsonFileName}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error serializing to JSON: {ex.Message}&quot;);
        }
    }

    // Read from JSON file (deserialization)
    private static void ReadFromJsonFile()
    {
        try
        {
            using (FileStream fileStream = new FileStream(JsonFileName, FileMode.Open))
            {
                Employee deserializedEmployee = JsonSerializer.Deserialize&lt;Employee&gt;(fileStream);

                Console.WriteLine($&quot;\n=== Deserialized from {JsonFileName} ===&quot;);
                Console.WriteLine(deserializedEmployee.ToString());
            }
        }
        catch (FileNotFoundException)
        {
            Console.WriteLine($&quot;File {JsonFileName} not found.&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error deserializing JSON: {ex.Message}&quot;);
        }
    }

    // Demonstrate various stream operations
    private static void DemonstrateStreamOperations()
    {
        Console.WriteLine(&quot;\n=== Stream Operations Demo ===&quot;);

        string demoFileName = &quot;stream_demo.txt&quot;;

        try
        {
            // Write using different methods
            using (FileStream fs = new FileStream(demoFileName, FileMode.Create))
            {
                // Write bytes directly
                byte[] data = Encoding.UTF8.GetBytes(&quot;Hello from FileStream!\n&quot;);
                fs.Write(data, 0, data.Length);

                // Write using StreamWriter
                using (StreamWriter sw = new StreamWriter(fs, Encoding.UTF8, 1024, true))
                {
                    sw.WriteLine(&quot;Hello from StreamWriter!&quot;);
                    sw.WriteLine($&quot;Current time: {DateTime.Now}&quot;);
                    sw.Flush(); // Ensure data is written
                }
            }

            // Read using different methods
            using (FileStream fs = new FileStream(demoFileName, FileMode.Open))
            {
                Console.WriteLine(&quot;File size: &quot; + fs.Length + &quot; bytes&quot;);

                // Read all bytes
                byte[] buffer = new byte[fs.Length];
                fs.Read(buffer, 0, buffer.Length);
                string content = Encoding.UTF8.GetString(buffer);

                Console.WriteLine(&quot;File contents:&quot;);
                Console.WriteLine(content);
            }

            // Memory stream example
            using (MemoryStream ms = new MemoryStream())
            {
                string text = &quot;Hello Memory Stream!&quot;;
                byte[] bytes = Encoding.UTF8.GetBytes(text);
                ms.Write(bytes, 0, bytes.Length);

                ms.Position = 0; // Reset position to beginning

                using (StreamReader sr = new StreamReader(ms))
                {
                    string result = sr.ReadToEnd();
                    Console.WriteLine($&quot;From MemoryStream: {result}&quot;);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Stream operation error: {ex.Message}&quot;);
        }
        finally
        {
            // Cleanup
            if (File.Exists(demoFileName))
                File.Delete(demoFileName);
        }
    }
}
</code></pre>
<h4 id="advanced-stream-example-with-custom-serialization">Advanced Stream Example with Custom Serialization</h4>
<pre><code class="language-csharp">public class CustomSerializationExample
{
    public static void BinarySerializationDemo()
    {
        var employees = new List&lt;Employee&gt;
        {
            new Employee { Id = 1, Name = &quot;John Doe&quot;, Department = &quot;IT&quot;, Salary = 50000, JoiningDate = DateTime.Now.AddYears(-2) },
            new Employee { Id = 2, Name = &quot;Jane Smith&quot;, Department = &quot;HR&quot;, Salary = 45000, JoiningDate = DateTime.Now.AddYears(-1) }
        };

        string fileName = &quot;employees.dat&quot;;

        // Write binary data
        using (FileStream fs = new FileStream(fileName, FileMode.Create))
        using (BinaryWriter writer = new BinaryWriter(fs))
        {
            writer.Write(employees.Count);

            foreach (var emp in employees)
            {
                writer.Write(emp.Id);
                writer.Write(emp.Name);
                writer.Write(emp.Department);
                writer.Write(emp.Salary);
                writer.Write(emp.JoiningDate.ToBinary());
            }
        }

        // Read binary data
        using (FileStream fs = new FileStream(fileName, FileMode.Open))
        using (BinaryReader reader = new BinaryReader(fs))
        {
            int count = reader.ReadInt32();

            for (int i = 0; i &lt; count; i++)
            {
                var emp = new Employee
                {
                    Id = reader.ReadInt32(),
                    Name = reader.ReadString(),
                    Department = reader.ReadString(),
                    Salary = reader.ReadDecimal(),
                    JoiningDate = DateTime.FromBinary(reader.ReadInt64())
                };

                Console.WriteLine(emp.ToString());
            }
        }
    }
}
</code></pre>
<h3 id="question-5-differentiate-connected-architecture-of-ado.net-from-disconnected-architecture-of-ado.net.write-a-c-program-to-connect-to-database-and-insert-five-employee-records-and-delete-employee-records-whose-salary-is-less-than-rs-10000">Question 5: Differentiate connected architecture of ADO.NET from disconnected architecture of ADO.NET. Write a C# program to connect to database and insert five employee records and delete employee records whose salary is less than Rs 10000.</h3>
<h4 id="connected-vs-disconnected-architecture">Connected vs Disconnected Architecture</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Connected Architecture</th>
<th>Disconnected Architecture</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Connection</strong></td>
<td>Maintains active connection</td>
<td>Works with disconnected data</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Faster for single operations</td>
<td>Better for multiple operations</td>
</tr>
<tr>
<td><strong>Memory Usage</strong></td>
<td>Less memory usage</td>
<td>More memory usage</td>
</tr>
<tr>
<td><strong>Concurrency</strong></td>
<td>Limited concurrent users</td>
<td>Supports many concurrent users</td>
</tr>
<tr>
<td><strong>Network Traffic</strong></td>
<td>Continuous network usage</td>
<td>Minimal network usage</td>
</tr>
<tr>
<td><strong>Offline Support</strong></td>
<td>No offline capability</td>
<td>Full offline support</td>
</tr>
<tr>
<td><strong>Data Modification</strong></td>
<td>Direct database updates</td>
<td>Batch updates possible</td>
</tr>
<tr>
<td><strong>Primary Classes</strong></td>
<td>SqlConnection, SqlCommand, SqlDataReader</td>
<td>DataSet, DataTable, SqlDataAdapter</td>
</tr>
<tr>
<td><strong>Use Case</strong></td>
<td>Simple read operations, real-time data</td>
<td>Complex operations, data manipulation</td>
</tr>
</tbody>
</table>
<h4 id="database-program-implementation">Database Program Implementation</h4>
<pre><code class="language-csharp">using System;
using System.Data;
using System.Data.SqlClient;
using System.Configuration;

public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string JobTitle { get; set; }
    public string Address { get; set; }
    public float Salary { get; set; }
    public DateTime JoiningDate { get; set; }
}

public class EmployeeDataAccess
{
    // Connection string - update with your SQL Server details
    private string connectionString = @&quot;Server=localhost;Database=Empinfo;Integrated Security=true;TrustServerCertificate=true;&quot;;

    // Alternative connection string for SQL Server Authentication
    // private string connectionString = @&quot;Server=localhost;Database=Empinfo;User Id=sa;Password=yourpassword;TrustServerCertificate=true;&quot;;

    public static void Main()
    {
        var dataAccess = new EmployeeDataAccess();

        try
        {
            // Create database and table if they don't exist
            dataAccess.CreateDatabaseAndTable();

            // Insert five employee records
            dataAccess.InsertEmployeeRecords();

            // Display all employees before deletion
            Console.WriteLine(&quot;=== All Employees Before Deletion ===&quot;);
            dataAccess.DisplayAllEmployees();

            // Delete employees with salary less than 10000
            int deletedCount = dataAccess.DeleteLowSalaryEmployees();
            Console.WriteLine($&quot;\n{deletedCount} employee(s) deleted with salary less than Rs. 10000&quot;);

            // Display remaining employees
            Console.WriteLine(&quot;\n=== Remaining Employees After Deletion ===&quot;);
            dataAccess.DisplayAllEmployees();
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }

        Console.WriteLine(&quot;\nPress any key to exit...&quot;);
        Console.ReadKey();
    }

    // Create database and table
    private void CreateDatabaseAndTable()
    {
        string masterConnectionString = connectionString.Replace(&quot;Database=Empinfo&quot;, &quot;Database=master&quot;);

        // Create database
        using (SqlConnection connection = new SqlConnection(masterConnectionString))
        {
            connection.Open();

            string createDbQuery = @&quot;
                IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = 'Empinfo')
                CREATE DATABASE Empinfo&quot;;

            using (SqlCommand command = new SqlCommand(createDbQuery, connection))
            {
                command.ExecuteNonQuery();
                Console.WriteLine(&quot;Database 'Empinfo' created or already exists.&quot;);
            }
        }

        // Create table
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            string createTableQuery = @&quot;
                IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Employee]') AND type in (N'U'))
                CREATE TABLE Employee (
                    Id INT PRIMARY KEY IDENTITY(1,1),
                    Name NVARCHAR(50) NOT NULL,
                    JobTitle NVARCHAR(50) NOT NULL,
                    Address NVARCHAR(50) NOT NULL,
                    Salary FLOAT NOT NULL,
                    JoiningDate DATETIME NOT NULL
                )&quot;;

            using (SqlCommand command = new SqlCommand(createTableQuery, connection))
            {
                command.ExecuteNonQuery();
                Console.WriteLine(&quot;Table 'Employee' created or already exists.&quot;);
            }
        }
    }

    // Connected Architecture - Insert Employee Records
    private void InsertEmployeeRecords()
    {
        var employees = new[]
        {
            new Employee { Name = &quot;John Doe&quot;, JobTitle = &quot;Software Developer&quot;, Address = &quot;123 Main St, City A&quot;, Salary = 55000, JoiningDate = DateTime.Now.AddYears(-2) },
            new Employee { Name = &quot;Jane Smith&quot;, JobTitle = &quot;Project Manager&quot;, Address = &quot;456 Oak Ave, City B&quot;, Salary = 75000, JoiningDate = DateTime.Now.AddYears(-3) },
            new Employee { Name = &quot;Mike Johnson&quot;, JobTitle = &quot;Junior Developer&quot;, Address = &quot;789 Pine Rd, City C&quot;, Salary = 8000, JoiningDate = DateTime.Now.AddMonths(-6) },
            new Employee { Name = &quot;Sarah Wilson&quot;, JobTitle = &quot;Senior Developer&quot;, Address = &quot;321 Elm St, City D&quot;, Salary = 85000, JoiningDate = DateTime.Now.AddYears(-4) },
            new Employee { Name = &quot;Tom Brown&quot;, JobTitle = &quot;Intern&quot;, Address = &quot;654 Maple Dr, City E&quot;, Salary = 5000, JoiningDate = DateTime.Now.AddMonths(-3) }
        };

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Clear existing data for demo
            string clearQuery = &quot;DELETE FROM Employee&quot;;
            using (SqlCommand clearCommand = new SqlCommand(clearQuery, connection))
            {
                clearCommand.ExecuteNonQuery();
            }

            // Insert new records
            string insertQuery = @&quot;
                INSERT INTO Employee (Name, JobTitle, Address, Salary, JoiningDate)
                VALUES (@Name, @JobTitle, @Address, @Salary, @JoiningDate)&quot;;

            foreach (var employee in employees)
            {
                using (SqlCommand command = new SqlCommand(insertQuery, connection))
                {
                    // Using parameters to prevent SQL injection
                    command.Parameters.AddWithValue(&quot;@Name&quot;, employee.Name);
                    command.Parameters.AddWithValue(&quot;@JobTitle&quot;, employee.JobTitle);
                    command.Parameters.AddWithValue(&quot;@Address&quot;, employee.Address);
                    command.Parameters.AddWithValue(&quot;@Salary&quot;, employee.Salary);
                    command.Parameters.AddWithValue(&quot;@JoiningDate&quot;, employee.JoiningDate);

                    int rowsAffected = command.ExecuteNonQuery();
                    if (rowsAffected &gt; 0)
                    {
                        Console.WriteLine($&quot;Inserted: {employee.Name}&quot;);
                    }
                }
            }

            Console.WriteLine(&quot;\nAll employee records inserted successfully!&quot;);
        }
    }

    // Connected Architecture - Display All Employees using DataReader
    private void DisplayAllEmployees()
    {
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            string selectQuery = &quot;SELECT Id, Name, JobTitle, Address, Salary, JoiningDate FROM Employee ORDER BY Id&quot;;

            using (SqlCommand command = new SqlCommand(selectQuery, connection))
            using (SqlDataReader reader = command.ExecuteReader())
            {
                Console.WriteLine($&quot;{&quot;ID&quot;,-5} {&quot;Name&quot;,-15} {&quot;Job Title&quot;,-20} {&quot;Address&quot;,-25} {&quot;Salary&quot;,-10} {&quot;Joining Date&quot;,-12}&quot;);
                Console.WriteLine(new string('-', 95));

                while (reader.Read())
                {
                    Console.WriteLine($&quot;{reader[&quot;Id&quot;],-5} &quot; +
                                    $&quot;{reader[&quot;Name&quot;],-15} &quot; +
                                    $&quot;{reader[&quot;JobTitle&quot;],-20} &quot; +
                                    $&quot;{reader[&quot;Address&quot;],-25} &quot; +
                                    $&quot;{reader[&quot;Salary&quot;],-10:F0} &quot; +
                                    $&quot;{((DateTime)reader[&quot;JoiningDate&quot;]).ToString(&quot;yyyy-MM-dd&quot;),-12}&quot;);
                }
            }
        }
    }

    // Connected Architecture - Delete Low Salary Employees
    private int DeleteLowSalaryEmployees()
    {
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            string deleteQuery = &quot;DELETE FROM Employee WHERE Salary &lt; @MinSalary&quot;;

            using (SqlCommand command = new SqlCommand(deleteQuery, connection))
            {
                command.Parameters.AddWithValue(&quot;@MinSalary&quot;, 10000);

                int rowsDeleted = command.ExecuteNonQuery();
                return rowsDeleted;
            }
        }
    }
}

// Disconnected Architecture Example
public class DisconnectedEmployeeDataAccess
{
    private string connectionString = @&quot;Server=localhost;Database=Empinfo;Integrated Security=true;TrustServerCertificate=true;&quot;;

    // Disconnected Architecture - Using DataSet and DataAdapter
    public void DisconnectedOperationsDemo()
    {
        DataSet employeeDataSet = new DataSet(&quot;EmployeeData&quot;);

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            // Create DataAdapter
            string selectQuery = &quot;SELECT Id, Name, JobTitle, Address, Salary, JoiningDate FROM Employee&quot;;
            SqlDataAdapter adapter = new SqlDataAdapter(selectQuery, connection);

            // Configure command builders for automatic INSERT, UPDATE, DELETE commands
            SqlCommandBuilder commandBuilder = new SqlCommandBuilder(adapter);

            // Fill DataSet (connection opens and closes automatically)
            adapter.Fill(employeeDataSet, &quot;Employees&quot;);

            // Work with data offline
            DataTable employeeTable = employeeDataSet.Tables[&quot;Employees&quot;];

            Console.WriteLine(&quot;=== Working with Disconnected Data ===&quot;);
            Console.WriteLine($&quot;Loaded {employeeTable.Rows.Count} employees into DataSet&quot;);

            // Modify data in memory
            foreach (DataRow row in employeeTable.Rows)
            {
                if ((double)row[&quot;Salary&quot;] &lt; 50000)
                {
                    row[&quot;Salary&quot;] = (double)row[&quot;Salary&quot;] * 1.1; // 10% raise
                    Console.WriteLine($&quot;Increased salary for {row[&quot;Name&quot;]}&quot;);
                }
            }

            // Add new employee
            DataRow newRow = employeeTable.NewRow();
            newRow[&quot;Name&quot;] = &quot;Alice Cooper&quot;;
            newRow[&quot;JobTitle&quot;] = &quot;Data Analyst&quot;;
            newRow[&quot;Address&quot;] = &quot;999 Data St, City F&quot;;
            newRow[&quot;Salary&quot;] = 60000;
            newRow[&quot;JoiningDate&quot;] = DateTime.Now;
            employeeTable.Rows.Add(newRow);

            // Update database with all changes in one batch
            try
            {
                int updatedRows = adapter.Update(employeeDataSet, &quot;Employees&quot;);
                Console.WriteLine($&quot;Updated {updatedRows} rows in database&quot;);
            }
            catch (Exception ex)
            {
                Console.WriteLine($&quot;Update failed: {ex.Message}&quot;);
            }
        }
    }
}
</code></pre>
<h3 id="question-6-write-a-short-note-on-the-following">Question 6: Write a short note on the following</h3>
<h4 id="a.sealed-class-and-sealed-method">a. Sealed Class and Sealed Method</h4>
<p><strong>Sealed Class:</strong>
A sealed class is a class that cannot be inherited by other classes. It prevents further derivation and is used when you want to restrict the inheritance hierarchy.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Cannot be used as a base class</li>
<li>All members are implicitly sealed</li>
<li>Can inherit from other classes but cannot be inherited</li>
<li>Provides performance benefits (no virtual method lookups)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">// Sealed class example
public sealed class MathUtility
{
    public static double CalculateCircleArea(double radius)
    {
        return Math.PI * radius * radius;
    }

    public static double CalculateRectangleArea(double length, double width)
    {
        return length * width;
    }
}

// This would cause compilation error:
// public class ExtendedMath : MathUtility { } // Error: Cannot inherit from sealed class

// Real-world example: String class is sealed
public void StringExample()
{
    string text = &quot;Hello&quot;; // String is sealed, cannot be inherited
}
</code></pre>
<p><strong>Sealed Method:</strong>
A sealed method is used in derived classes to prevent further overriding of a virtual method in subsequent derived classes.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Must be used with override keyword</li>
<li>Prevents further overriding in derived classes</li>
<li>Can only be applied to virtual or abstract methods</li>
<li>Maintains the inheritance chain but stops further overriding</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">// Base class with virtual method
public class Vehicle
{
    public virtual void Start()
    {
        Console.WriteLine(&quot;Vehicle starting...&quot;);
    }
}

// Derived class that seals the method
public class Car : Vehicle
{
    public sealed override void Start()
    {
        Console.WriteLine(&quot;Car engine starting...&quot;);
    }
}

// Further derived class cannot override the sealed method
public class SportsCar : Car
{
    // This would cause compilation error:
    // public override void Start() { } // Error: Cannot override sealed method

    // But can create new method with same name (method hiding)
    public new void Start()
    {
        Console.WriteLine(&quot;Sports car turbo engine starting...&quot;);
    }
}

// Usage example
public void SealedMethodDemo()
{
    Vehicle vehicle = new SportsCar();
    vehicle.Start(); // Calls Car's sealed Start method

    SportsCar sports = new SportsCar();
    sports.Start(); // Calls SportsCar's new Start method (hiding)
}
</code></pre>
<p><strong>Practical Use Cases:</strong></p>
<pre><code class="language-csharp">// Security-sensitive class
public sealed class CryptoHelper
{
    public static string EncryptPassword(string password)
    {
        // Secure encryption logic
        return Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(password));
    }
}

// Performance-critical class
public sealed class FastCalculator
{
    public double Calculate(double x, double y)
    {
        // No virtual method overhead
        return x * y + Math.Sin(x);
    }
}
</code></pre>
<h4 id="b.ajax-asynchronous-javascript-and-xml">b. AJAX (Asynchronous JavaScript and XML)</h4>
<p><strong>AJAX</strong> is a web development technique that allows web pages to update content dynamically without requiring a full page reload. It enables asynchronous communication between the client and server.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><strong>Asynchronous</strong>: Operations don't block the user interface</li>
<li><strong>Partial Updates</strong>: Only specific parts of the page are updated</li>
<li><strong>Better User Experience</strong>: Faster, more responsive web applications</li>
<li><strong>Reduced Server Load</strong>: Less data transfer and processing</li>
</ul>
<p><strong>Core Technologies:</strong></p>
<ol>
<li><strong>JavaScript</strong>: Controls the AJAX behavior</li>
<li><strong>XMLHttpRequest</strong>: Browser API for making HTTP requests</li>
<li><strong>DOM</strong>: Manipulates page content dynamically</li>
<li><strong>CSS</strong>: Styles the dynamic content</li>
<li><strong>Server-side</strong>: Processes requests and returns data (often JSON)</li>
</ol>
<p><strong>AJAX in ASP.NET Core Example:</strong></p>
<p><strong>Controller (C#):</strong></p>
<pre><code class="language-csharp">[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class EmployeeController : ControllerBase
{
    [HttpGet]
    public IActionResult GetEmployees()
    {
        var employees = new[]
        {
            new { Id = 1, Name = &quot;John Doe&quot;, Department = &quot;IT&quot; },
            new { Id = 2, Name = &quot;Jane Smith&quot;, Department = &quot;HR&quot; },
            new { Id = 3, Name = &quot;Mike Johnson&quot;, Department = &quot;Finance&quot; }
        };

        return Ok(employees);
    }

    [HttpPost]
    public IActionResult AddEmployee([FromBody] Employee employee)
    {
        // Add employee logic here
        return Ok(new { Message = &quot;Employee added successfully&quot;, Id = employee.Id });
    }

    [HttpDelete(&quot;{id}&quot;)]
    public IActionResult DeleteEmployee(int id)
    {
        // Delete employee logic here
        return Ok(new { Message = $&quot;Employee {id} deleted successfully&quot; });
    }
}
</code></pre>
<p><strong>JavaScript (Client-side):</strong></p>
<pre><code class="language-javascript">// Fetch employees using AJAX
function loadEmployees() {
    fetch('/api/employee')
        .then(response =&gt; response.json())
        .then(data =&gt; {
            const tableBody = document.getElementById('employeeTableBody');
            tableBody.innerHTML = '';

            data.forEach(employee =&gt; {
                const row = `
                    &lt;tr&gt;
                        &lt;td&gt;${employee.id}&lt;/td&gt;
                        &lt;td&gt;${employee.name}&lt;/td&gt;
                        &lt;td&gt;${employee.department}&lt;/td&gt;
                        &lt;td&gt;
                            &lt;button onclick=&quot;deleteEmployee(${employee.id})&quot;&gt;Delete&lt;/button&gt;
                        &lt;/td&gt;
                    &lt;/tr&gt;
                `;
                tableBody.innerHTML += row;
            });
        })
        .catch(error =&gt; {
            console.error('Error loading employees:', error);
            alert('Failed to load employees');
        });
}

// Add employee using AJAX
function addEmployee() {
    const employeeData = {
        name: document.getElementById('employeeName').value,
        department: document.getElementById('employeeDepartment').value
    };

    fetch('/api/employee', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(employeeData)
    })
    .then(response =&gt; response.json())
    .then(data =&gt; {
        alert(data.message);
        loadEmployees(); // Refresh the list
        clearForm();
    })
    .catch(error =&gt; {
        console.error('Error adding employee:', error);
        alert('Failed to add employee');
    });
}

// Delete employee using AJAX
function deleteEmployee(id) {
    if (confirm('Are you sure you want to delete this employee?')) {
        fetch(`/api/employee/${id}`, {
            method: 'DELETE'
        })
        .then(response =&gt; response.json())
        .then(data =&gt; {
            alert(data.message);
            loadEmployees(); // Refresh the list
        })
        .catch(error =&gt; {
            console.error('Error deleting employee:', error);
            alert('Failed to delete employee');
        });
    }
}

// Load employees when page loads
document.addEventListener('DOMContentLoaded', function() {
    loadEmployees();
});
</code></pre>
<p><strong>HTML:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;AJAX Employee Management&lt;/title&gt;
    &lt;style&gt;
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .form-container { margin-bottom: 20px; }
        .form-container input, .form-container button { margin: 5px; padding: 5px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Employee Management with AJAX&lt;/h1&gt;

    &lt;div class=&quot;form-container&quot;&gt;
        &lt;h3&gt;Add New Employee&lt;/h3&gt;
        &lt;input type=&quot;text&quot; id=&quot;employeeName&quot; placeholder=&quot;Employee Name&quot; /&gt;
        &lt;input type=&quot;text&quot; id=&quot;employeeDepartment&quot; placeholder=&quot;Department&quot; /&gt;
        &lt;button onclick=&quot;addEmployee()&quot;&gt;Add Employee&lt;/button&gt;
    &lt;/div&gt;

    &lt;h3&gt;Employee List&lt;/h3&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;ID&lt;/th&gt;
                &lt;th&gt;Name&lt;/th&gt;
                &lt;th&gt;Department&lt;/th&gt;
                &lt;th&gt;Actions&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody id=&quot;employeeTableBody&quot;&gt;
            &lt;!-- Employee data will be loaded here via AJAX --&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;script src=&quot;employee-ajax.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>jQuery AJAX Alternative:</strong></p>
<pre><code class="language-javascript">// Using jQuery for AJAX operations
$(document).ready(function() {
    loadEmployees();
});

function loadEmployees() {
    $.ajax({
        url: '/api/employee',
        type: 'GET',
        dataType: 'json',
        success: function(data) {
            var html = '';
            $.each(data, function(index, employee) {
                html += '&lt;tr&gt;';
                html += '&lt;td&gt;' + employee.id + '&lt;/td&gt;';
                html += '&lt;td&gt;' + employee.name + '&lt;/td&gt;';
                html += '&lt;td&gt;' + employee.department + '&lt;/td&gt;';
                html += '&lt;td&gt;&lt;button onclick=&quot;deleteEmployee(' + employee.id + ')&quot;&gt;Delete&lt;/button&gt;&lt;/td&gt;';
                html += '&lt;/tr&gt;';
            });
            $('#employeeTableBody').html(html);
        },
        error: function() {
            alert('Failed to load employees');
        }
    });
}

function addEmployee() {
    var employeeData = {
        name: $('#employeeName').val(),
        department: $('#employeeDepartment').val()
    };

    $.ajax({
        url: '/api/employee',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(employeeData),
        success: function(data) {
            alert(data.message);
            loadEmployees();
            $('#employeeName').val('');
            $('#employeeDepartment').val('');
        },
        error: function() {
            alert('Failed to add employee');
        }
    });
}
</code></pre>
<p><strong>Benefits of AJAX:</strong></p>
<ul>
<li><strong>Improved User Experience</strong>: No page reloads, faster interactions</li>
<li><strong>Reduced Bandwidth</strong>: Only necessary data is transferred</li>
<li><strong>Better Performance</strong>: Less server processing and faster response</li>
<li><strong>Dynamic Content</strong>: Real-time updates without page refresh</li>
<li><strong>Asynchronous Processing</strong>: Non-blocking operations</li>
</ul>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li>Form validation and submission</li>
<li>Auto-complete and search suggestions</li>
<li>Loading data dynamically (infinite scroll)</li>
<li>Real-time notifications and updates</li>
<li>Single Page Applications (SPAs)</li>
</ul>
<hr />
<h2 id="additional-exam-questions-and-answers">Additional Exam Questions and Answers</h2>
<h3 id="question-1-what-is-the-difference-between-for-loop-and-foreach-loop-explain-with-example-in-c">Question 1: What is the difference between 'for loop' and 'foreach loop'? Explain with Example in C#.</h3>
<h4 id="differences">Differences:</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>for loop</th>
<th>foreach loop</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Purpose</strong></td>
<td>General-purpose iteration with index control</td>
<td>Iterating through collections</td>
</tr>
<tr>
<td><strong>Index Access</strong></td>
<td>Provides index access</td>
<td>No direct index access</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Slightly faster for arrays</td>
<td>Optimized for collections</td>
</tr>
<tr>
<td><strong>Flexibility</strong></td>
<td>Can modify iteration pattern</td>
<td>Fixed iteration pattern</td>
</tr>
<tr>
<td><strong>Collection Modification</strong></td>
<td>Can modify collection during iteration</td>
<td>Cannot modify collection during iteration</td>
</tr>
</tbody>
</table>
<h4 id="examples">Examples:</h4>
<pre><code class="language-csharp">public class LoopComparison
{
    public static void ForLoopExample()
    {
        int[] numbers = { 1, 2, 3, 4, 5 };

        // for loop - provides index access
        Console.WriteLine(&quot;For loop:&quot;);
        for (int i = 0; i &lt; numbers.Length; i++)
        {
            Console.WriteLine($&quot;Index {i}: {numbers[i]}&quot;);
            // Can modify array elements
            numbers[i] *= 2;
        }

        // Can iterate backwards
        Console.WriteLine(&quot;\nBackward iteration:&quot;);
        for (int i = numbers.Length - 1; i &gt;= 0; i--)
        {
            Console.WriteLine($&quot;Index {i}: {numbers[i]}&quot;);
        }

        // Can skip elements
        Console.WriteLine(&quot;\nSkip every other element:&quot;);
        for (int i = 0; i &lt; numbers.Length; i += 2)
        {
            Console.WriteLine($&quot;Index {i}: {numbers[i]}&quot;);
        }
    }

    public static void ForEachLoopExample()
    {
        int[] numbers = { 10, 20, 30, 40, 50 };
        List&lt;string&gt; names = new List&lt;string&gt; { &quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot; };

        // foreach loop - simpler syntax for iteration
        Console.WriteLine(&quot;Foreach loop with array:&quot;);
        foreach (int number in numbers)
        {
            Console.WriteLine($&quot;Value: {number}&quot;);
            // Cannot modify 'number' variable to change array
        }

        // Works with any IEnumerable
        Console.WriteLine(&quot;\nForeach loop with List:&quot;);
        foreach (string name in names)
        {
            Console.WriteLine($&quot;Name: {name}&quot;);
        }

        // Works with Dictionary
        Dictionary&lt;string, int&gt; ages = new Dictionary&lt;string, int&gt;
        {
            [&quot;Alice&quot;] = 25,
            [&quot;Bob&quot;] = 30
        };

        Console.WriteLine(&quot;\nForeach loop with Dictionary:&quot;);
        foreach (KeyValuePair&lt;string, int&gt; kvp in ages)
        {
            Console.WriteLine($&quot;{kvp.Key}: {kvp.Value}&quot;);
        }
    }

    public static void PerformanceComparison()
    {
        int[] largeArray = new int[1000000];
        for (int i = 0; i &lt; largeArray.Length; i++)
        {
            largeArray[i] = i;
        }

        Stopwatch sw = new Stopwatch();

        // for loop timing
        sw.Start();
        long sum1 = 0;
        for (int i = 0; i &lt; largeArray.Length; i++)
        {
            sum1 += largeArray[i];
        }
        sw.Stop();
        long forTime = sw.ElapsedMilliseconds;

        // foreach loop timing
        sw.Restart();
        long sum2 = 0;
        foreach (int number in largeArray)
        {
            sum2 += number;
        }
        sw.Stop();
        long foreachTime = sw.ElapsedMilliseconds;

        Console.WriteLine($&quot;For loop time: {forTime}ms&quot;);
        Console.WriteLine($&quot;Foreach loop time: {foreachTime}ms&quot;);
    }
}
</code></pre>
<h3 id="question-2-what-is-linq-what-are-the-advantages-of-linq-explain-with-example">Question 2: What is LINQ? What are the advantages of LINQ? Explain with Example.</h3>
<h4 id="what-is-linq">What is LINQ?</h4>
<p>LINQ (Language Integrated Query) is a set of features that extends powerful query capabilities to the language syntax of C# and Visual Basic. It allows you to write queries directly in your programming language.</p>
<h4 id="advantages-of-linq">Advantages of LINQ:</h4>
<ol>
<li><strong>Type Safety</strong> - Compile-time checking</li>
<li><strong>IntelliSense Support</strong> - Auto-completion and syntax checking</li>
<li><strong>Unified Syntax</strong> - Same syntax for different data sources</li>
<li><strong>Deferred Execution</strong> - Queries execute when enumerated</li>
<li><strong>Readable Code</strong> - More intuitive than traditional loops</li>
</ol>
<h4 id="examples-1">Examples:</h4>
<pre><code class="language-csharp">public class LinqExamples
{
    public class Student
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public int Age { get; set; }
        public string Course { get; set; }
        public double Grade { get; set; }
    }

    public static void LinqBasics()
    {
        List&lt;Student&gt; students = new List&lt;Student&gt;
        {
            new Student { Id = 1, Name = &quot;Alice&quot;, Age = 20, Course = &quot;Computer Science&quot;, Grade = 85.5 },
            new Student { Id = 2, Name = &quot;Bob&quot;, Age = 22, Course = &quot;Mathematics&quot;, Grade = 92.0 },
            new Student { Id = 3, Name = &quot;Charlie&quot;, Age = 19, Course = &quot;Computer Science&quot;, Grade = 78.5 },
            new Student { Id = 4, Name = &quot;Diana&quot;, Age = 21, Course = &quot;Physics&quot;, Grade = 88.0 },
            new Student { Id = 5, Name = &quot;Eve&quot;, Age = 20, Course = &quot;Mathematics&quot;, Grade = 95.5 }
        };

        // Method Syntax
        Console.WriteLine(&quot;Students with grade &gt; 85 (Method Syntax):&quot;);
        var highGradeStudents = students
            .Where(s =&gt; s.Grade &gt; 85)
            .OrderBy(s =&gt; s.Name)
            .Select(s =&gt; new { s.Name, s.Grade, s.Course });

        foreach (var student in highGradeStudents)
        {
            Console.WriteLine($&quot;{student.Name}: {student.Grade} ({student.Course})&quot;);
        }

        // Query Syntax
        Console.WriteLine(&quot;\nComputer Science students (Query Syntax):&quot;);
        var csStudents = from s in students
                        where s.Course == &quot;Computer Science&quot;
                        orderby s.Grade descending
                        select s;

        foreach (var student in csStudents)
        {
            Console.WriteLine($&quot;{student.Name}: {student.Grade}&quot;);
        }
    }

    public static void AdvancedLinqOperations()
    {
        int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

        // Aggregation operations
        int sum = numbers.Sum();
        double average = numbers.Average();
        int max = numbers.Max();
        int min = numbers.Min();
        int count = numbers.Count(n =&gt; n % 2 == 0);

        Console.WriteLine($&quot;Sum: {sum}, Average: {average:F2}&quot;);
        Console.WriteLine($&quot;Max: {max}, Min: {min}, Even count: {count}&quot;);

        // Grouping
        List&lt;Student&gt; students = GetStudents();
        var groupedByCourse = students
            .GroupBy(s =&gt; s.Course)
            .Select(g =&gt; new
            {
                Course = g.Key,
                Count = g.Count(),
                AverageGrade = g.Average(s =&gt; s.Grade)
            });

        Console.WriteLine(&quot;\nStudents grouped by course:&quot;);
        foreach (var group in groupedByCourse)
        {
            Console.WriteLine($&quot;{group.Course}: {group.Count} students, Avg grade: {group.AverageGrade:F2}&quot;);
        }

        // Joining
        List&lt;Course&gt; courses = new List&lt;Course&gt;
        {
            new Course { Name = &quot;Computer Science&quot;, Credits = 4 },
            new Course { Name = &quot;Mathematics&quot;, Credits = 3 },
            new Course { Name = &quot;Physics&quot;, Credits = 4 }
        };

        var studentCourseInfo = from s in students
                               join c in courses on s.Course equals c.Name
                               select new
                               {
                                   StudentName = s.Name,
                                   CourseName = c.Name,
                                   Credits = c.Credits,
                                   Grade = s.Grade
                               };

        Console.WriteLine(&quot;\nStudent-Course Information:&quot;);
        foreach (var info in studentCourseInfo)
        {
            Console.WriteLine($&quot;{info.StudentName} - {info.CourseName} ({info.Credits} credits): {info.Grade}&quot;);
        }
    }

    public class Course
    {
        public string Name { get; set; }
        public int Credits { get; set; }
    }

    private static List&lt;Student&gt; GetStudents()
    {
        return new List&lt;Student&gt;
        {
            new Student { Id = 1, Name = &quot;Alice&quot;, Age = 20, Course = &quot;Computer Science&quot;, Grade = 85.5 },
            new Student { Id = 2, Name = &quot;Bob&quot;, Age = 22, Course = &quot;Mathematics&quot;, Grade = 92.0 },
            new Student { Id = 3, Name = &quot;Charlie&quot;, Age = 19, Course = &quot;Computer Science&quot;, Grade = 78.5 },
            new Student { Id = 4, Name = &quot;Diana&quot;, Age = 21, Course = &quot;Physics&quot;, Grade = 88.0 }
        };
    }
}
</code></pre>
<h3 id="question-3-write-a-c-program-to-connect-to-the-database-insert-data-into-database-and-display-the-data-using-ado.net">Question 3: Write a C# program to connect to the database, insert data into Database and display the data using ADO.NET.</h3>
<pre><code class="language-csharp">using System;
using System.Data;
using System.Data.SqlClient;

public class DatabaseOperations
{
    private static string connectionString = &quot;Server=localhost;Database=StudentDB;Integrated Security=true;&quot;;

    public static void Main()
    {
        try
        {
            CreateDatabase();
            InsertStudentData();
            DisplayStudentData();
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }

    public static void CreateDatabase()
    {
        string createTableQuery = @&quot;
            IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='Students' AND xtype='U')
            CREATE TABLE Students (
                Id INT PRIMARY KEY IDENTITY(1,1),
                Name NVARCHAR(50) NOT NULL,
                Age INT NOT NULL,
                Course NVARCHAR(100) NOT NULL,
                Grade DECIMAL(5,2) NOT NULL,
                EnrollmentDate DATETIME DEFAULT GETDATE()
            )&quot;;

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();
            using (SqlCommand command = new SqlCommand(createTableQuery, connection))
            {
                command.ExecuteNonQuery();
                Console.WriteLine(&quot;Table 'Students' created successfully.&quot;);
            }
        }
    }

    public static void InsertStudentData()
    {
        string insertQuery = @&quot;
            INSERT INTO Students (Name, Age, Course, Grade)
            VALUES (@Name, @Age, @Course, @Grade)&quot;;

        // Sample student data
        var students = new[]
        {
            new { Name = &quot;Alice Johnson&quot;, Age = 20, Course = &quot;Computer Science&quot;, Grade = 85.5m },
            new { Name = &quot;Bob Smith&quot;, Age = 22, Course = &quot;Mathematics&quot;, Grade = 92.0m },
            new { Name = &quot;Charlie Brown&quot;, Age = 19, Course = &quot;Physics&quot;, Grade = 78.5m },
            new { Name = &quot;Diana Prince&quot;, Age = 21, Course = &quot;Chemistry&quot;, Grade = 88.0m },
            new { Name = &quot;Eve Wilson&quot;, Age = 20, Course = &quot;Biology&quot;, Grade = 95.5m }
        };

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            foreach (var student in students)
            {
                using (SqlCommand command = new SqlCommand(insertQuery, connection))
                {
                    command.Parameters.AddWithValue(&quot;@Name&quot;, student.Name);
                    command.Parameters.AddWithValue(&quot;@Age&quot;, student.Age);
                    command.Parameters.AddWithValue(&quot;@Course&quot;, student.Course);
                    command.Parameters.AddWithValue(&quot;@Grade&quot;, student.Grade);

                    int rowsAffected = command.ExecuteNonQuery();
                    Console.WriteLine($&quot;Inserted student: {student.Name} ({rowsAffected} row(s) affected)&quot;);
                }
            }
        }
    }

    public static void DisplayStudentData()
    {
        string selectQuery = &quot;SELECT Id, Name, Age, Course, Grade, EnrollmentDate FROM Students ORDER BY Grade DESC&quot;;

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();
            using (SqlCommand command = new SqlCommand(selectQuery, connection))
            {
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    Console.WriteLine(&quot;\n--- Student Information ---&quot;);
                    Console.WriteLine($&quot;{&quot;ID&quot;,-5} {&quot;Name&quot;,-20} {&quot;Age&quot;,-5} {&quot;Course&quot;,-20} {&quot;Grade&quot;,-8} {&quot;Enrollment Date&quot;,-20}&quot;);
                    Console.WriteLine(new string('-', 80));

                    while (reader.Read())
                    {
                        Console.WriteLine($&quot;{reader[&quot;Id&quot;],-5} &quot; +
                                        $&quot;{reader[&quot;Name&quot;],-20} &quot; +
                                        $&quot;{reader[&quot;Age&quot;],-5} &quot; +
                                        $&quot;{reader[&quot;Course&quot;],-20} &quot; +
                                        $&quot;{reader[&quot;Grade&quot;],-8} &quot; +
                                        $&quot;{((DateTime)reader[&quot;EnrollmentDate&quot;]).ToString(&quot;yyyy-MM-dd&quot;),-20}&quot;);
                    }
                }
            }
        }
    }

    // Alternative method using DataSet (Disconnected architecture)
    public static void DisplayDataUsingDataSet()
    {
        string selectQuery = &quot;SELECT * FROM Students&quot;;

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            SqlDataAdapter adapter = new SqlDataAdapter(selectQuery, connection);
            DataSet dataSet = new DataSet();

            adapter.Fill(dataSet, &quot;Students&quot;);

            Console.WriteLine(&quot;\n--- Using DataSet ---&quot;);
            foreach (DataRow row in dataSet.Tables[&quot;Students&quot;].Rows)
            {
                Console.WriteLine($&quot;ID: {row[&quot;Id&quot;]}, Name: {row[&quot;Name&quot;]}, &quot; +
                                $&quot;Course: {row[&quot;Course&quot;]}, Grade: {row[&quot;Grade&quot;]}&quot;);
            }
        }
    }

    // Method to search students by course
    public static void SearchStudentsByCourse(string courseName)
    {
        string searchQuery = &quot;SELECT * FROM Students WHERE Course = @Course&quot;;

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();
            using (SqlCommand command = new SqlCommand(searchQuery, connection))
            {
                command.Parameters.AddWithValue(&quot;@Course&quot;, courseName);

                using (SqlDataReader reader = command.ExecuteReader())
                {
                    Console.WriteLine($&quot;\n--- Students in {courseName} ---&quot;);
                    while (reader.Read())
                    {
                        Console.WriteLine($&quot;{reader[&quot;Name&quot;]} - Grade: {reader[&quot;Grade&quot;]}&quot;);
                    }
                }
            }
        }
    }
}
</code></pre>
<h3 id="question-4-what-is-the-authentication-and-authorization-in-asp.net-explain-with-example">Question 4: What is the authentication and authorization in ASP.NET? Explain with example.</h3>
<h4 id="authentication-vs-authorization">Authentication vs Authorization:</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Authentication</th>
<th>Authorization</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Definition</strong></td>
<td>Verifying user identity</td>
<td>Determining user permissions</td>
</tr>
<tr>
<td><strong>Question</strong></td>
<td>&quot;Who are you?&quot;</td>
<td>&quot;What can you do?&quot;</td>
</tr>
<tr>
<td><strong>Process</strong></td>
<td>Login process</td>
<td>Access control</td>
</tr>
<tr>
<td><strong>Example</strong></td>
<td>Username/Password</td>
<td>Admin vs User roles</td>
</tr>
</tbody>
</table>
<h4 id="authentication-types-in-asp.net">Authentication Types in ASP.NET:</h4>
<ol>
<li><strong>Windows Authentication</strong> - Uses Windows accounts</li>
<li><strong>Forms Authentication</strong> - Custom login forms</li>
<li><strong>Identity Authentication</strong> - ASP.NET Identity system</li>
<li><strong>JWT Authentication</strong> - Token-based authentication</li>
</ol>
<h4 id="example-implementation">Example Implementation:</h4>
<pre><code class="language-csharp">// Startup.cs (ASP.NET Core)
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Add Identity services
        services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
            options.UseSqlServer(connectionString));

        services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt;
        {
            // Password requirements
            options.Password.RequireDigit = true;
            options.Password.RequiredLength = 6;
            options.Password.RequireNonAlphanumeric = false;
        })
        .AddRoles&lt;IdentityRole&gt;()
        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();

        services.AddControllersWithViews();
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseRouting();

        // Authentication middleware
        app.UseAuthentication();
        app.UseAuthorization();

        app.UseEndpoints(endpoints =&gt;
        {
            endpoints.MapControllerRoute(
                name: &quot;default&quot;,
                pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            endpoints.MapRazorPages();
        });
    }
}

// Controllers with Authentication and Authorization
[Authorize] // Requires authentication
public class HomeController : Controller
{
    public IActionResult Index()
    {
        return View();
    }

    [Authorize(Roles = &quot;Admin&quot;)] // Requires Admin role
    public IActionResult AdminPanel()
    {
        return View();
    }

    [Authorize(Policy = &quot;MinimumAge&quot;)] // Custom policy
    public IActionResult RestrictedContent()
    {
        return View();
    }

    [AllowAnonymous] // Allows anonymous access
    public IActionResult PublicInfo()
    {
        return View();
    }
}

// Account Controller for Authentication
public class AccountController : Controller
{
    private readonly UserManager&lt;IdentityUser&gt; _userManager;
    private readonly SignInManager&lt;IdentityUser&gt; _signInManager;

    public AccountController(UserManager&lt;IdentityUser&gt; userManager,
                           SignInManager&lt;IdentityUser&gt; signInManager)
    {
        _userManager = userManager;
        _signInManager = signInManager;
    }

    [HttpGet]
    public IActionResult Login()
    {
        return View();
    }

    [HttpPost]
    public async Task&lt;IActionResult&gt; Login(LoginViewModel model)
    {
        if (ModelState.IsValid)
        {
            var result = await _signInManager.PasswordSignInAsync(
                model.Email, model.Password, model.RememberMe, false);

            if (result.Succeeded)
            {
                return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
            }

            ModelState.AddModelError(&quot;&quot;, &quot;Invalid login attempt.&quot;);
        }

        return View(model);
    }

    [HttpPost]
    public async Task&lt;IActionResult&gt; Logout()
    {
        await _signInManager.SignOutAsync();
        return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
    }

    [HttpGet]
    public IActionResult Register()
    {
        return View();
    }

    [HttpPost]
    public async Task&lt;IActionResult&gt; Register(RegisterViewModel model)
    {
        if (ModelState.IsValid)
        {
            var user = new IdentityUser
            {
                UserName = model.Email,
                Email = model.Email
            };

            var result = await _userManager.CreateAsync(user, model.Password);

            if (result.Succeeded)
            {
                await _signInManager.SignInAsync(user, isPersistent: false);
                return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
            }

            foreach (var error in result.Errors)
            {
                ModelState.AddModelError(&quot;&quot;, error.Description);
            }
        }

        return View(model);
    }
}

// ViewModels
public class LoginViewModel
{
    [Required]
    [EmailAddress]
    public string Email { get; set; }

    [Required]
    [DataType(DataType.Password)]
    public string Password { get; set; }

    public bool RememberMe { get; set; }
}

public class RegisterViewModel
{
    [Required]
    [EmailAddress]
    public string Email { get; set; }

    [Required]
    [DataType(DataType.Password)]
    public string Password { get; set; }

    [DataType(DataType.Password)]
    [Compare(&quot;Password&quot;, ErrorMessage = &quot;Passwords don't match.&quot;)]
    public string ConfirmPassword { get; set; }
}
</code></pre>
<h3 id="question-5-explain-the-asp.net-page-life-cycle.what-is-the-difference-between-server.redirect-and-server.transfer-explain-with-example">Question 5: Explain the ASP.NET page life cycle. What is the difference between Server.Redirect and Server.Transfer? Explain with example.</h3>
<h4 id="asp.net-page-life-cycle">ASP.NET Page Life Cycle:</h4>
<pre><code class="language-csharp">public partial class PageLifeCycleDemo : System.Web.UI.Page
{
    protected void Page_PreInit(object sender, EventArgs e)
    {
        // Occurs before page initialization
        // Can set themes, master pages, and create dynamic controls
        Response.Write(&quot;1. PreInit&lt;br/&gt;&quot;);
    }

    protected void Page_Init(object sender, EventArgs e)
    {
        // Page and control initialization
        // ViewState is not available yet
        Response.Write(&quot;2. Init&lt;br/&gt;&quot;);
    }

    protected void Page_InitComplete(object sender, EventArgs e)
    {
        // All controls are initialized
        Response.Write(&quot;3. InitComplete&lt;br/&gt;&quot;);
    }

    protected void Page_PreLoad(object sender, EventArgs e)
    {
        // Occurs before Load event
        Response.Write(&quot;4. PreLoad&lt;br/&gt;&quot;);
    }

    protected void Page_Load(object sender, EventArgs e)
    {
        // Page and controls are loaded
        // ViewState is available
        if (!IsPostBack)
        {
            Response.Write(&quot;5. Load (First Time)&lt;br/&gt;&quot;);
        }
        else
        {
            Response.Write(&quot;5. Load (PostBack)&lt;br/&gt;&quot;);
        }
    }

    protected void Page_LoadComplete(object sender, EventArgs e)
    {
        // All controls are loaded
        Response.Write(&quot;6. LoadComplete&lt;br/&gt;&quot;);
    }

    protected void Page_PreRender(object sender, EventArgs e)
    {
        // Occurs before rendering
        // Last chance to modify controls
        Response.Write(&quot;7. PreRender&lt;br/&gt;&quot;);
    }

    protected void Page_PreRenderComplete(object sender, EventArgs e)
    {
        // All controls have completed pre-rendering
        Response.Write(&quot;8. PreRenderComplete&lt;br/&gt;&quot;);
    }

    protected void Page_SaveStateComplete(object sender, EventArgs e)
    {
        // ViewState has been saved
        Response.Write(&quot;9. SaveStateComplete&lt;br/&gt;&quot;);
    }

    protected void Page_Unload(object sender, EventArgs e)
    {
        // Cleanup - page is being destroyed
        // Cannot modify response here
        // Use for cleanup operations
    }
}
</code></pre>
<h4 id="server.redirect-vs-server.transfer">Server.Redirect vs Server.Transfer:</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Server.Redirect</th>
<th>Server.Transfer</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Location</strong></td>
<td>Client-side redirection</td>
<td>Server-side transfer</td>
</tr>
<tr>
<td><strong>URL Change</strong></td>
<td>Browser URL changes</td>
<td>Browser URL remains same</td>
</tr>
<tr>
<td><strong>Round Trips</strong></td>
<td>Two round trips</td>
<td>One round trip</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Slower</td>
<td>Faster</td>
</tr>
<tr>
<td><strong>Context Preservation</strong></td>
<td>New request context</td>
<td>Same request context</td>
</tr>
<tr>
<td><strong>External URLs</strong></td>
<td>Can redirect to external sites</td>
<td>Cannot transfer to external sites</td>
</tr>
</tbody>
</table>
<h4 id="examples-2">Examples:</h4>
<pre><code class="language-csharp">// Server.Redirect Example
public partial class RedirectExample : System.Web.UI.Page
{
    protected void btnRedirect_Click(object sender, EventArgs e)
    {
        // Method 1: Simple redirect
        Response.Redirect(&quot;Welcome.aspx&quot;);

        // Method 2: Redirect with query string
        Response.Redirect(&quot;Welcome.aspx?name=&quot; + txtName.Text);

        // Method 3: Redirect with end response
        Response.Redirect(&quot;Welcome.aspx&quot;, true); // Ends current page execution

        // Method 4: Redirect to external site
        Response.Redirect(&quot;https://www.google.com&quot;);
    }

    protected void btnRedirectPermanent_Click(object sender, EventArgs e)
    {
        // Permanent redirect (301 status code)
        Response.RedirectPermanent(&quot;NewLocation.aspx&quot;);
    }
}

// Server.Transfer Example
public partial class TransferExample : System.Web.UI.Page
{
    protected void btnTransfer_Click(object sender, EventArgs e)
    {
        // Method 1: Simple transfer
        Server.Transfer(&quot;Welcome.aspx&quot;);

        // Method 2: Transfer with preserving form data
        Server.Transfer(&quot;Welcome.aspx&quot;, true); // Preserves form collection

        // Method 3: Transfer with passing data through Context
        Context.Items[&quot;UserData&quot;] = txtName.Text;
        Server.Transfer(&quot;Welcome.aspx&quot;);
    }
}

// Destination page to receive transferred data
public partial class Welcome : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        // Getting data from redirect (query string)
        string nameFromRedirect = Request.QueryString[&quot;name&quot;];
        if (!string.IsNullOrEmpty(nameFromRedirect))
        {
            lblWelcome.Text = &quot;Welcome &quot; + nameFromRedirect + &quot; (from Redirect)&quot;;
        }

        // Getting data from transfer (Context.Items)
        string nameFromTransfer = Context.Items[&quot;UserData&quot;] as string;
        if (!string.IsNullOrEmpty(nameFromTransfer))
        {
            lblWelcome.Text = &quot;Welcome &quot; + nameFromTransfer + &quot; (from Transfer)&quot;;
        }

        // Getting data from transfer (Previous page)
        if (PreviousPage != null)
        {
            TextBox txtPreviousName = PreviousPage.FindControl(&quot;txtName&quot;) as TextBox;
            if (txtPreviousName != null)
            {
                lblWelcome.Text = &quot;Welcome &quot; + txtPreviousName.Text + &quot; (from Previous Page)&quot;;
            }
        }
    }
}
</code></pre>
<h3 id="question-6-describe-the-following-terms-razor-view-stream-reader-and-stream-writer">Question 6: Describe the following terms: Razor View, Stream Reader and Stream Writer.</h3>
<h4 id="razor-view">Razor View</h4>
<p>Razor is a markup syntax for embedding .NET code into web pages. It provides a clean and lightweight way to create dynamic web content.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Uses @ symbol to transition from HTML to C#</li>
<li>Supports both C# and VB.NET</li>
<li>IntelliSense support in Visual Studio</li>
<li>Compile-time syntax checking</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-html">@{
    ViewData[&quot;Title&quot;] = &quot;Student List&quot;;
    var students = ViewBag.Students as List&lt;Student&gt;;
}

&lt;h2&gt;@ViewData[&quot;Title&quot;]&lt;/h2&gt;

@if (students != null &amp;&amp; students.Any())
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Name&lt;/th&gt;
                &lt;th&gt;Age&lt;/th&gt;
                &lt;th&gt;Course&lt;/th&gt;
                &lt;th&gt;Grade&lt;/th&gt;
                &lt;th&gt;Actions&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            @foreach (var student in students)
            {
                &lt;tr&gt;
                    &lt;td&gt;@student.Name&lt;/td&gt;
                    &lt;td&gt;@student.Age&lt;/td&gt;
                    &lt;td&gt;@student.Course&lt;/td&gt;
                    &lt;td&gt;@student.Grade.ToString(&quot;F2&quot;)&lt;/td&gt;
                    &lt;td&gt;
                        &lt;a href=&quot;@Url.Action(&quot;Edit&quot;, &quot;Student&quot;, new { id = student.Id })&quot;&gt;Edit&lt;/a&gt; |
                        &lt;a href=&quot;@Url.Action(&quot;Delete&quot;, &quot;Student&quot;, new { id = student.Id })&quot;&gt;Delete&lt;/a&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            }
        &lt;/tbody&gt;
    &lt;/table&gt;
}
else
{
    &lt;p&gt;No students found.&lt;/p&gt;
}

@section Scripts {
    &lt;script&gt;
        function confirmDelete(studentName) {
            return confirm('Are you sure you want to delete ' + studentName + '?');
        }
    &lt;/script&gt;
}
</code></pre>
<h4 id="stream-reader">Stream Reader</h4>
<p>StreamReader is used to read characters from a stream in a particular encoding.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Reads text files efficiently</li>
<li>Supports different encodings (UTF-8, ASCII, etc.)</li>
<li>Implements IDisposable (use with using statement)</li>
<li>Provides both synchronous and asynchronous methods</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-csharp">public class StreamReaderExamples
{
    public static void ReadTextFile()
    {
        string filePath = @&quot;C:\temp\students.txt&quot;;

        // Method 1: Using 'using' statement (recommended)
        using (StreamReader reader = new StreamReader(filePath))
        {
            string content = reader.ReadToEnd();
            Console.WriteLine(&quot;File Content:&quot;);
            Console.WriteLine(content);
        }

        // Method 2: Reading line by line
        using (StreamReader reader = new StreamReader(filePath))
        {
            string line;
            int lineNumber = 1;

            while ((line = reader.ReadLine()) != null)
            {
                Console.WriteLine($&quot;Line {lineNumber}: {line}&quot;);
                lineNumber++;
            }
        }

        // Method 3: Reading with specific encoding
        using (StreamReader reader = new StreamReader(filePath, Encoding.UTF8))
        {
            string content = reader.ReadToEnd();
            Console.WriteLine(content);
        }
    }

    public static async Task ReadTextFileAsync()
    {
        string filePath = @&quot;C:\temp\students.txt&quot;;

        using (StreamReader reader = new StreamReader(filePath))
        {
            string content = await reader.ReadToEndAsync();
            Console.WriteLine(&quot;Async File Content:&quot;);
            Console.WriteLine(content);
        }
    }

    public static void ProcessLargeFile()
    {
        string filePath = @&quot;C:\temp\largefile.txt&quot;;

        using (StreamReader reader = new StreamReader(filePath))
        {
            string line;
            while ((line = reader.ReadLine()) != null)
            {
                // Process each line individually to save memory
                ProcessLine(line);
            }
        }
    }

    private static void ProcessLine(string line)
    {
        // Process individual line
        if (line.Contains(&quot;ERROR&quot;))
        {
            Console.WriteLine($&quot;Error found: {line}&quot;);
        }
    }
}
</code></pre>
<h4 id="stream-writer">Stream Writer</h4>
<p>StreamWriter is used to write characters to a stream in a particular encoding.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Writes text to files efficiently</li>
<li>Supports different encodings</li>
<li>Can append to existing files</li>
<li>Implements IDisposable</li>
<li>Provides both synchronous and asynchronous methods</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-csharp">public class StreamWriterExamples
{
    public static void WriteTextFile()
    {
        string filePath = @&quot;C:\temp\output.txt&quot;;

        // Method 1: Create new file (overwrites existing)
        using (StreamWriter writer = new StreamWriter(filePath))
        {
            writer.WriteLine(&quot;Student Information&quot;);
            writer.WriteLine(&quot;==================&quot;);
            writer.WriteLine(&quot;Name: Alice Johnson&quot;);
            writer.WriteLine(&quot;Age: 20&quot;);
            writer.WriteLine(&quot;Course: Computer Science&quot;);
            writer.WriteLine($&quot;Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}&quot;);
        }

        // Method 2: Append to existing file
        using (StreamWriter writer = new StreamWriter(filePath, append: true))
        {
            writer.WriteLine(&quot;\nAdditional Information:&quot;);
            writer.WriteLine(&quot;Grade: 85.5&quot;);
            writer.WriteLine(&quot;Status: Active&quot;);
        }

        // Method 3: With specific encoding
        using (StreamWriter writer = new StreamWriter(filePath, false, Encoding.UTF8))
        {
            writer.WriteLine(&quot;UTF-8 encoded content with special characters: Ã¡Ã©Ã­Ã³Ãº&quot;);
        }
    }

    public static void WriteStudentData()
    {
        string filePath = @&quot;C:\temp\students.csv&quot;;

        var students = new[]
        {
            new { Name = &quot;Alice&quot;, Age = 20, Course = &quot;CS&quot;, Grade = 85.5 },
            new { Name = &quot;Bob&quot;, Age = 22, Course = &quot;Math&quot;, Grade = 92.0 },
            new { Name = &quot;Charlie&quot;, Age = 19, Course = &quot;Physics&quot;, Grade = 78.5 }
        };

        using (StreamWriter writer = new StreamWriter(filePath))
        {
            // Write CSV header
            writer.WriteLine(&quot;Name,Age,Course,Grade&quot;);

            // Write student data
            foreach (var student in students)
            {
                writer.WriteLine($&quot;{student.Name},{student.Age},{student.Course},{student.Grade}&quot;);
            }
        }

        Console.WriteLine($&quot;Student data written to {filePath}&quot;);
    }

    public static async Task WriteTextFileAsync()
    {
        string filePath = @&quot;C:\temp\async_output.txt&quot;;

        using (StreamWriter writer = new StreamWriter(filePath))
        {
            await writer.WriteLineAsync(&quot;Async writing example&quot;);
            await writer.WriteLineAsync($&quot;Written at: {DateTime.Now}&quot;);
        }
    }

    public static void LogExample()
    {
        string logPath = @&quot;C:\temp\application.log&quot;;

        using (StreamWriter writer = new StreamWriter(logPath, append: true))
        {
            writer.WriteLine($&quot;[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] INFO: Application started&quot;);
            writer.WriteLine($&quot;[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] DEBUG: Processing user request&quot;);
            writer.WriteLine($&quot;[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] ERROR: Database connection failed&quot;);

            // Ensure data is written immediately
            writer.Flush();
        }
    }
}
</code></pre>
<h3 id="question-7-describe-different-types-of-inheritance-methods-with-example-in-c">Question 7: Describe different types of inheritance methods with example in C#.</h3>
<h4 id="types-of-inheritance-in-c-1">Types of Inheritance in C#:</h4>
<ol>
<li><strong>Single Inheritance</strong> - One class inherits from one base class</li>
<li><strong>Multilevel Inheritance</strong> - Chain of inheritance</li>
<li><strong>Hierarchical Inheritance</strong> - Multiple classes inherit from one base class</li>
<li><strong>Interface Inheritance</strong> - Multiple interface implementation (Multiple inheritance alternative)</li>
</ol>
<p><strong>Note:</strong> C# does not support multiple inheritance of classes, but supports multiple interface inheritance.</p>
<h4 id="examples-3">Examples:</h4>
<pre><code class="language-csharp">// 1. Single Inheritance
public class Animal
{
    public string Name { get; set; }
    public int Age { get; set; }

    public virtual void Eat()
    {
        Console.WriteLine($&quot;{Name} is eating.&quot;);
    }

    public virtual void Sleep()
    {
        Console.WriteLine($&quot;{Name} is sleeping.&quot;);
    }
}

public class Dog : Animal // Single inheritance
{
    public string Breed { get; set; }

    public override void Eat()
    {
        Console.WriteLine($&quot;{Name} the dog is eating dog food.&quot;);
    }

    public void Bark()
    {
        Console.WriteLine($&quot;{Name} is barking!&quot;);
    }
}

// 2. Multilevel Inheritance
public class Mammal : Animal
{
    public double BodyTemperature { get; set; } = 37.0;

    public virtual void GiveBirth()
    {
        Console.WriteLine($&quot;{Name} is giving birth to live offspring.&quot;);
    }
}

public class Canine : Mammal
{
    public string PackBehavior { get; set; }

    public virtual void Hunt()
    {
        Console.WriteLine($&quot;{Name} is hunting in a pack.&quot;);
    }
}

public class Wolf : Canine // Multilevel: Wolf -&gt; Canine -&gt; Mammal -&gt; Animal
{
    public string Territory { get; set; }

    public override void Hunt()
    {
        Console.WriteLine($&quot;{Name} the wolf is hunting in territory: {Territory}&quot;);
    }

    public void Howl()
    {
        Console.WriteLine($&quot;{Name} is howling at the moon!&quot;);
    }
}

// 3. Hierarchical Inheritance
public class Vehicle
{
    public string Brand { get; set; }
    public int Year { get; set; }

    public virtual void Start()
    {
        Console.WriteLine($&quot;{Brand} vehicle is starting.&quot;);
    }

    public virtual void Stop()
    {
        Console.WriteLine($&quot;{Brand} vehicle is stopping.&quot;);
    }
}

public class Car : Vehicle // Hierarchical inheritance
{
    public int NumberOfDoors { get; set; }

    public override void Start()
    {
        Console.WriteLine($&quot;{Brand} car is starting with ignition.&quot;);
    }

    public void OpenTrunk()
    {
        Console.WriteLine(&quot;Car trunk is opened.&quot;);
    }
}

public class Motorcycle : Vehicle // Hierarchical inheritance
{
    public bool HasSidecar { get; set; }

    public override void Start()
    {
        Console.WriteLine($&quot;{Brand} motorcycle is starting with kick/button.&quot;);
    }

    public void Wheelie()
    {
        Console.WriteLine(&quot;Motorcycle is doing a wheelie!&quot;);
    }
}

public class Truck : Vehicle // Hierarchical inheritance
{
    public double CargoCapacity { get; set; }

    public override void Start()
    {
        Console.WriteLine($&quot;{Brand} truck is starting with heavy engine.&quot;);
    }

    public void LoadCargo()
    {
        Console.WriteLine($&quot;Loading cargo up to {CargoCapacity} tons.&quot;);
    }
}

// 4. Interface Inheritance (Multiple inheritance alternative)
public interface IFlyable
{
    void Fly();
    double MaxAltitude { get; }
}

public interface ISwimmable
{
    void Swim();
    double MaxDepth { get; }
}

public interface IWalkable
{
    void Walk();
    double MaxSpeed { get; }
}

// Multiple interface inheritance
public class Duck : Animal, IFlyable, ISwimmable, IWalkable
{
    public double MaxAltitude { get; set; } = 1000;
    public double MaxDepth { get; set; } = 5;
    public double MaxSpeed { get; set; } = 10;

    public void Fly()
    {
        Console.WriteLine($&quot;{Name} the duck is flying up to {MaxAltitude} meters.&quot;);
    }

    public void Swim()
    {
        Console.WriteLine($&quot;{Name} the duck is swimming up to {MaxDepth} meters deep.&quot;);
    }

    public void Walk()
    {
        Console.WriteLine($&quot;{Name} the duck is walking at {MaxSpeed} km/h.&quot;);
    }

    public void Quack()
    {
        Console.WriteLine($&quot;{Name} says: Quack quack!&quot;);
    }
}

// Usage Example
public class InheritanceDemo
{
    public static void Main()
    {
        // Single inheritance
        Dog dog = new Dog { Name = &quot;Buddy&quot;, Age = 3, Breed = &quot;Golden Retriever&quot; };
        dog.Eat();
        dog.Bark();

        // Multilevel inheritance
        Wolf wolf = new Wolf { Name = &quot;Alpha&quot;, Age = 5, Territory = &quot;Forest&quot; };
        wolf.Eat();      // From Animal
        wolf.GiveBirth(); // From Mammal
        wolf.Hunt();     // From Canine (overridden)
        wolf.Howl();     // From Wolf

        // Hierarchical inheritance
        Car car = new Car { Brand = &quot;Toyota&quot;, Year = 2023, NumberOfDoors = 4 };
        Motorcycle bike = new Motorcycle { Brand = &quot;Honda&quot;, Year = 2022, HasSidecar = false };
        Truck truck = new Truck { Brand = &quot;Ford&quot;, Year = 2021, CargoCapacity = 10.5 };

        car.Start();
        bike.Start();
        truck.Start();

        // Multiple interface inheritance
        Duck duck = new Duck { Name = &quot;Donald&quot;, Age = 2 };
        duck.Eat();   // From Animal
        duck.Fly();   // From IFlyable
        duck.Swim();  // From ISwimmable
        duck.Walk();  // From IWalkable
        duck.Quack(); // From Duck
    }
}
</code></pre>
<h3 id="question-8-what-are-benefit-of-ajax-how-do-you-implement-ajax-in-mvc-explain">Question 8: What are benefit of Ajax? How do you implement Ajax in MVC? Explain.</h3>
<h4 id="benefits-of-ajax">Benefits of AJAX:</h4>
<ol>
<li><strong>Improved User Experience</strong> - No full page reloads</li>
<li><strong>Faster Response Time</strong> - Only necessary data is transferred</li>
<li><strong>Reduced Server Load</strong> - Less bandwidth usage</li>
<li><strong>Asynchronous Operations</strong> - Non-blocking user interface</li>
<li><strong>Dynamic Content Updates</strong> - Real-time data updates</li>
<li><strong>Better Interactivity</strong> - More responsive applications</li>
</ol>
<h4 id="ajax-implementation-in-mvc">AJAX Implementation in MVC:</h4>
<pre><code class="language-csharp">// 1. Controller Actions for AJAX
public class EmployeeController : Controller
{
    private List&lt;Employee&gt; employees = new List&lt;Employee&gt;
    {
        new Employee { Id = 1, Name = &quot;Alice Johnson&quot;, Department = &quot;IT&quot;, Salary = 75000 },
        new Employee { Id = 2, Name = &quot;Bob Smith&quot;, Department = &quot;HR&quot;, Salary = 65000 },
        new Employee { Id = 3, Name = &quot;Charlie Brown&quot;, Department = &quot;Finance&quot;, Salary = 80000 }
    };

    public IActionResult Index()
    {
        return View();
    }

    // AJAX method to get all employees
    [HttpGet]
    public JsonResult GetEmployees()
    {
        return Json(employees);
    }

    // AJAX method to get employee by ID
    [HttpGet]
    public JsonResult GetEmployee(int id)
    {
        var employee = employees.FirstOrDefault(e =&gt; e.Id == id);
        if (employee != null)
        {
            return Json(new { success = true, data = employee });
        }
        return Json(new { success = false, message = &quot;Employee not found&quot; });
    }

    // AJAX method to add employee
    [HttpPost]
    public JsonResult AddEmployee(Employee employee)
    {
        try
        {
            employee.Id = employees.Max(e =&gt; e.Id) + 1;
            employees.Add(employee);
            return Json(new { success = true, message = &quot;Employee added successfully&quot;, data = employee });
        }
        catch (Exception ex)
        {
            return Json(new { success = false, message = ex.Message });
        }
    }

    // AJAX method to update employee
    [HttpPost]
    public JsonResult UpdateEmployee(Employee employee)
    {
        try
        {
            var existingEmployee = employees.FirstOrDefault(e =&gt; e.Id == employee.Id);
            if (existingEmployee != null)
            {
                existingEmployee.Name = employee.Name;
                existingEmployee.Department = employee.Department;
                existingEmployee.Salary = employee.Salary;
                return Json(new { success = true, message = &quot;Employee updated successfully&quot; });
            }
            return Json(new { success = false, message = &quot;Employee not found&quot; });
        }
        catch (Exception ex)
        {
            return Json(new { success = false, message = ex.Message });
        }
    }

    // AJAX method to delete employee
    [HttpPost]
    public JsonResult DeleteEmployee(int id)
    {
        try
        {
            var employee = employees.FirstOrDefault(e =&gt; e.Id == id);
            if (employee != null)
            {
                employees.Remove(employee);
                return Json(new { success = true, message = &quot;Employee deleted successfully&quot; });
            }
            return Json(new { success = false, message = &quot;Employee not found&quot; });
        }
        catch (Exception ex)
        {
            return Json(new { success = false, message = ex.Message });
        }
    }
}

public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Department { get; set; }
    public decimal Salary { get; set; }
}
</code></pre>
<h4 id="razor-view-with-ajax">Razor View with AJAX:</h4>
<pre><code class="language-html">@{
    ViewData[&quot;Title&quot;] = &quot;Employee Management&quot;;
}

&lt;h2&gt;Employee Management System&lt;/h2&gt;

&lt;div class=&quot;container&quot;&gt;
    &lt;!-- Add Employee Form --&gt;
    &lt;div class=&quot;card mb-4&quot;&gt;
        &lt;div class=&quot;card-header&quot;&gt;
            &lt;h4&gt;Add New Employee&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;card-body&quot;&gt;
            &lt;form id=&quot;employeeForm&quot;&gt;
                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;col-md-4&quot;&gt;
                        &lt;input type=&quot;text&quot; id=&quot;employeeName&quot; class=&quot;form-control&quot; placeholder=&quot;Employee Name&quot; required&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;col-md-4&quot;&gt;
                        &lt;input type=&quot;text&quot; id=&quot;employeeDepartment&quot; class=&quot;form-control&quot; placeholder=&quot;Department&quot; required&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;col-md-2&quot;&gt;
                        &lt;input type=&quot;number&quot; id=&quot;employeeSalary&quot; class=&quot;form-control&quot; placeholder=&quot;Salary&quot; required&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;col-md-2&quot;&gt;
                        &lt;button type=&quot;button&quot; id=&quot;addEmployee&quot; class=&quot;btn btn-primary&quot;&gt;Add Employee&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Employee List --&gt;
    &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;card-header d-flex justify-content-between&quot;&gt;
            &lt;h4&gt;Employee List&lt;/h4&gt;
            &lt;button type=&quot;button&quot; id=&quot;refreshList&quot; class=&quot;btn btn-secondary&quot;&gt;Refresh&lt;/button&gt;
        &lt;/div&gt;
        &lt;div class=&quot;card-body&quot;&gt;
            &lt;div id=&quot;loadingSpinner&quot; class=&quot;text-center&quot; style=&quot;display: none;&quot;&gt;
                &lt;div class=&quot;spinner-border&quot; role=&quot;status&quot;&gt;
                    &lt;span class=&quot;sr-only&quot;&gt;Loading...&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;table class=&quot;table table-striped&quot; id=&quot;employeeTable&quot;&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;ID&lt;/th&gt;
                        &lt;th&gt;Name&lt;/th&gt;
                        &lt;th&gt;Department&lt;/th&gt;
                        &lt;th&gt;Salary&lt;/th&gt;
                        &lt;th&gt;Actions&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody id=&quot;employeeTableBody&quot;&gt;
                    &lt;!-- Employee data will be loaded here via AJAX --&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- Edit Employee Modal --&gt;
&lt;div class=&quot;modal fade&quot; id=&quot;editEmployeeModal&quot; tabindex=&quot;-1&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot;&gt;
        &lt;div class=&quot;modal-content&quot;&gt;
            &lt;div class=&quot;modal-header&quot;&gt;
                &lt;h5 class=&quot;modal-title&quot;&gt;Edit Employee&lt;/h5&gt;
                &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;
                    &lt;span&gt;&amp;times;&lt;/span&gt;
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;div class=&quot;modal-body&quot;&gt;
                &lt;form id=&quot;editEmployeeForm&quot;&gt;
                    &lt;input type=&quot;hidden&quot; id=&quot;editEmployeeId&quot;&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label&gt;Name:&lt;/label&gt;
                        &lt;input type=&quot;text&quot; id=&quot;editEmployeeName&quot; class=&quot;form-control&quot; required&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label&gt;Department:&lt;/label&gt;
                        &lt;input type=&quot;text&quot; id=&quot;editEmployeeDepartment&quot; class=&quot;form-control&quot; required&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label&gt;Salary:&lt;/label&gt;
                        &lt;input type=&quot;number&quot; id=&quot;editEmployeeSalary&quot; class=&quot;form-control&quot; required&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;
            &lt;div class=&quot;modal-footer&quot;&gt;
                &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot; data-dismiss=&quot;modal&quot;&gt;Cancel&lt;/button&gt;
                &lt;button type=&quot;button&quot; id=&quot;saveEmployee&quot; class=&quot;btn btn-primary&quot;&gt;Save Changes&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

@section Scripts {
&lt;script&gt;
$(document).ready(function() {
    // Load employees on page load
    loadEmployees();

    // Add employee
    $('#addEmployee').click(function() {
        addEmployee();
    });

    // Refresh employee list
    $('#refreshList').click(function() {
        loadEmployees();
    });

    // Save edited employee
    $('#saveEmployee').click(function() {
        updateEmployee();
    });
});

function loadEmployees() {
    $('#loadingSpinner').show();
    $('#employeeTableBody').empty();

    $.ajax({
        url: '@Url.Action(&quot;GetEmployees&quot;, &quot;Employee&quot;)',
        type: 'GET',
        dataType: 'json',
        success: function(data) {
            $('#loadingSpinner').hide();
            var tbody = $('#employeeTableBody');

            if (data &amp;&amp; data.length &gt; 0) {
                $.each(data, function(index, employee) {
                    var row = `
                        &lt;tr&gt;
                            &lt;td&gt;${employee.id}&lt;/td&gt;
                            &lt;td&gt;${employee.name}&lt;/td&gt;
                            &lt;td&gt;${employee.department}&lt;/td&gt;
                            &lt;td&gt;$${employee.salary.toLocaleString()}&lt;/td&gt;
                            &lt;td&gt;
                                &lt;button class=&quot;btn btn-sm btn-warning&quot; onclick=&quot;editEmployee(${employee.id})&quot;&gt;Edit&lt;/button&gt;
                                &lt;button class=&quot;btn btn-sm btn-danger&quot; onclick=&quot;deleteEmployee(${employee.id})&quot;&gt;Delete&lt;/button&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    `;
                    tbody.append(row);
                });
            } else {
                tbody.append('&lt;tr&gt;&lt;td colspan=&quot;5&quot; class=&quot;text-center&quot;&gt;No employees found&lt;/td&gt;&lt;/tr&gt;');
            }
        },
        error: function() {
            $('#loadingSpinner').hide();
            alert('Failed to load employees');
        }
    });
}

function addEmployee() {
    var name = $('#employeeName').val();
    var department = $('#employeeDepartment').val();
    var salary = $('#employeeSalary').val();

    if (!name || !department || !salary) {
        alert('Please fill all fields');
        return;
    }

    $.ajax({
        url: '@Url.Action(&quot;AddEmployee&quot;, &quot;Employee&quot;)',
        type: 'POST',
        data: {
            Name: name,
            Department: department,
            Salary: salary
        },
        success: function(response) {
            if (response.success) {
                alert(response.message);
                loadEmployees();
                $('#employeeName').val('');
                $('#employeeDepartment').val('');
                $('#employeeSalary').val('');
            } else {
                alert('Error: ' + response.message);
            }
        },
        error: function() {
            alert('Failed to add employee');
        }
    });
}

function editEmployee(id) {
    $.ajax({
        url: '@Url.Action(&quot;GetEmployee&quot;, &quot;Employee&quot;)',
        type: 'GET',
        data: { id: id },
        success: function(response) {
            if (response.success) {
                var employee = response.data;
                $('#editEmployeeId').val(employee.id);
                $('#editEmployeeName').val(employee.name);
                $('#editEmployeeDepartment').val(employee.department);
                $('#editEmployeeSalary').val(employee.salary);
                $('#editEmployeeModal').modal('show');
            } else {
                alert('Error: ' + response.message);
            }
        },
        error: function() {
            alert('Failed to get employee details');
        }
    });
}

function updateEmployee() {
    var id = $('#editEmployeeId').val();
    var name = $('#editEmployeeName').val();
    var department = $('#editEmployeeDepartment').val();
    var salary = $('#editEmployeeSalary').val();

    $.ajax({
        url: '@Url.Action(&quot;UpdateEmployee&quot;, &quot;Employee&quot;)',
        type: 'POST',
        data: {
            Id: id,
            Name: name,
            Department: department,
            Salary: salary
        },
        success: function(response) {
            if (response.success) {
                alert(response.message);
                $('#editEmployeeModal').modal('hide');
                loadEmployees();
            } else {
                alert('Error: ' + response.message);
            }
        },
        error: function() {
            alert('Failed to update employee');
        }
    });
}

function deleteEmployee(id) {
    if (confirm('Are you sure you want to delete this employee?')) {
        $.ajax({
            url: '@Url.Action(&quot;DeleteEmployee&quot;, &quot;Employee&quot;)',
            type: 'POST',
            data: { id: id },
            success: function(response) {
                if (response.success) {
                    alert(response.message);
                    loadEmployees();
                } else {
                    alert('Error: ' + response.message);
                }
            },
            error: function() {
                alert('Failed to delete employee');
            }
        });
    }
}
&lt;/script&gt;
}
</code></pre>
<h3 id="question-9-explain-difference-between-value-type-and-reference-type-in-clr-with-example">Question 9: Explain difference between value type and reference type in CLR with example.</h3>
<h4 id="value-types-vs-reference-types-in-clr">Value Types vs Reference Types in CLR:</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Value Type</th>
<th>Reference Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Storage</strong></td>
<td>Stack (for local variables)</td>
<td>Heap</td>
</tr>
<tr>
<td><strong>Memory Allocation</strong></td>
<td>Direct value storage</td>
<td>Reference to heap location</td>
</tr>
<tr>
<td><strong>Assignment</strong></td>
<td>Creates a copy</td>
<td>Copies the reference</td>
</tr>
<tr>
<td><strong>Null Values</strong></td>
<td>Cannot be null (except nullable)</td>
<td>Can be null</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Faster access</td>
<td>Slower due to indirection</td>
</tr>
<tr>
<td><strong>Garbage Collection</strong></td>
<td>No GC needed for stack allocation</td>
<td>Subject to garbage collection</td>
</tr>
<tr>
<td><strong>Default Values</strong></td>
<td>Zero/false for primitives</td>
<td>null for references</td>
</tr>
</tbody>
</table>
<h4 id="clr-memory-management-example">CLR Memory Management Example:</h4>
<pre><code class="language-csharp">public class ValueVsReferenceTypeDemo
{
    // Value type struct
    public struct Point
    {
        public int X, Y;
        public Point(int x, int y) { X = x; Y = y; }
        public override string ToString() =&gt; $&quot;({X}, {Y})&quot;;
    }

    // Reference type class
    public class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public Person(string name, int age) { Name = name; Age = age; }
        public override string ToString() =&gt; $&quot;{Name}, {Age}&quot;;
    }

    public static void Main()
    {
        Console.WriteLine(&quot;=== Value Type Behavior ===&quot;);
        ValueTypeExample();

        Console.WriteLine(&quot;\n=== Reference Type Behavior ===&quot;);
        ReferenceTypeExample();

        Console.WriteLine(&quot;\n=== Boxing and Unboxing ===&quot;);
        BoxingUnboxingExample();
    }

    public static void ValueTypeExample()
    {
        // Value types - stored on stack
        int a = 10;
        int b = a;    // Copy of value
        a = 20;       // Only 'a' changes

        Console.WriteLine($&quot;a = {a}, b = {b}&quot;); // a = 20, b = 10

        // Struct example
        Point p1 = new Point(5, 10);
        Point p2 = p1;    // Copy created
        p1.X = 15;        // Only p1 changes

        Console.WriteLine($&quot;p1 = {p1}, p2 = {p2}&quot;); // p1 = (15, 10), p2 = (5, 10)
    }

    public static void ReferenceTypeExample()
    {
        // Reference types - stored on heap
        Person person1 = new Person(&quot;Alice&quot;, 25);
        Person person2 = person1;    // Copy of reference, not object
        person1.Age = 30;            // Both references point to same object

        Console.WriteLine($&quot;person1: {person1}&quot;); // Alice, 30
        Console.WriteLine($&quot;person2: {person2}&quot;); // Alice, 30 (same object)
    }

    public static void BoxingUnboxingExample()
    {
        // Boxing: Value type to object (heap allocation)
        int valueType = 42;
        object boxed = valueType;    // Boxing occurs

        Console.WriteLine($&quot;Original: {valueType}&quot;);
        Console.WriteLine($&quot;Boxed: {boxed}&quot;);

        // Unboxing: Object back to value type
        int unboxed = (int)boxed;    // Unboxing occurs
        Console.WriteLine($&quot;Unboxed: {unboxed}&quot;);
    }
}
</code></pre>
<h3 id="question-10-what-are-two-types-of-delegate-explain-each-with-an-example">Question 10: What are two types of delegate? Explain each with an example.</h3>
<h4 id="types-of-delegates-in-c">Types of Delegates in C#:</h4>
<ol>
<li><strong>Single-cast Delegate (Simple Delegate)</strong></li>
<li><strong>Multi-cast Delegate</strong></li>
</ol>
<h4 id="single-cast-delegate">1. Single-cast Delegate:</h4>
<p>A delegate that holds reference to a single method.</p>
<pre><code class="language-csharp">public class SingleCastDelegateDemo
{
    // Declare delegate type
    public delegate int CalculateDelegate(int x, int y);
    public delegate void PrintDelegate(string message);

    public static void Main()
    {
        Console.WriteLine(&quot;=== Single-cast Delegate Examples ===&quot;);

        // Create delegate instance pointing to a method
        CalculateDelegate calc = Add;

        // Call delegate
        int result = calc(10, 5);
        Console.WriteLine($&quot;Addition result: {result}&quot;);

        // Change delegate to point to different method
        calc = Multiply;
        result = calc(10, 5);
        Console.WriteLine($&quot;Multiplication result: {result}&quot;);

        // Using lambda expression
        calc = (x, y) =&gt; x / y;
        result = calc(10, 5);
        Console.WriteLine($&quot;Division result: {result}&quot;);
    }

    public static int Add(int x, int y)
    {
        Console.WriteLine($&quot;Adding {x} + {y}&quot;);
        return x + y;
    }

    public static int Multiply(int x, int y)
    {
        Console.WriteLine($&quot;Multiplying {x} * {y}&quot;);
        return x * y;
    }
}
</code></pre>
<h4 id="multi-cast-delegate">2. Multi-cast Delegate:</h4>
<p>A delegate that can hold references to multiple methods and call them in sequence.</p>
<pre><code class="language-csharp">public class MultiCastDelegateDemo
{
    public delegate void NotificationDelegate(string message);

    public static void Main()
    {
        Console.WriteLine(&quot;=== Multi-cast Delegate Examples ===&quot;);

        // Create multi-cast delegate
        NotificationDelegate notification = EmailNotification;
        notification += SmsNotification;        // Add another method
        notification += PushNotification;      // Add third method

        // Call all methods in the delegate
        Console.WriteLine(&quot;Sending notification...&quot;);
        notification(&quot;System maintenance scheduled&quot;);

        Console.WriteLine(&quot;\n--- Removing Methods ---&quot;);
        notification -= EmailNotification;    // Remove method
        notification(&quot;Emergency alert&quot;);
    }

    public static void EmailNotification(string message)
    {
        Console.WriteLine($&quot;EMAIL: {message}&quot;);
    }

    public static void SmsNotification(string message)
    {
        Console.WriteLine($&quot;SMS: {message}&quot;);
    }

    public static void PushNotification(string message)
    {
        Console.WriteLine($&quot;PUSH: {message}&quot;);
    }
}
</code></pre>
<h3 id="question-11-define-term-serialization-and-deserialization-and-write-a-program-to-write-user-input-into-file-and-display-using-stream-class">Question 11: Define term serialization and deserialization and write a program to write user input into file and display using stream class.</h3>
<h4 id="definitions">Definitions:</h4>
<ul>
<li><strong>Serialization</strong>: Converting an object's state into a format that can be stored or transmitted</li>
<li><strong>Deserialization</strong>: Converting serialized data back into an object</li>
</ul>
<h4 id="complete-program-example">Complete Program Example:</h4>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;

[Serializable]
public class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
    public string Course { get; set; }
    public double Grade { get; set; }

    public Student() { }

    public Student(int id, string name, int age, string course, double grade)
    {
        Id = id;
        Name = name;
        Age = age;
        Course = course;
        Grade = grade;
    }

    public override string ToString()
    {
        return $&quot;ID: {Id}, Name: {Name}, Age: {Age}, Course: {Course}, Grade: {Grade:F2}&quot;;
    }
}

public class SerializationDemo
{
    private static List&lt;Student&gt; students = new List&lt;Student&gt;();
    private static string jsonFilePath = @&quot;C:\temp\students.json&quot;;
    private static string textFilePath = @&quot;C:\temp\students.txt&quot;;

    public static void Main()
    {
        Directory.CreateDirectory(@&quot;C:\temp&quot;);

        bool exit = false;
        while (!exit)
        {
            Console.WriteLine(&quot;\n=== Student Management System ===&quot;);
            Console.WriteLine(&quot;1. Add Student&quot;);
            Console.WriteLine(&quot;2. Display All Students&quot;);
            Console.WriteLine(&quot;3. Save to JSON File&quot;);
            Console.WriteLine(&quot;4. Load from JSON File&quot;);
            Console.WriteLine(&quot;5. Save to Text File&quot;);
            Console.WriteLine(&quot;6. Load from Text File&quot;);
            Console.WriteLine(&quot;7. Exit&quot;);
            Console.Write(&quot;Choose option: &quot;);

            string choice = Console.ReadLine();

            switch (choice)
            {
                case &quot;1&quot;: AddStudent(); break;
                case &quot;2&quot;: DisplayStudents(); break;
                case &quot;3&quot;: SaveToJson(); break;
                case &quot;4&quot;: LoadFromJson(); break;
                case &quot;5&quot;: SaveToTextFile(); break;
                case &quot;6&quot;: LoadFromTextFile(); break;
                case &quot;7&quot;: exit = true; break;
                default: Console.WriteLine(&quot;Invalid option!&quot;); break;
            }
        }
    }

    public static void AddStudent()
    {
        try
        {
            Console.Write(&quot;Enter Student ID: &quot;);
            int id = int.Parse(Console.ReadLine());

            Console.Write(&quot;Enter Student Name: &quot;);
            string name = Console.ReadLine();

            Console.Write(&quot;Enter Student Age: &quot;);
            int age = int.Parse(Console.ReadLine());

            Console.Write(&quot;Enter Course: &quot;);
            string course = Console.ReadLine();

            Console.Write(&quot;Enter Grade (0-100): &quot;);
            double grade = double.Parse(Console.ReadLine());

            Student student = new Student(id, name, age, course, grade);
            students.Add(student);

            Console.WriteLine(&quot;Student added successfully!&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error adding student: {ex.Message}&quot;);
        }
    }

    public static void DisplayStudents()
    {
        if (students.Count == 0)
        {
            Console.WriteLine(&quot;No students found.&quot;);
            return;
        }

        Console.WriteLine(&quot;\n--- Student List ---&quot;);
        foreach (Student student in students)
        {
            Console.WriteLine(student);
        }
    }

    // JSON Serialization using System.Text.Json
    public static void SaveToJson()
    {
        try
        {
            var options = new JsonSerializerOptions { WriteIndented = true };
            string jsonString = JsonSerializer.Serialize(students, options);

            using (StreamWriter writer = new StreamWriter(jsonFilePath))
            {
                writer.Write(jsonString);
            }

            Console.WriteLine($&quot;Data saved to JSON file: {jsonFilePath}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error saving to JSON: {ex.Message}&quot;);
        }
    }

    public static void LoadFromJson()
    {
        try
        {
            if (!File.Exists(jsonFilePath))
            {
                Console.WriteLine(&quot;JSON file not found.&quot;);
                return;
            }

            string jsonString;
            using (StreamReader reader = new StreamReader(jsonFilePath))
            {
                jsonString = reader.ReadToEnd();
            }

            students = JsonSerializer.Deserialize&lt;List&lt;Student&gt;&gt;(jsonString) ?? new List&lt;Student&gt;();

            Console.WriteLine($&quot;Data loaded from JSON file. {students.Count} students loaded.&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error loading from JSON: {ex.Message}&quot;);
        }
    }

    // Custom Text File Format using StreamWriter/StreamReader
    public static void SaveToTextFile()
    {
        try
        {
            using (StreamWriter writer = new StreamWriter(textFilePath))
            {
                writer.WriteLine(&quot;# Student Data File&quot;);
                writer.WriteLine($&quot;# Generated on: {DateTime.Now}&quot;);
                writer.WriteLine($&quot;# Total Students: {students.Count}&quot;);
                writer.WriteLine(&quot;# Format: ID|Name|Age|Course|Grade&quot;);
                writer.WriteLine(&quot;---DATA---&quot;);

                foreach (Student student in students)
                {
                    writer.WriteLine($&quot;{student.Id}|{student.Name}|{student.Age}|{student.Course}|{student.Grade}&quot;);
                }

                writer.WriteLine(&quot;---END---&quot;);
            }

            Console.WriteLine($&quot;Data saved to text file: {textFilePath}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error saving to text file: {ex.Message}&quot;);
        }
    }

    public static void LoadFromTextFile()
    {
        try
        {
            if (!File.Exists(textFilePath))
            {
                Console.WriteLine(&quot;Text file not found.&quot;);
                return;
            }

            students.Clear();
            bool dataSection = false;

            using (StreamReader reader = new StreamReader(textFilePath))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    if (line == &quot;---DATA---&quot;)
                    {
                        dataSection = true;
                        continue;
                    }

                    if (line == &quot;---END---&quot;)
                    {
                        break;
                    }

                    if (dataSection &amp;&amp; !line.StartsWith(&quot;#&quot;))
                    {
                        string[] parts = line.Split('|');
                        if (parts.Length == 5)
                        {
                            Student student = new Student
                            {
                                Id = int.Parse(parts[0]),
                                Name = parts[1],
                                Age = int.Parse(parts[2]),
                                Course = parts[3],
                                Grade = double.Parse(parts[4])
                            };
                            students.Add(student);
                        }
                    }
                }
            }

            Console.WriteLine($&quot;Data loaded from text file. {students.Count} students loaded.&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error loading from text file: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h3 id="question-12-what-is-tpl-and-write-a-program-to-create-multiple-threads-along-with-main-thread">Question 12: What is TPL? And write a program to create multiple threads along with main thread.</h3>
<h4 id="tpl-task-parallel-library">TPL (Task Parallel Library):</h4>
<p>TPL is a set of public types and APIs in the System.Threading and System.Threading.Tasks namespaces that simplifies the process of adding parallelism and concurrency to applications.</p>
<p><strong>Benefits of TPL:</strong></p>
<ul>
<li>Simplified thread management</li>
<li>Automatic work distribution</li>
<li>Better performance on multi-core systems</li>
<li>Built-in cancellation support</li>
<li>Exception handling across threads</li>
</ul>
<h4 id="complete-program-example-1">Complete Program Example:</h4>
<pre><code class="language-csharp">using System;
using System.Threading;
using System.Threading.Tasks;

public class TPLDemo
{
    public static void Main()
    {
        Console.WriteLine($&quot;Main thread ID: {Thread.CurrentThread.ManagedThreadId}&quot;);
        Console.WriteLine(&quot;=== TPL (Task Parallel Library) Demo ===\n&quot;);

        // 1. Basic Task creation
        BasicTaskExample();

        // 2. Multiple tasks
        MultipleTasksExample();

        // 3. Task with return values
        TaskWithReturnValueExample();

        // 4. Parallel loops
        ParallelLoopsExample();

        // 5. Task continuation
        TaskContinuationExample();

        Console.WriteLine($&quot;\nMain thread {Thread.CurrentThread.ManagedThreadId} completed.&quot;);
    }

    public static void BasicTaskExample()
    {
        Console.WriteLine(&quot;1. Basic Task Example:&quot;);

        // Create and start a task
        Task task1 = Task.Run(() =&gt;
        {
            Console.WriteLine($&quot;Task 1 running on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            Thread.Sleep(2000);
            Console.WriteLine(&quot;Task 1 completed&quot;);
        });

        // Wait for task to complete
        task1.Wait();
        Console.WriteLine(&quot;Basic task example finished\n&quot;);
    }

    public static void MultipleTasksExample()
    {
        Console.WriteLine(&quot;2. Multiple Tasks Example:&quot;);

        // Create multiple tasks
        Task[] tasks = new Task[5];

        for (int i = 0; i &lt; 5; i++)
        {
            int taskId = i + 1; // Capture loop variable
            tasks[i] = Task.Run(() =&gt;
            {
                Console.WriteLine($&quot;Task {taskId} started on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
                Thread.Sleep(1000 * taskId); // Different sleep times
                Console.WriteLine($&quot;Task {taskId} completed&quot;);
            });
        }

        // Wait for all tasks to complete
        Task.WaitAll(tasks);
        Console.WriteLine(&quot;All tasks completed\n&quot;);
    }

    public static void TaskWithReturnValueExample()
    {
        Console.WriteLine(&quot;3. Task with Return Values:&quot;);

        // Tasks that return values
        Task&lt;int&gt;[] calculationTasks = new Task&lt;int&gt;[3];

        calculationTasks[0] = Task.Run(() =&gt;
        {
            Console.WriteLine($&quot;Calculating factorial on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            return CalculateFactorial(5);
        });

        calculationTasks[1] = Task.Run(() =&gt;
        {
            Console.WriteLine($&quot;Calculating sum on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            return CalculateSum(1, 100);
        });

        calculationTasks[2] = Task.Run(() =&gt;
        {
            Console.WriteLine($&quot;Calculating power on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            return CalculatePower(2, 10);
        });

        // Wait for all tasks and get results
        Task.WaitAll(calculationTasks);

        Console.WriteLine($&quot;Factorial result: {calculationTasks[0].Result}&quot;);
        Console.WriteLine($&quot;Sum result: {calculationTasks[1].Result}&quot;);
        Console.WriteLine($&quot;Power result: {calculationTasks[2].Result}\n&quot;);
    }

    public static void ParallelLoopsExample()
    {
        Console.WriteLine(&quot;4. Parallel Loops Example:&quot;);

        // Parallel.For example
        Console.WriteLine(&quot;Parallel.For processing:&quot;);
        Parallel.For(1, 6, i =&gt;
        {
            Console.WriteLine($&quot;Processing item {i} on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            Thread.Sleep(500);
        });

        // Parallel.ForEach example
        Console.WriteLine(&quot;\nParallel.ForEach processing:&quot;);
        string[] data = { &quot;File1.txt&quot;, &quot;File2.txt&quot;, &quot;File3.txt&quot;, &quot;File4.txt&quot; };

        Parallel.ForEach(data, file =&gt;
        {
            Console.WriteLine($&quot;Processing {file} on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            Thread.Sleep(800);
            Console.WriteLine($&quot;Completed {file}&quot;);
        });

        Console.WriteLine(&quot;Parallel loops completed\n&quot;);
    }

    public static void TaskContinuationExample()
    {
        Console.WriteLine(&quot;5. Task Continuation Example:&quot;);

        Task&lt;string&gt; downloadTask = Task.Run(() =&gt;
        {
            Console.WriteLine($&quot;Downloading data on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            Thread.Sleep(2000);
            return &quot;Downloaded data content&quot;;
        });

        Task processTask = downloadTask.ContinueWith(antecedent =&gt;
        {
            Console.WriteLine($&quot;Processing data on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
            string data = antecedent.Result;
            Console.WriteLine($&quot;Processing: {data}&quot;);
            Thread.Sleep(1000);
            Console.WriteLine(&quot;Data processing completed&quot;);
        });

        // Wait for the continuation task
        processTask.Wait();
        Console.WriteLine(&quot;Task continuation example completed\n&quot;);
    }

    // Helper methods for calculations
    public static int CalculateFactorial(int n)
    {
        Thread.Sleep(1000); // Simulate work
        if (n &lt;= 1) return 1;
        return n * CalculateFactorial(n - 1);
    }

    public static int CalculateSum(int start, int end)
    {
        Thread.Sleep(1000); // Simulate work
        int sum = 0;
        for (int i = start; i &lt;= end; i++)
        {
            sum += i;
        }
        return sum;
    }

    public static int CalculatePower(int baseNum, int exponent)
    {
        Thread.Sleep(1000); // Simulate work
        return (int)Math.Pow(baseNum, exponent);
    }
}

// Advanced TPL example with cancellation
public class AdvancedTPLDemo
{
    public static void CancellationExample()
    {
        Console.WriteLine(&quot;=== Cancellation Example ===&quot;);

        CancellationTokenSource cts = new CancellationTokenSource();

        // Start a long-running task
        Task longRunningTask = Task.Run(() =&gt;
        {
            for (int i = 1; i &lt;= 10; i++)
            {
                // Check for cancellation
                cts.Token.ThrowIfCancellationRequested();

                Console.WriteLine($&quot;Working... Step {i}/10 on thread {Thread.CurrentThread.ManagedThreadId}&quot;);
                Thread.Sleep(1000);
            }
        }, cts.Token);

        // Cancel after 3 seconds
        cts.CancelAfter(3000);

        try
        {
            longRunningTask.Wait();
            Console.WriteLine(&quot;Task completed successfully&quot;);
        }
        catch (AggregateException ex)
        {
            if (ex.InnerException is OperationCanceledException)
            {
                Console.WriteLine(&quot;Task was cancelled&quot;);
            }
        }
    }

    public static void ExceptionHandlingExample()
    {
        Console.WriteLine(&quot;=== Exception Handling Example ===&quot;);

        Task[] tasks = new Task[3];

        tasks[0] = Task.Run(() =&gt;
        {
            Console.WriteLine(&quot;Task 1: Running normally&quot;);
            Thread.Sleep(1000);
        });

        tasks[1] = Task.Run(() =&gt;
        {
            Console.WriteLine(&quot;Task 2: About to throw exception&quot;);
            throw new InvalidOperationException(&quot;Something went wrong in Task 2&quot;);
        });

        tasks[2] = Task.Run(() =&gt;
        {
            Console.WriteLine(&quot;Task 3: Running normally&quot;);
            Thread.Sleep(1500);
        });

        try
        {
            Task.WaitAll(tasks);
        }
        catch (AggregateException ex)
        {
            Console.WriteLine($&quot;Caught {ex.InnerExceptions.Count} exceptions:&quot;);
            foreach (var innerEx in ex.InnerExceptions)
            {
                Console.WriteLine($&quot;- {innerEx.Message}&quot;);
            }
        }
    }
}
</code></pre>
<p>}</p>
<pre><code>
### Question 13: Provided that a MSSQL database named &quot;LibraryDb&quot; with table named &quot;Books&quot; with following columns (Id as int, ISBN as varchar(20), Title as varchar(200), Publication Date as DateTime). Write a C# program to connect to the database and insert as many books as user wants, and finally display all the books in db. Explain the difference between ExecuteReader and ExecuteNonQuery.

#### Complete Library Management Program:

```csharp
using System;
using System.Data;
using System.Data.SqlClient;

public class LibraryManagement
{
    private static string connectionString = &quot;Server=localhost;Database=LibraryDb;Integrated Security=true;&quot;;

    public static void Main()
    {
        try
        {
            CreateDatabaseAndTable();

            bool continueAdding = true;
            while (continueAdding)
            {
                AddBook();

                Console.Write(&quot;Do you want to add another book? (y/n): &quot;);
                string response = Console.ReadLine().ToLower();
                continueAdding = (response == &quot;y&quot; || response == &quot;yes&quot;);
            }

            DisplayAllBooks();
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }

    public static void CreateDatabaseAndTable()
    {
        string createTableQuery = @&quot;
            IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='Books' AND xtype='U')
            CREATE TABLE Books (
                Id INT PRIMARY KEY IDENTITY(1,1),
                ISBN VARCHAR(20) NOT NULL,
                Title VARCHAR(200) NOT NULL,
                PublicationDate DATETIME NOT NULL
            )&quot;;

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(createTableQuery, connection))
                {
                    command.ExecuteNonQuery(); // Uses ExecuteNonQuery for CREATE TABLE
                    Console.WriteLine(&quot;Database table 'Books' created/verified successfully.&quot;);
                }
            }
            catch (SqlException ex)
            {
                Console.WriteLine($&quot;Database error: {ex.Message}&quot;);
            }
        }
    }

    public static void AddBook()
    {
        try
        {
            Console.WriteLine(&quot;\n--- Add New Book ---&quot;);

            Console.Write(&quot;Enter ISBN: &quot;);
            string isbn = Console.ReadLine();

            Console.Write(&quot;Enter Title: &quot;);
            string title = Console.ReadLine();

            Console.Write(&quot;Enter Publication Date (yyyy-mm-dd): &quot;);
            DateTime publicationDate = DateTime.Parse(Console.ReadLine());

            string insertQuery = @&quot;
                INSERT INTO Books (ISBN, Title, PublicationDate)
                VALUES (@ISBN, @Title, @PublicationDate)&quot;;

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(insertQuery, connection))
                {
                    // Add parameters to prevent SQL injection
                    command.Parameters.AddWithValue(&quot;@ISBN&quot;, isbn);
                    command.Parameters.AddWithValue(&quot;@Title&quot;, title);
                    command.Parameters.AddWithValue(&quot;@PublicationDate&quot;, publicationDate);

                    int rowsAffected = command.ExecuteNonQuery(); // Uses ExecuteNonQuery for INSERT
                    Console.WriteLine($&quot;Book added successfully! ({rowsAffected} row(s) affected)&quot;);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error adding book: {ex.Message}&quot;);
        }
    }

    public static void DisplayAllBooks()
    {
        string selectQuery = &quot;SELECT Id, ISBN, Title, PublicationDate FROM Books ORDER BY Id&quot;;

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(selectQuery, connection))
                {
                    using (SqlDataReader reader = command.ExecuteReader()) // Uses ExecuteReader for SELECT
                    {
                        Console.WriteLine(&quot;\n--- All Books in Library ---&quot;);
                        Console.WriteLine($&quot;{&quot;ID&quot;,-5} {&quot;ISBN&quot;,-15} {&quot;Title&quot;,-30} {&quot;Publication Date&quot;,-15}&quot;);
                        Console.WriteLine(new string('-', 70));

                        while (reader.Read())
                        {
                            Console.WriteLine($&quot;{reader[&quot;Id&quot;],-5} &quot; +
                                            $&quot;{reader[&quot;ISBN&quot;],-15} &quot; +
                                            $&quot;{reader[&quot;Title&quot;],-30} &quot; +
                                            $&quot;{((DateTime)reader[&quot;PublicationDate&quot;]).ToString(&quot;yyyy-MM-dd&quot;),-15}&quot;);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($&quot;Error displaying books: {ex.Message}&quot;);
            }
        }
    }

    // Additional methods to demonstrate ExecuteReader vs ExecuteNonQuery
    public static void DemonstrateExecuteMethods()
    {
        Console.WriteLine(&quot;\n=== ExecuteReader vs ExecuteNonQuery Demo ===&quot;);

        // ExecuteNonQuery examples
        ExecuteNonQueryExamples();

        // ExecuteReader examples
        ExecuteReaderExamples();
    }

    public static void ExecuteNonQueryExamples()
    {
        Console.WriteLine(&quot;\nExecuteNonQuery Examples:&quot;);

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // INSERT example
            string insertQuery = &quot;INSERT INTO Books (ISBN, Title, PublicationDate) VALUES ('123-456', 'Test Book', '2023-01-01')&quot;;
            using (SqlCommand command = new SqlCommand(insertQuery, connection))
            {
                int rowsAffected = command.ExecuteNonQuery();
                Console.WriteLine($&quot;INSERT: {rowsAffected} row(s) affected&quot;);
            }

            // UPDATE example
            string updateQuery = &quot;UPDATE Books SET Title = 'Updated Test Book' WHERE ISBN = '123-456'&quot;;
            using (SqlCommand command = new SqlCommand(updateQuery, connection))
            {
                int rowsAffected = command.ExecuteNonQuery();
                Console.WriteLine($&quot;UPDATE: {rowsAffected} row(s) affected&quot;);
            }

            // DELETE example
            string deleteQuery = &quot;DELETE FROM Books WHERE ISBN = '123-456'&quot;;
            using (SqlCommand command = new SqlCommand(deleteQuery, connection))
            {
                int rowsAffected = command.ExecuteNonQuery();
                Console.WriteLine($&quot;DELETE: {rowsAffected} row(s) affected&quot;);
            }
        }
    }

    public static void ExecuteReaderExamples()
    {
        Console.WriteLine(&quot;\nExecuteReader Examples:&quot;);

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // SELECT with specific columns
            string selectQuery = &quot;SELECT TOP 3 ISBN, Title FROM Books&quot;;
            using (SqlCommand command = new SqlCommand(selectQuery, connection))
            {
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    Console.WriteLine(&quot;Top 3 Books (ISBN and Title only):&quot;);
                    while (reader.Read())
                    {
                        Console.WriteLine($&quot;ISBN: {reader[&quot;ISBN&quot;]}, Title: {reader[&quot;Title&quot;]}&quot;);
                    }
                }
            }
        }
    }
}
</code></pre>
<h4 id="executereader-vs-executenonquery">ExecuteReader vs ExecuteNonQuery:</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>ExecuteReader</th>
<th>ExecuteNonQuery</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Purpose</strong></td>
<td>Retrieve data from database</td>
<td>Execute commands that don't return data</td>
</tr>
<tr>
<td><strong>Return Type</strong></td>
<td>SqlDataReader</td>
<td>int (rows affected)</td>
</tr>
<tr>
<td><strong>Used For</strong></td>
<td>SELECT statements</td>
<td>INSERT, UPDATE, DELETE, CREATE, DROP</td>
</tr>
<tr>
<td><strong>Data Access</strong></td>
<td>Forward-only, read-only data stream</td>
<td>Number of affected rows</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Efficient for large datasets</td>
<td>Fast for modification operations</td>
</tr>
<tr>
<td><strong>Connection</strong></td>
<td>Keeps connection open while reading</td>
<td>Releases connection immediately</td>
</tr>
</tbody>
</table>
<p><strong>Examples:</strong></p>
<pre><code class="language-csharp">// ExecuteReader - for SELECT statements
using (SqlDataReader reader = command.ExecuteReader())
{
    while (reader.Read())
    {
        // Read data row by row
        string title = reader[&quot;Title&quot;].ToString();
    }
}

// ExecuteNonQuery - for INSERT, UPDATE, DELETE
int rowsAffected = command.ExecuteNonQuery();
Console.WriteLine($&quot;{rowsAffected} rows were modified&quot;);
</code></pre>
<h3 id="question-14-write-c-code-for-downloading-web-page-from-a-web-server-e.g.httpmyblog.com.np">Question 14: Write C# code for downloading web page from a web server e.g. <a href="http://myblog.com.np/">http://myblog.com.np/</a></h3>
<pre><code class="language-csharp">using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

public class WebPageDownloader
{
    public static async Task Main()
    {
        Console.WriteLine(&quot;=== Web Page Downloader ===&quot;);

        // Method 1: Using HttpClient (Recommended - Modern approach)
        await DownloadWithHttpClient();

        // Method 2: Using WebClient (Legacy approach)
        DownloadWithWebClient();

        // Method 3: Download and save to file
        await DownloadAndSaveToFile();

        // Method 4: Download with custom headers
        await DownloadWithCustomHeaders();
    }

    // Method 1: Modern approach using HttpClient
    public static async Task DownloadWithHttpClient()
    {
        Console.WriteLine(&quot;\n1. Downloading with HttpClient:&quot;);

        string url = &quot;http://myblog.com.np/&quot;;

        try
        {
            using (HttpClient client = new HttpClient())
            {
                // Set timeout
                client.Timeout = TimeSpan.FromSeconds(30);

                // Download the web page
                string content = await client.GetStringAsync(url);

                Console.WriteLine($&quot;Successfully downloaded {content.Length} characters&quot;);
                Console.WriteLine(&quot;First 200 characters:&quot;);
                Console.WriteLine(content.Substring(0, Math.Min(200, content.Length)));
                Console.WriteLine(&quot;...&quot;);
            }
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($&quot;HTTP Error: {ex.Message}&quot;);
        }
        catch (TaskCanceledException ex)
        {
            Console.WriteLine($&quot;Timeout Error: {ex.Message}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;General Error: {ex.Message}&quot;);
        }
    }

    // Method 2: Legacy approach using WebClient
    public static void DownloadWithWebClient()
    {
        Console.WriteLine(&quot;\n2. Downloading with WebClient:&quot;);

        string url = &quot;http://myblog.com.np/&quot;;

        try
        {
            using (System.Net.WebClient client = new System.Net.WebClient())
            {
                // Set encoding
                client.Encoding = Encoding.UTF8;

                // Add user agent to avoid blocking
                client.Headers.Add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&quot;);

                // Download the web page
                string content = client.DownloadString(url);

                Console.WriteLine($&quot;Successfully downloaded {content.Length} characters&quot;);
                Console.WriteLine(&quot;First 200 characters:&quot;);
                Console.WriteLine(content.Substring(0, Math.Min(200, content.Length)));
                Console.WriteLine(&quot;...&quot;);
            }
        }
        catch (System.Net.WebException ex)
        {
            Console.WriteLine($&quot;Web Error: {ex.Message}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;General Error: {ex.Message}&quot;);
        }
    }

    // Method 3: Download and save to file
    public static async Task DownloadAndSaveToFile()
    {
        Console.WriteLine(&quot;\n3. Downloading and saving to file:&quot;);

        string url = &quot;http://myblog.com.np/&quot;;
        string fileName = &quot;downloaded_webpage.html&quot;;

        try
        {
            using (HttpClient client = new HttpClient())
            {
                // Download content
                string content = await client.GetStringAsync(url);

                // Save to file
                await File.WriteAllTextAsync(fileName, content, Encoding.UTF8);

                Console.WriteLine($&quot;Web page saved to: {fileName}&quot;);
                Console.WriteLine($&quot;File size: {new FileInfo(fileName).Length} bytes&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }

    // Method 4: Download with custom headers and detailed response info
    public static async Task DownloadWithCustomHeaders()
    {
        Console.WriteLine(&quot;\n4. Downloading with custom headers:&quot;);

        string url = &quot;http://myblog.com.np/&quot;;

        try
        {
            using (HttpClient client = new HttpClient())
            {
                // Add custom headers
                client.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, &quot;C# Web Downloader v1.0&quot;);
                client.DefaultRequestHeaders.Add(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml&quot;);

                // Get full response (not just content)
                HttpResponseMessage response = await client.GetAsync(url);

                Console.WriteLine($&quot;Status Code: {response.StatusCode}&quot;);
                Console.WriteLine($&quot;Content Type: {response.Content.Headers.ContentType}&quot;);
                Console.WriteLine($&quot;Content Length: {response.Content.Headers.ContentLength}&quot;);

                // Check if successful
                if (response.IsSuccessStatusCode)
                {
                    string content = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($&quot;Successfully downloaded {content.Length} characters&quot;);

                    // Display response headers
                    Console.WriteLine(&quot;\nResponse Headers:&quot;);
                    foreach (var header in response.Headers)
                    {
                        Console.WriteLine($&quot;{header.Key}: {string.Join(&quot;, &quot;, header.Value)}&quot;);
                    }
                }
                else
                {
                    Console.WriteLine($&quot;Failed to download: {response.ReasonPhrase}&quot;);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }

    // Bonus: Download multiple pages concurrently
    public static async Task DownloadMultiplePages()
    {
        Console.WriteLine(&quot;\n5. Downloading multiple pages concurrently:&quot;);

        string[] urls = {
            &quot;http://myblog.com.np/&quot;,
            &quot;http://google.com/&quot;,
            &quot;http://github.com/&quot;
        };

        using (HttpClient client = new HttpClient())
        {
            // Create tasks for all downloads
            Task&lt;string&gt;[] downloadTasks = new Task&lt;string&gt;[urls.Length];

            for (int i = 0; i &lt; urls.Length; i++)
            {
                string url = urls[i];
                downloadTasks[i] = client.GetStringAsync(url);
            }

            try
            {
                // Wait for all downloads to complete
                string[] results = await Task.WhenAll(downloadTasks);

                for (int i = 0; i &lt; urls.Length; i++)
                {
                    Console.WriteLine($&quot;{urls[i]}: {results[i].Length} characters downloaded&quot;);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($&quot;Error in concurrent downloads: {ex.Message}&quot;);
            }
        }
    }
}

// Alternative implementation with more error handling
public class RobustWebDownloader
{
    private static readonly HttpClient httpClient = new HttpClient();

    static RobustWebDownloader()
    {
        // Configure HttpClient
        httpClient.Timeout = TimeSpan.FromSeconds(30);
        httpClient.DefaultRequestHeaders.Add(&quot;User-Agent&quot;,
            &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&quot;);
    }

    public static async Task&lt;string&gt; DownloadWebPageAsync(string url)
    {
        try
        {
            Console.WriteLine($&quot;Downloading: {url}&quot;);

            using (HttpResponseMessage response = await httpClient.GetAsync(url))
            {
                response.EnsureSuccessStatusCode();
                string content = await response.Content.ReadAsStringAsync();

                Console.WriteLine($&quot;Download completed: {content.Length} characters&quot;);
                return content;
            }
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($&quot;HTTP request failed: {ex.Message}&quot;);
            return null;
        }
        catch (TaskCanceledException ex)
        {
            Console.WriteLine($&quot;Request timed out: {ex.Message}&quot;);
            return null;
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Unexpected error: {ex.Message}&quot;);
            return null;
        }
    }

    public static async Task&lt;bool&gt; DownloadToFileAsync(string url, string fileName)
    {
        try
        {
            string content = await DownloadWebPageAsync(url);
            if (content != null)
            {
                await File.WriteAllTextAsync(fileName, content, Encoding.UTF8);
                Console.WriteLine($&quot;Content saved to: {fileName}&quot;);
                return true;
            }
            return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error saving to file: {ex.Message}&quot;);
            return false;
        }
    }
}
</code></pre>
<h3 id="question-15-write-a-c-program-to-inherit-a-class-box-with-properties-length-breadth-and-height.class-box-should-have-a-read-only-property-named-volume.also-add-a-method-to-display-the-properties-in-the-console">Question 15: Write a C# program to inherit a class BOX with properties Length, Breadth and Height. Class Box should have a read-only property named volume. Also add a method to display the properties in the console.</h3>
<pre><code class="language-csharp">using System;

// Base class Box
public class Box
{
    // Protected fields - accessible to derived classes
    protected double length;
    protected double breadth;
    protected double height;

    // Default constructor
    public Box()
    {
        length = 0;
        breadth = 0;
        height = 0;
    }

    // Parameterized constructor
    public Box(double length, double breadth, double height)
    {
        this.length = length;
        this.breadth = breadth;
        this.height = height;
    }

    // Properties with validation
    public double Length
    {
        get { return length; }
        set
        {
            if (value &gt;= 0)
                length = value;
            else
                throw new ArgumentException(&quot;Length cannot be negative&quot;);
        }
    }

    public double Breadth
    {
        get { return breadth; }
        set
        {
            if (value &gt;= 0)
                breadth = value;
            else
                throw new ArgumentException(&quot;Breadth cannot be negative&quot;);
        }
    }

    public double Height
    {
        get { return height; }
        set
        {
            if (value &gt;= 0)
                height = value;
            else
                throw new ArgumentException(&quot;Height cannot be negative&quot;);
        }
    }

    // Read-only property for Volume
    public virtual double Volume
    {
        get { return length * breadth * height; }
    }

    // Virtual method to display properties (can be overridden)
    public virtual void DisplayProperties()
    {
        Console.WriteLine(&quot;=== Box Properties ===&quot;);
        Console.WriteLine($&quot;Length: {length:F2}&quot;);
        Console.WriteLine($&quot;Breadth: {breadth:F2}&quot;);
        Console.WriteLine($&quot;Height: {height:F2}&quot;);
        Console.WriteLine($&quot;Volume: {Volume:F2}&quot;);
        Console.WriteLine(&quot;=====================&quot;);
    }

    // Method to calculate surface area
    public virtual double GetSurfaceArea()
    {
        return 2 * (length * breadth + breadth * height + height * length);
    }
}

// Derived class - Cube (inherits from Box)
public class Cube : Box
{
    // Constructor for cube (all sides equal)
    public Cube(double side) : base(side, side, side)
    {
    }

    // Property for side (all dimensions are equal in a cube)
    public double Side
    {
        get { return length; }
        set
        {
            if (value &gt;= 0)
            {
                length = breadth = height = value;
            }
            else
            {
                throw new ArgumentException(&quot;Side cannot be negative&quot;);
            }
        }
    }

    // Override display method for cube-specific output
    public override void DisplayProperties()
    {
        Console.WriteLine(&quot;=== Cube Properties ===&quot;);
        Console.WriteLine($&quot;Side: {length:F2}&quot;);
        Console.WriteLine($&quot;Volume: {Volume:F2}&quot;);
        Console.WriteLine($&quot;Surface Area: {GetSurfaceArea():F2}&quot;);
        Console.WriteLine(&quot;======================&quot;);
    }
}

// Derived class - Rectangular Box with additional features
public class RectangularBox : Box
{
    private string material;
    private double weight;

    public RectangularBox(double length, double breadth, double height, string material = &quot;Cardboard&quot;)
        : base(length, breadth, height)
    {
        this.material = material;
        this.weight = 0;
    }

    public string Material
    {
        get { return material; }
        set { material = value ?? &quot;Unknown&quot;; }
    }

    public double Weight
    {
        get { return weight; }
        set
        {
            if (value &gt;= 0)
                weight = value;
            else
                throw new ArgumentException(&quot;Weight cannot be negative&quot;);
        }
    }

    // Calculate density (weight per unit volume)
    public double Density
    {
        get
        {
            return Volume &gt; 0 ? weight / Volume : 0;
        }
    }

    // Override display method
    public override void DisplayProperties()
    {
        Console.WriteLine(&quot;=== Rectangular Box Properties ===&quot;);
        Console.WriteLine($&quot;Length: {length:F2}&quot;);
        Console.WriteLine($&quot;Breadth: {breadth:F2}&quot;);
        Console.WriteLine($&quot;Height: {height:F2}&quot;);
        Console.WriteLine($&quot;Volume: {Volume:F2}&quot;);
        Console.WriteLine($&quot;Surface Area: {GetSurfaceArea():F2}&quot;);
        Console.WriteLine($&quot;Material: {material}&quot;);
        Console.WriteLine($&quot;Weight: {weight:F2}&quot;);
        Console.WriteLine($&quot;Density: {Density:F4}&quot;);
        Console.WriteLine(&quot;=================================&quot;);
    }
}

// Another derived class - Gift Box
public class GiftBox : Box
{
    private string color;
    private bool hasRibbon;
    private string giftMessage;

    public GiftBox(double length, double breadth, double height, string color = &quot;Red&quot;)
        : base(length, breadth, height)
    {
        this.color = color;
        this.hasRibbon = false;
        this.giftMessage = &quot;&quot;;
    }

    public string Color
    {
        get { return color; }
        set { color = value ?? &quot;Unknown&quot;; }
    }

    public bool HasRibbon
    {
        get { return hasRibbon; }
        set { hasRibbon = value; }
    }

    public string GiftMessage
    {
        get { return giftMessage; }
        set { giftMessage = value ?? &quot;&quot;; }
    }

    // Calculate wrapping paper needed (with some extra)
    public double WrappingPaperNeeded
    {
        get { return GetSurfaceArea() * 1.2; } // 20% extra for overlap
    }

    public override void DisplayProperties()
    {
        Console.WriteLine(&quot;=== Gift Box Properties ===&quot;);
        Console.WriteLine($&quot;Dimensions: {length:F2} x {breadth:F2} x {height:F2}&quot;);
        Console.WriteLine($&quot;Volume: {Volume:F2}&quot;);
        Console.WriteLine($&quot;Color: {color}&quot;);
        Console.WriteLine($&quot;Has Ribbon: {(hasRibbon ? &quot;Yes&quot; : &quot;No&quot;)}&quot;);
        Console.WriteLine($&quot;Gift Message: {(string.IsNullOrEmpty(giftMessage) ? &quot;None&quot; : giftMessage)}&quot;);
        Console.WriteLine($&quot;Wrapping Paper Needed: {WrappingPaperNeeded:F2}&quot;);
        Console.WriteLine(&quot;===========================&quot;);
    }
}

// Main program to demonstrate inheritance
public class BoxInheritanceDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Box Inheritance Demonstration ===\n&quot;);

        try
        {
            // Create base Box object
            Console.WriteLine(&quot;1. Basic Box:&quot;);
            Box basicBox = new Box(10, 8, 6);
            basicBox.DisplayProperties();

            // Create Cube object
            Console.WriteLine(&quot;\n2. Cube:&quot;);
            Cube cube = new Cube(5);
            cube.DisplayProperties();

            // Create Rectangular Box
            Console.WriteLine(&quot;\n3. Rectangular Box:&quot;);
            RectangularBox rectBox = new RectangularBox(12, 8, 4, &quot;Wood&quot;);
            rectBox.Weight = 2.5;
            rectBox.DisplayProperties();

            // Create Gift Box
            Console.WriteLine(&quot;\n4. Gift Box:&quot;);
            GiftBox giftBox = new GiftBox(15, 10, 8, &quot;Blue&quot;);
            giftBox.HasRibbon = true;
            giftBox.GiftMessage = &quot;Happy Birthday!&quot;;
            giftBox.DisplayProperties();

            // Demonstrate polymorphism
            Console.WriteLine(&quot;\n5. Polymorphism Demo:&quot;);
            DemonstratePolymorphism();

            // Interactive box creation
            Console.WriteLine(&quot;\n6. Create Your Own Box:&quot;);
            CreateInteractiveBox();
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($&quot;Validation Error: {ex.Message}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }

    public static void DemonstratePolymorphism()
    {
        // Array of Box references pointing to different derived objects
        Box[] boxes = {
            new Box(5, 4, 3),
            new Cube(4),
            new RectangularBox(6, 5, 4, &quot;Plastic&quot;),
            new GiftBox(8, 6, 5, &quot;Green&quot;)
        };

        Console.WriteLine(&quot;Processing different box types polymorphically:&quot;);
        foreach (Box box in boxes)
        {
            Console.WriteLine($&quot;Box type: {box.GetType().Name}&quot;);
            Console.WriteLine($&quot;Volume: {box.Volume:F2}&quot;);
            Console.WriteLine($&quot;Surface Area: {box.GetSurfaceArea():F2}&quot;);
            Console.WriteLine(&quot;---&quot;);
        }
    }

    public static void CreateInteractiveBox()
    {
        try
        {
            Console.Write(&quot;Enter length: &quot;);
            double length = double.Parse(Console.ReadLine());

            Console.Write(&quot;Enter breadth: &quot;);
            double breadth = double.Parse(Console.ReadLine());

            Console.Write(&quot;Enter height: &quot;);
            double height = double.Parse(Console.ReadLine());

            Box userBox = new Box(length, breadth, height);

            Console.WriteLine(&quot;\nYour custom box:&quot;);
            userBox.DisplayProperties();

            // Modify properties
            Console.Write(&quot;Want to modify length? (y/n): &quot;);
            if (Console.ReadLine().ToLower() == &quot;y&quot;)
            {
                Console.Write(&quot;Enter new length: &quot;);
                userBox.Length = double.Parse(Console.ReadLine());

                Console.WriteLine(&quot;\nUpdated box:&quot;);
                userBox.DisplayProperties();
            }
        }
        catch (FormatException)
        {
            Console.WriteLine(&quot;Invalid input format. Please enter numeric values.&quot;);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($&quot;Invalid value: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h3 id="question-16-what-is-event-in-c-explain-briefly-about-event-source-and-event-listener.how-are-delegate-and-event-related">Question 16: What is event in C#? Explain briefly about event source and event listener. How are delegate and event related?</h3>
<h4 id="what-is-an-event-1">What is an Event?</h4>
<p>An <strong>event</strong> in C# is a special kind of multicast delegate that provides notifications when something of interest happens. Events follow the publisher-subscriber pattern where:</p>
<ul>
<li><strong>Event Source (Publisher)</strong>: The class that raises the event</li>
<li><strong>Event Listener (Subscriber)</strong>: The class that handles the event</li>
</ul>
<h4 id="event-source-and-event-listener">Event Source and Event Listener:</h4>
<pre><code class="language-csharp">using System;

// Event arguments class
public class TemperatureChangedEventArgs : EventArgs
{
    public double OldTemperature { get; }
    public double NewTemperature { get; }
    public DateTime TimeStamp { get; }

    public TemperatureChangedEventArgs(double oldTemp, double newTemp)
    {
        OldTemperature = oldTemp;
        NewTemperature = newTemp;
        TimeStamp = DateTime.Now;
    }
}

// Event Source (Publisher)
public class TemperatureSensor
{
    private double temperature;

    // Declare event using delegate
    public event EventHandler&lt;TemperatureChangedEventArgs&gt; TemperatureChanged;

    public double Temperature
    {
        get { return temperature; }
        set
        {
            if (Math.Abs(temperature - value) &gt; 0.1) // Only fire if significant change
            {
                double oldTemp = temperature;
                temperature = value;
                OnTemperatureChanged(oldTemp, temperature);
            }
        }
    }

    // Protected virtual method to raise the event
    protected virtual void OnTemperatureChanged(double oldTemp, double newTemp)
    {
        TemperatureChanged?.Invoke(this, new TemperatureChangedEventArgs(oldTemp, newTemp));
    }

    // Method to simulate temperature reading
    public void StartMonitoring()
    {
        Console.WriteLine(&quot;Temperature monitoring started...&quot;);
        Random random = new Random();

        for (int i = 0; i &lt; 10; i++)
        {
            Temperature = 20 + random.NextDouble() * 15; // Random temp between 20-35
            System.Threading.Thread.Sleep(1000);
        }
    }
}

// Event Listeners (Subscribers)
public class TemperatureDisplay
{
    private string deviceName;

    public TemperatureDisplay(string name)
    {
        deviceName = name;
    }

    // Event handler method
    public void OnTemperatureChanged(object sender, TemperatureChangedEventArgs e)
    {
        Console.WriteLine($&quot;[{deviceName}] Temperature changed from {e.OldTemperature:F1}Â°C to {e.NewTemperature:F1}Â°C at {e.TimeStamp:HH:mm:ss}&quot;);
    }
}

public class TemperatureAlarm
{
    private double alertThreshold;

    public TemperatureAlarm(double threshold)
    {
        alertThreshold = threshold;
    }

    public void OnTemperatureChanged(object sender, TemperatureChangedEventArgs e)
    {
        if (e.NewTemperature &gt; alertThreshold)
        {
            Console.WriteLine($&quot;ðŸš¨ ALERT: Temperature {e.NewTemperature:F1}Â°C exceeds threshold {alertThreshold:F1}Â°C!&quot;);
        }
    }
}

public class TemperatureLogger
{
    public void OnTemperatureChanged(object sender, TemperatureChangedEventArgs e)
    {
        string logEntry = $&quot;[LOG] {e.TimeStamp:yyyy-MM-dd HH:mm:ss} - Temperature: {e.NewTemperature:F2}Â°C&quot;;
        Console.WriteLine(logEntry);

        // In real application, write to file or database
        System.IO.File.AppendAllText(&quot;temperature.log&quot;, logEntry + Environment.NewLine);
    }
}

// Main program demonstrating events
public class EventDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Event Demonstration ===\n&quot;);

        // Create event source
        TemperatureSensor sensor = new TemperatureSensor();

        // Create event listeners
        TemperatureDisplay display = new TemperatureDisplay(&quot;Main Display&quot;);
        TemperatureAlarm alarm = new TemperatureAlarm(30.0);
        TemperatureLogger logger = new TemperatureLogger();

        // Subscribe to events (register event handlers)
        sensor.TemperatureChanged += display.OnTemperatureChanged;
        sensor.TemperatureChanged += alarm.OnTemperatureChanged;
        sensor.TemperatureChanged += logger.OnTemperatureChanged;

        // Add anonymous event handler
        sensor.TemperatureChanged += (sender, e) =&gt;
        {
            if (e.NewTemperature &lt; 22)
            {
                Console.WriteLine(&quot;â„ï¸ Temperature is getting cold!&quot;);
            }
        };

        // Start monitoring (this will trigger events)
        sensor.StartMonitoring();

        Console.WriteLine(&quot;\n--- Unsubscribing some handlers ---&quot;);

        // Unsubscribe some handlers
        sensor.TemperatureChanged -= alarm.OnTemperatureChanged;

        Console.WriteLine(&quot;Setting final temperature...&quot;);
        sensor.Temperature = 25.5;

        DemonstrateCustomEvents();
    }

    public static void DemonstrateCustomEvents()
    {
        Console.WriteLine(&quot;\n=== Custom Event Example ===&quot;);

        var player = new MusicPlayer();
        var display = new MusicDisplay();
        var notification = new MusicNotification();

        // Subscribe to events
        player.SongStarted += display.OnSongStarted;
        player.SongStarted += notification.OnSongStarted;
        player.SongEnded += display.OnSongEnded;

        // Play some songs
        player.PlaySong(&quot;Bohemian Rhapsody&quot;, &quot;Queen&quot;);
        player.PlaySong(&quot;Hotel California&quot;, &quot;Eagles&quot;);
    }
}

// Custom event example - Music Player
public class SongEventArgs : EventArgs
{
    public string SongTitle { get; }
    public string Artist { get; }
    public DateTime EventTime { get; }

    public SongEventArgs(string title, string artist)
    {
        SongTitle = title;
        Artist = artist;
        EventTime = DateTime.Now;
    }
}

public class MusicPlayer
{
    public event EventHandler&lt;SongEventArgs&gt; SongStarted;
    public event EventHandler&lt;SongEventArgs&gt; SongEnded;

    public void PlaySong(string title, string artist)
    {
        Console.WriteLine($&quot;ðŸŽµ Playing: {title} by {artist}&quot;);

        // Raise SongStarted event
        OnSongStarted(new SongEventArgs(title, artist));

        // Simulate song playing
        System.Threading.Thread.Sleep(2000);

        // Raise SongEnded event
        OnSongEnded(new SongEventArgs(title, artist));
    }

    protected virtual void OnSongStarted(SongEventArgs e)
    {
        SongStarted?.Invoke(this, e);
    }

    protected virtual void OnSongEnded(SongEventArgs e)
    {
        SongEnded?.Invoke(this, e);
    }
}

public class MusicDisplay
{
    public void OnSongStarted(object sender, SongEventArgs e)
    {
        Console.WriteLine($&quot;ðŸ“º Now Playing: {e.SongTitle} - {e.Artist}&quot;);
    }

    public void OnSongEnded(object sender, SongEventArgs e)
    {
        Console.WriteLine($&quot;ðŸ“º Finished: {e.SongTitle}&quot;);
    }
}

public class MusicNotification
{
    public void OnSongStarted(object sender, SongEventArgs e)
    {
        Console.WriteLine($&quot;ðŸ”” Notification: Started playing {e.SongTitle}&quot;);
    }
}
</code></pre>
<h4 id="relationship-between-delegates-and-events">Relationship between Delegates and Events:</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Delegate</th>
<th>Event</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Definition</strong></td>
<td>Type-safe function pointer</td>
<td>Special form of multicast delegate</td>
</tr>
<tr>
<td><strong>Access</strong></td>
<td>Can be called directly from outside</td>
<td>Can only be raised from within the class</td>
</tr>
<tr>
<td><strong>Assignment</strong></td>
<td>Supports = operator</td>
<td>Only supports += and -= operators</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>Less secure (external classes can invoke)</td>
<td>More secure (encapsulated)</td>
</tr>
<tr>
<td><strong>Purpose</strong></td>
<td>General callback mechanism</td>
<td>Notification mechanism</td>
</tr>
</tbody>
</table>
<pre><code class="language-csharp">// Delegate vs Event comparison
public class DelegateVsEventDemo
{
    // Regular delegate
    public Action&lt;string&gt; MyDelegate;

    // Event based on delegate
    public event Action&lt;string&gt; MyEvent;

    public void DemonstrateRelationship()
    {
        // Delegate usage
        MyDelegate = msg =&gt; Console.WriteLine($&quot;Delegate: {msg}&quot;);
        MyDelegate += msg =&gt; Console.WriteLine($&quot;Delegate 2: {msg}&quot;);

        // Event usage
        MyEvent += msg =&gt; Console.WriteLine($&quot;Event: {msg}&quot;);

        // Calling delegate directly (allowed)
        MyDelegate?.Invoke(&quot;Hello from delegate&quot;);

        // Calling event directly (NOT allowed from outside class)
        // MyEvent?.Invoke(&quot;Hello from event&quot;); // Would cause compile error if called from outside

        // Proper way to raise event
        OnMyEvent(&quot;Hello from event&quot;);
    }

    protected virtual void OnMyEvent(string message)
    {
        MyEvent?.Invoke(message); // Can only be called from within the class
    }
}
</code></pre>
<p><strong>Key Points:</strong></p>
<ol>
<li><strong>Events are built on delegates</strong> - They use delegates internally</li>
<li><strong>Events provide encapsulation</strong> - Only the class that declares the event can raise it</li>
<li><strong>Events follow conventions</strong> - Usually named with verbs (Started, Changed, Completed)</li>
<li><strong>Event handlers follow pattern</strong> - <code>EventHandler&lt;T&gt;</code> or custom delegate types</li>
<li><strong>Events support += and -= only</strong> - Cannot be assigned directly with = operator</li>
</ol>
<h3 id="question-17-what-are-the-access-modifiers-in-c-explain-each-of-them-in-brief">Question 17: What are the access modifiers in C#? Explain each of them in brief.</h3>
<h4 id="access-modifiers-in-c">Access Modifiers in C#:</h4>
<p>C# provides several access modifiers that control the visibility and accessibility of classes, methods, fields, and other members.</p>
<pre><code class="language-csharp">using System;

// Demonstration of all access modifiers
public class AccessModifierDemo
{
    // PUBLIC - Accessible from anywhere
    public string PublicField = &quot;I'm accessible from anywhere&quot;;

    // PRIVATE - Accessible only within the same class
    private string privateField = &quot;I'm only accessible within this class&quot;;

    // PROTECTED - Accessible within the same class and derived classes
    protected string protectedField = &quot;I'm accessible in this class and derived classes&quot;;

    // INTERNAL - Accessible within the same assembly
    internal string internalField = &quot;I'm accessible within the same assembly&quot;;

    // PROTECTED INTERNAL - Accessible within same assembly OR derived classes
    protected internal string protectedInternalField = &quot;I'm accessible within assembly or derived classes&quot;;

    // PRIVATE PROTECTED - Accessible within same assembly AND derived classes only
    private protected string privateProtectedField = &quot;I'm accessible in derived classes within same assembly&quot;;

    public AccessModifierDemo()
    {
        // All fields are accessible within the same class
        Console.WriteLine(&quot;=== Inside AccessModifierDemo Constructor ===&quot;);
        Console.WriteLine($&quot;Public: {PublicField}&quot;);
        Console.WriteLine($&quot;Private: {privateField}&quot;);
        Console.WriteLine($&quot;Protected: {protectedField}&quot;);
        Console.WriteLine($&quot;Internal: {internalField}&quot;);
        Console.WriteLine($&quot;Protected Internal: {protectedInternalField}&quot;);
        Console.WriteLine($&quot;Private Protected: {privateProtectedField}&quot;);
    }

    // PUBLIC method
    public void PublicMethod()
    {
        Console.WriteLine(&quot;Public method - accessible from anywhere&quot;);
        PrivateMethod(); // Can call private method from within same class
    }

    // PRIVATE method
    private void PrivateMethod()
    {
        Console.WriteLine(&quot;Private method - only accessible within this class&quot;);
    }

    // PROTECTED method
    protected void ProtectedMethod()
    {
        Console.WriteLine(&quot;Protected method - accessible in derived classes&quot;);
    }

    // INTERNAL method
    internal void InternalMethod()
    {
        Console.WriteLine(&quot;Internal method - accessible within same assembly&quot;);
    }

    // PROTECTED INTERNAL method
    protected internal void ProtectedInternalMethod()
    {
        Console.WriteLine(&quot;Protected Internal method&quot;);
    }

    // PRIVATE PROTECTED method
    private protected void PrivateProtectedMethod()
    {
        Console.WriteLine(&quot;Private Protected method&quot;);
    }
}

// DERIVED CLASS - demonstrating inherited access
public class DerivedClass : AccessModifierDemo
{
    public void TestInheritedAccess()
    {
        Console.WriteLine(&quot;\n=== Inside Derived Class ===&quot;);

        // Accessible in derived class
        Console.WriteLine($&quot;Public: {PublicField}&quot;);
        // Console.WriteLine($&quot;Private: {privateField}&quot;); // ERROR: Not accessible
        Console.WriteLine($&quot;Protected: {protectedField}&quot;);
        Console.WriteLine($&quot;Internal: {internalField}&quot;);
        Console.WriteLine($&quot;Protected Internal: {protectedInternalField}&quot;);
        Console.WriteLine($&quot;Private Protected: {privateProtectedField}&quot;);

        // Method calls
        PublicMethod();
        // PrivateMethod(); // ERROR: Not accessible
        ProtectedMethod();
        InternalMethod();
        ProtectedInternalMethod();
        PrivateProtectedMethod();
    }
}

// SEPARATE CLASS in same assembly
public class SeparateClass
{
    public void TestExternalAccess()
    {
        Console.WriteLine(&quot;\n=== Inside Separate Class (Same Assembly) ===&quot;);

        AccessModifierDemo obj = new AccessModifierDemo();

        // Accessible from separate class in same assembly
        Console.WriteLine($&quot;Public: {obj.PublicField}&quot;);
        // Console.WriteLine($&quot;Private: {obj.privateField}&quot;); // ERROR: Not accessible
        // Console.WriteLine($&quot;Protected: {obj.protectedField}&quot;); // ERROR: Not accessible (not derived)
        Console.WriteLine($&quot;Internal: {obj.internalField}&quot;);
        Console.WriteLine($&quot;Protected Internal: {obj.protectedInternalField}&quot;);
        // Console.WriteLine($&quot;Private Protected: {obj.privateProtectedField}&quot;); // ERROR: Not accessible (not derived)

        // Method calls
        obj.PublicMethod();
        // obj.PrivateMethod(); // ERROR: Not accessible
        // obj.ProtectedMethod(); // ERROR: Not accessible (not derived)
        obj.InternalMethod();
        obj.ProtectedInternalMethod();
        // obj.PrivateProtectedMethod(); // ERROR: Not accessible (not derived)
    }
}

// CLASS ACCESS MODIFIERS
public class PublicClass
{
    public void Method() { Console.WriteLine(&quot;Public class method&quot;); }
}

internal class InternalClass
{
    public void Method() { Console.WriteLine(&quot;Internal class method&quot;); }
}

// NESTED CLASS ACCESS MODIFIERS
public class OuterClass
{
    private int outerPrivateField = 100;

    // Public nested class
    public class PublicNestedClass
    {
        public void AccessOuter(OuterClass outer)
        {
            // Nested class can access private members of outer class
            Console.WriteLine($&quot;Accessing outer private field: {outer.outerPrivateField}&quot;);
        }
    }

    // Private nested class
    private class PrivateNestedClass
    {
        public void Method()
        {
            Console.WriteLine(&quot;Private nested class method&quot;);
        }
    }

    // Protected nested class
    protected class ProtectedNestedClass
    {
        public void Method()
        {
            Console.WriteLine(&quot;Protected nested class method&quot;);
        }
    }

    public void CreateNestedInstances()
    {
        var publicNested = new PublicNestedClass();
        var privateNested = new PrivateNestedClass();
        var protectedNested = new ProtectedNestedClass();

        publicNested.AccessOuter(this);
        privateNested.Method();
        protectedNested.Method();
    }
}

// INTERFACE ACCESS MODIFIERS
public interface IPublicInterface
{
    void PublicInterfaceMethod();
}

internal interface IInternalInterface
{
    void InternalInterfaceMethod();
}

// PROPERTY ACCESS MODIFIERS
public class PropertyAccessDemo
{
    private string _name;

    // Property with different access levels for get/set
    public string Name
    {
        get { return _name; }
        private set { _name = value; } // Private setter
    }

    // Auto-property with private setter
    public int Id { get; private set; }

    // Protected setter
    public DateTime CreatedDate { get; protected set; }

    public PropertyAccessDemo(string name, int id)
    {
        Name = name; // Can set within same class
        Id = id;
        CreatedDate = DateTime.Now;
    }
}

// MAIN PROGRAM
public class Program
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== C# Access Modifiers Demonstration ===&quot;);

        // Test base class
        AccessModifierDemo baseObj = new AccessModifierDemo();
        baseObj.PublicMethod();
        // baseObj.PrivateMethod(); // ERROR: Not accessible
        baseObj.InternalMethod();

        // Test derived class
        DerivedClass derivedObj = new DerivedClass();
        derivedObj.TestInheritedAccess();

        // Test separate class
        SeparateClass separateObj = new SeparateClass();
        separateObj.TestExternalAccess();

        // Test nested classes
        Console.WriteLine(&quot;\n=== Nested Classes ===&quot;);
        OuterClass outerObj = new OuterClass();
        outerObj.CreateNestedInstances();

        var publicNested = new OuterClass.PublicNestedClass();
        // var privateNested = new OuterClass.PrivateNestedClass(); // ERROR: Not accessible

        // Test property access
        Console.WriteLine(&quot;\n=== Property Access ===&quot;);
        PropertyAccessDemo propObj = new PropertyAccessDemo(&quot;Test&quot;, 123);
        Console.WriteLine($&quot;Name: {propObj.Name}&quot;);
        Console.WriteLine($&quot;ID: {propObj.Id}&quot;);
        // propObj.Name = &quot;New Name&quot;; // ERROR: Setter is private
        // propObj.Id = 456; // ERROR: Setter is private
    }
}
</code></pre>
<h4 id="summary-of-access-modifiers">Summary of Access Modifiers:</h4>
<table>
<thead>
<tr>
<th>Access Modifier</th>
<th>Class Level</th>
<th>Member Level</th>
<th>Accessibility</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>public</strong></td>
<td>âœ“</td>
<td>âœ“</td>
<td>Everywhere</td>
</tr>
<tr>
<td><strong>private</strong></td>
<td>âœ—</td>
<td>âœ“</td>
<td>Same class only</td>
</tr>
<tr>
<td><strong>protected</strong></td>
<td>âœ—</td>
<td>âœ“</td>
<td>Same class + derived classes</td>
</tr>
<tr>
<td><strong>internal</strong></td>
<td>âœ“</td>
<td>âœ“</td>
<td>Same assembly</td>
</tr>
<tr>
<td><strong>protected internal</strong></td>
<td>âœ—</td>
<td>âœ“</td>
<td>Same assembly OR derived classes</td>
</tr>
<tr>
<td><strong>private protected</strong></td>
<td>âœ—</td>
<td>âœ“</td>
<td>Same assembly AND derived classes</td>
</tr>
</tbody>
</table>
<h4 id="key-points">Key Points:</h4>
<ol>
<li><p><strong>Default Access Levels:</strong></p>
<ul>
<li>Classes: <code>internal</code></li>
<li>Class members: <code>private</code></li>
<li>Interface members: <code>public</code></li>
</ul>
</li>
<li><p><strong>Most Restrictive to Least Restrictive:</strong></p>
<ul>
<li>private -&gt; private protected -&gt; protected -&gt; internal -&gt; protected internal -&gt; public</li>
</ul>
</li>
<li><p><strong>Best Practices:</strong></p>
<ul>
<li>Use the most restrictive access level possible</li>
<li>Prefer <code>private</code> for implementation details</li>
<li>Use <code>public</code> only for intended API</li>
<li>Use <code>protected</code> for extensibility in inheritance</li>
<li>Use <code>internal</code> for assembly-level collaboration</li>
</ul>
</li>
</ol>
<h3 id="question-18-what-do-we-mean-by-exceptions-write-basic-c-code-using-try-catch-to-catch-an-arithmetic-exception">Question 18: What do we mean by exceptions? Write basic C# code using try catch to catch an arithmetic exception.</h3>
<h4 id="what-are-exceptions">What are Exceptions?</h4>
<p><strong>Exceptions</strong> are runtime errors that occur during program execution. They represent unexpected or exceptional circumstances that disrupt the normal flow of a program. C# uses a structured exception handling mechanism with try-catch-finally blocks.</p>
<h4 id="exception-handling-with-try-catch">Exception Handling with Try-Catch:</h4>
<pre><code class="language-csharp">using System;

public class ExceptionHandlingDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Exception Handling Demonstration ===\n&quot;);

        // Basic arithmetic exception handling
        BasicArithmeticExceptionDemo();

        // Multiple exception types
        MultipleExceptionDemo();

        // Finally block demonstration
        FinallyBlockDemo();

        // Custom exception handling
        CustomExceptionDemo();

        // Nested try-catch
        NestedTryCatchDemo();
    }

    // Basic arithmetic exception handling
    public static void BasicArithmeticExceptionDemo()
    {
        Console.WriteLine(&quot;1. Basic Arithmetic Exception Handling:&quot;);

        try
        {
            Console.Write(&quot;Enter first number: &quot;);
            int number1 = int.Parse(Console.ReadLine());

            Console.Write(&quot;Enter second number: &quot;);
            int number2 = int.Parse(Console.ReadLine());

            // This can throw DivideByZeroException
            int result = number1 / number2;
            Console.WriteLine($&quot;Result: {number1} / {number2} = {result}&quot;);
        }
        catch (DivideByZeroException ex)
        {
            Console.WriteLine($&quot;Arithmetic Error: Cannot divide by zero!&quot;);
            Console.WriteLine($&quot;Exception Message: {ex.Message}&quot;);
        }
        catch (FormatException ex)
        {
            Console.WriteLine($&quot;Input Error: Please enter valid integers!&quot;);
            Console.WriteLine($&quot;Exception Message: {ex.Message}&quot;);
        }
        catch (OverflowException ex)
        {
            Console.WriteLine($&quot;Overflow Error: Number is too large!&quot;);
            Console.WriteLine($&quot;Exception Message: {ex.Message}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;General Error: {ex.Message}&quot;);
        }

        Console.WriteLine();
    }

    // Multiple arithmetic operations with exception handling
    public static void MultipleExceptionDemo()
    {
        Console.WriteLine(&quot;2. Multiple Arithmetic Operations:&quot;);

        int[] numbers = { 10, 5, 0, -3 };
        int divisor = 0;

        for (int i = 0; i &lt; numbers.Length; i++)
        {
            try
            {
                Console.WriteLine($&quot;Processing number: {numbers[i]}&quot;);

                // Division by zero exception
                int division = numbers[i] / divisor;
                Console.WriteLine($&quot;Division result: {division}&quot;);

                // Array index out of bounds
                int nextNumber = numbers[i + 10]; // Will throw IndexOutOfRangeException

                // Arithmetic overflow (if using checked context)
                checked
                {
                    int overflow = int.MaxValue + 1;
                }
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine(&quot;  âŒ Division by zero detected!&quot;);
            }
            catch (IndexOutOfRangeException)
            {
                Console.WriteLine(&quot;  âŒ Array index out of range!&quot;);
            }
            catch (OverflowException)
            {
                Console.WriteLine(&quot;  âŒ Arithmetic overflow occurred!&quot;);
            }
            catch (ArithmeticException ex)
            {
                Console.WriteLine($&quot;  âŒ Arithmetic exception: {ex.Message}&quot;);
            }
        }

        Console.WriteLine();
    }

    // Finally block demonstration
    public static void FinallyBlockDemo()
    {
        Console.WriteLine(&quot;3. Finally Block Demonstration:&quot;);

        System.IO.FileStream fileStream = null;

        try
        {
            // Simulate file operations that might fail
            Console.WriteLine(&quot;Opening file...&quot;);
            fileStream = new System.IO.FileStream(&quot;test.txt&quot;, System.IO.FileMode.Create);

            Console.Write(&quot;Enter a number to write to file: &quot;);
            int number = int.Parse(Console.ReadLine());

            // Potential arithmetic exception
            int result = 100 / number;

            byte[] data = System.Text.Encoding.UTF8.GetBytes($&quot;Result: {result}&quot;);
            fileStream.Write(data, 0, data.Length);

            Console.WriteLine(&quot;File written successfully!&quot;);
        }
        catch (DivideByZeroException)
        {
            Console.WriteLine(&quot;âŒ Cannot divide by zero while writing to file!&quot;);
        }
        catch (FormatException)
        {
            Console.WriteLine(&quot;âŒ Invalid number format!&quot;);
        }
        catch (System.IO.IOException ex)
        {
            Console.WriteLine($&quot;âŒ File I/O error: {ex.Message}&quot;);
        }
        finally
        {
            // This block always executes, even if exception occurs
            Console.WriteLine(&quot;Executing finally block...&quot;);

            if (fileStream != null)
            {
                fileStream.Close();
                Console.WriteLine(&quot;File stream closed.&quot;);
            }

            // Clean up temporary file
            if (System.IO.File.Exists(&quot;test.txt&quot;))
            {
                System.IO.File.Delete(&quot;test.txt&quot;);
                Console.WriteLine(&quot;Temporary file deleted.&quot;);
            }
        }

        Console.WriteLine();
    }

    // Custom exception handling
    public static void CustomExceptionDemo()
    {
        Console.WriteLine(&quot;4. Custom Exception Handling:&quot;);

        try
        {
            Calculator calculator = new Calculator();

            // Operations that might throw custom exceptions
            Console.WriteLine(&quot;Testing calculator operations:&quot;);

            double result1 = calculator.Divide(10, 2);
            Console.WriteLine($&quot;10 / 2 = {result1}&quot;);

            double result2 = calculator.Divide(10, 0); // Will throw custom exception
        }
        catch (CalculatorException ex)
        {
            Console.WriteLine($&quot;âŒ Calculator Error: {ex.Message}&quot;);
            Console.WriteLine($&quot;Error Code: {ex.ErrorCode}&quot;);
        }
        catch (ArithmeticException ex)
        {
            Console.WriteLine($&quot;âŒ Arithmetic Error: {ex.Message}&quot;);
        }

        Console.WriteLine();
    }

    // Nested try-catch blocks
    public static void NestedTryCatchDemo()
    {
        Console.WriteLine(&quot;5. Nested Try-Catch Blocks:&quot;);

        try
        {
            Console.WriteLine(&quot;Outer try block&quot;);

            try
            {
                Console.WriteLine(&quot;Inner try block&quot;);

                Console.Write(&quot;Enter a number for nested operation: &quot;);
                int number = int.Parse(Console.ReadLine());

                // Nested arithmetic operation
                int result = 1000 / number;

                // Array operation that might fail
                int[] array = new int[number];
                array[number] = 42; // Index out of bounds if number &gt; 0
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine(&quot;Inner catch: Division by zero handled&quot;);
                throw; // Re-throw to outer catch
            }
            catch (IndexOutOfRangeException)
            {
                Console.WriteLine(&quot;Inner catch: Array index error handled locally&quot;);
                // Not re-throwing, so outer catch won't see this
            }
        }
        catch (DivideByZeroException)
        {
            Console.WriteLine(&quot;Outer catch: Handling re-thrown division by zero&quot;);
        }
        catch (FormatException)
        {
            Console.WriteLine(&quot;Outer catch: Invalid input format&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Outer catch: General exception - {ex.Message}&quot;);
        }

        Console.WriteLine();
    }
}

// Custom Exception Class
public class CalculatorException : ArithmeticException
{
    public int ErrorCode { get; }

    public CalculatorException(string message, int errorCode) : base(message)
    {
        ErrorCode = errorCode;
    }

    public CalculatorException(string message, int errorCode, Exception innerException)
        : base(message, innerException)
    {
        ErrorCode = errorCode;
    }
}

// Calculator class with custom exception handling
public class Calculator
{
    public double Add(double a, double b)
    {
        try
        {
            checked
            {
                return a + b;
            }
        }
        catch (OverflowException)
        {
            throw new CalculatorException(&quot;Addition overflow occurred&quot;, 1001);
        }
    }

    public double Subtract(double a, double b)
    {
        try
        {
            checked
            {
                return a - b;
            }
        }
        catch (OverflowException)
        {
            throw new CalculatorException(&quot;Subtraction overflow occurred&quot;, 1002);
        }
    }

    public double Multiply(double a, double b)
    {
        try
        {
            checked
            {
                return a * b;
            }
        }
        catch (OverflowException)
        {
            throw new CalculatorException(&quot;Multiplication overflow occurred&quot;, 1003);
        }
    }

    public double Divide(double dividend, double divisor)
    {
        if (divisor == 0)
        {
            throw new CalculatorException(&quot;Division by zero is not allowed&quot;, 1004);
        }

        if (double.IsInfinity(dividend / divisor))
        {
            throw new CalculatorException(&quot;Division result is infinity&quot;, 1005);
        }

        return dividend / divisor;
    }

    public double SquareRoot(double number)
    {
        if (number &lt; 0)
        {
            throw new CalculatorException(&quot;Cannot calculate square root of negative number&quot;, 1006);
        }

        return Math.Sqrt(number);
    }
}

// Exception hierarchy demonstration
public class MathUtilities
{
    public static void DemonstrateExceptionHierarchy()
    {
        Console.WriteLine(&quot;6. Exception Hierarchy Demonstration:&quot;);

        try
        {
            // Different types of arithmetic exceptions
            ThrowDifferentExceptions(1); // DivideByZeroException
        }
        catch (DivideByZeroException ex)
        {
            Console.WriteLine($&quot;Specific: DivideByZeroException - {ex.Message}&quot;);
        }
        catch (ArithmeticException ex)
        {
            Console.WriteLine($&quot;General: ArithmeticException - {ex.Message}&quot;);
        }
        catch (SystemException ex)
        {
            Console.WriteLine($&quot;System: SystemException - {ex.Message}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Base: Exception - {ex.Message}&quot;);
        }
    }

    public static void ThrowDifferentExceptions(int type)
    {
        switch (type)
        {
            case 1:
                throw new DivideByZeroException(&quot;Division by zero occurred&quot;);
            case 2:
                throw new OverflowException(&quot;Arithmetic overflow occurred&quot;);
            case 3:
                throw new ArithmeticException(&quot;General arithmetic error&quot;);
            default:
                throw new InvalidOperationException(&quot;Invalid operation&quot;);
        }
    }
}
</code></pre>
<h4 id="common-arithmetic-exceptions">Common Arithmetic Exceptions:</h4>
<table>
<thead>
<tr>
<th>Exception Type</th>
<th>Description</th>
<th>Common Causes</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DivideByZeroException</strong></td>
<td>Division by zero</td>
<td><code>x / 0</code>, <code>x % 0</code></td>
</tr>
<tr>
<td><strong>OverflowException</strong></td>
<td>Arithmetic overflow</td>
<td>Result exceeds data type limits</td>
</tr>
<tr>
<td><strong>ArithmeticException</strong></td>
<td>Base class for arithmetic errors</td>
<td>Parent of above exceptions</td>
</tr>
<tr>
<td><strong>InvalidOperationException</strong></td>
<td>Invalid operation for current state</td>
<td>Math operations on invalid data</td>
</tr>
</tbody>
</table>
<h4 id="exception-handling-best-practices">Exception Handling Best Practices:</h4>
<pre><code class="language-csharp">public class ExceptionBestPractices
{
    // âœ… GOOD: Specific exception handling
    public static int SafeDivide(int dividend, int divisor)
    {
        try
        {
            return dividend / divisor;
        }
        catch (DivideByZeroException)
        {
            Console.WriteLine(&quot;Warning: Division by zero, returning 0&quot;);
            return 0;
        }
    }

    // âœ… GOOD: Input validation to prevent exceptions
    public static int ValidatedDivide(int dividend, int divisor)
    {
        if (divisor == 0)
        {
            throw new ArgumentException(&quot;Divisor cannot be zero&quot;, nameof(divisor));
        }

        return dividend / divisor;
    }

    // âœ… GOOD: Using finally for cleanup
    public static void ProcessWithCleanup()
    {
        System.IO.FileStream stream = null;
        try
        {
            stream = new System.IO.FileStream(&quot;data.txt&quot;, System.IO.FileMode.Create);
            // Process file
        }
        catch (System.IO.IOException ex)
        {
            Console.WriteLine($&quot;File error: {ex.Message}&quot;);
        }
        finally
        {
            stream?.Close(); // Always cleanup
        }
    }

    // âœ… GOOD: Using 'using' statement for automatic disposal
    public static void ProcessWithUsing()
    {
        try
        {
            using (var stream = new System.IO.FileStream(&quot;data.txt&quot;, System.IO.FileMode.Create))
            {
                // Process file - automatic cleanup
            }
        }
        catch (System.IO.IOException ex)
        {
            Console.WriteLine($&quot;File error: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h4 id="key-points-1">Key Points:</h4>
<ul>
<li><strong>Exception handling is for exceptional circumstances</strong>, not normal control flow</li>
<li><strong>Catch specific exceptions</strong> before general ones</li>
<li><strong>Use finally blocks</strong> for cleanup code that must run</li>
<li><strong>Consider using 'using' statements</strong> for automatic resource disposal</li>
<li><strong>Don't catch exceptions you can't handle meaningfully</strong></li>
<li><strong>Log exceptions</strong> for debugging and monitoring</li>
</ul>
<h3 id="question-19-c-is-object-oriented-language.give-one-reason-supporting-the-given-argument">Question 19: C# is Object Oriented Language. Give one reason supporting the given argument.</h3>
<p><strong>C# is an Object-Oriented Programming (OOP) language because it supports all four fundamental principles of OOP: Encapsulation, Inheritance, Polymorphism, and Abstraction.</strong></p>
<h4 id="primary-reason-encapsulation">Primary Reason - Encapsulation:</h4>
<p><strong>C# fully supports encapsulation by allowing data and methods to be bundled together within classes, while controlling access through access modifiers.</strong></p>
<pre><code class="language-csharp">using System;

// Example demonstrating Encapsulation - the core OOP principle
public class BankAccount
{
    // Private fields - data is hidden from outside access
    private string accountNumber;
    private string accountHolder;
    private decimal balance;
    private DateTime createdDate;

    // Constructor to initialize object state
    public BankAccount(string accountNumber, string accountHolder, decimal initialBalance)
    {
        this.accountNumber = accountNumber;
        this.accountHolder = accountHolder;
        this.balance = initialBalance &gt;= 0 ? initialBalance : 0;
        this.createdDate = DateTime.Now;
    }

    // Public properties provide controlled access to private data
    public string AccountNumber
    {
        get { return accountNumber; }
        // No setter - account number cannot be changed after creation
    }

    public string AccountHolder
    {
        get { return accountHolder; }
        set
        {
            if (!string.IsNullOrEmpty(value))
                accountHolder = value;
        }
    }

    // Read-only property for balance (can only be modified through methods)
    public decimal Balance
    {
        get { return balance; }
    }

    public DateTime CreatedDate
    {
        get { return createdDate; }
    }

    // Public methods provide controlled operations on private data
    public bool Deposit(decimal amount)
    {
        if (amount &gt; 0)
        {
            balance += amount;
            Console.WriteLine($&quot;Deposited: ${amount:F2}. New balance: ${balance:F2}&quot;);
            return true;
        }
        Console.WriteLine(&quot;Invalid deposit amount. Amount must be positive.&quot;);
        return false;
    }

    public bool Withdraw(decimal amount)
    {
        if (amount &gt; 0 &amp;&amp; amount &lt;= balance)
        {
            balance -= amount;
            Console.WriteLine($&quot;Withdrawn: ${amount:F2}. New balance: ${balance:F2}&quot;);
            return true;
        }
        Console.WriteLine(&quot;Invalid withdrawal. Check amount and balance.&quot;);
        return false;
    }

    // Method to display account information
    public void DisplayAccountInfo()
    {
        Console.WriteLine($&quot;Account: {accountNumber}&quot;);
        Console.WriteLine($&quot;Holder: {accountHolder}&quot;);
        Console.WriteLine($&quot;Balance: ${balance:F2}&quot;);
        Console.WriteLine($&quot;Created: {createdDate:yyyy-MM-dd}&quot;);
    }
}

// Additional example showing all OOP principles
public class OOPDemonstration
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== C# OOP Demonstration ===\n&quot;);

        // 1. ENCAPSULATION - Data and methods bundled together with access control
        Console.WriteLine(&quot;1. ENCAPSULATION:&quot;);
        BankAccount account = new BankAccount(&quot;ACC001&quot;, &quot;John Doe&quot;, 1000.00m);

        // Data is accessed through controlled methods/properties
        Console.WriteLine($&quot;Account Number: {account.AccountNumber}&quot;); // Accessible
        Console.WriteLine($&quot;Balance: ${account.Balance:F2}&quot;); // Read-only access

        // Direct access to private fields is not allowed:
        // account.balance = 5000; // ERROR: Cannot access private field

        // Operations through public methods
        account.Deposit(500);
        account.Withdraw(200);
        account.DisplayAccountInfo();

        Console.WriteLine();

        // 2. INHERITANCE - Creating specialized classes from base classes
        Console.WriteLine(&quot;2. INHERITANCE:&quot;);
        SavingsAccount savings = new SavingsAccount(&quot;SAV001&quot;, &quot;Jane Smith&quot;, 2000, 0.05m);
        savings.Deposit(100);
        savings.ApplyInterest();
        savings.DisplayAccountInfo();

        Console.WriteLine();

        // 3. POLYMORPHISM - Same interface, different implementations
        Console.WriteLine(&quot;3. POLYMORPHISM:&quot;);
        BankAccount[] accounts =
        {
            new BankAccount(&quot;ACC002&quot;, &quot;Alice Brown&quot;, 1500),
            new SavingsAccount(&quot;SAV002&quot;, &quot;Bob Wilson&quot;, 3000, 0.03m),
            new CheckingAccount(&quot;CHK001&quot;, &quot;Carol Davis&quot;, 800, 500)
        };

        foreach (BankAccount acc in accounts)
        {
            Console.WriteLine($&quot;Processing {acc.GetType().Name}:&quot;);
            acc.DisplayAccountInfo(); // Polymorphic behavior
            Console.WriteLine();
        }

        // 4. ABSTRACTION - Hiding complex implementation details
        Console.WriteLine(&quot;4. ABSTRACTION:&quot;);
        IPaymentProcessor processor = new CreditCardProcessor();
        processor.ProcessPayment(250.00m); // Abstract interface, concrete implementation
    }
}

// INHERITANCE example
public class SavingsAccount : BankAccount
{
    private decimal interestRate;

    public SavingsAccount(string accountNumber, string accountHolder, decimal initialBalance, decimal interestRate)
        : base(accountNumber, accountHolder, initialBalance)
    {
        this.interestRate = interestRate;
    }

    public decimal InterestRate
    {
        get { return interestRate; }
        set { interestRate = value &gt;= 0 ? value : 0; }
    }

    public void ApplyInterest()
    {
        decimal interest = Balance * interestRate;
        Deposit(interest);
        Console.WriteLine($&quot;Interest applied: ${interest:F2} at rate {interestRate:P2}&quot;);
    }

    public override void DisplayAccountInfo()
    {
        base.DisplayAccountInfo();
        Console.WriteLine($&quot;Interest Rate: {interestRate:P2}&quot;);
    }
}

public class CheckingAccount : BankAccount
{
    private decimal overdraftLimit;

    public CheckingAccount(string accountNumber, string accountHolder, decimal initialBalance, decimal overdraftLimit)
        : base(accountNumber, accountHolder, initialBalance)
    {
        this.overdraftLimit = overdraftLimit;
    }

    public decimal OverdraftLimit
    {
        get { return overdraftLimit; }
        set { overdraftLimit = value &gt;= 0 ? value : 0; }
    }

    // Override withdraw method to allow overdraft
    public new bool Withdraw(decimal amount)
    {
        if (amount &gt; 0 &amp;&amp; amount &lt;= (Balance + overdraftLimit))
        {
            // Use reflection or internal access to modify balance
            // For simplicity, using base withdrawal with validation
            if (amount &lt;= Balance)
            {
                return base.Withdraw(amount);
            }
            else
            {
                decimal overdraftAmount = amount - Balance;
                Console.WriteLine($&quot;Using overdraft: ${overdraftAmount:F2}&quot;);
                // In real implementation, would modify balance directly
                return true;
            }
        }
        Console.WriteLine(&quot;Withdrawal exceeds account balance plus overdraft limit.&quot;);
        return false;
    }

    public override void DisplayAccountInfo()
    {
        base.DisplayAccountInfo();
        Console.WriteLine($&quot;Overdraft Limit: ${overdraftLimit:F2}&quot;);
    }
}

// ABSTRACTION example with interfaces
public interface IPaymentProcessor
{
    bool ProcessPayment(decimal amount);
    string GetTransactionId();
}

public class CreditCardProcessor : IPaymentProcessor
{
    private Random random = new Random();

    public bool ProcessPayment(decimal amount)
    {
        // Complex internal logic hidden from user
        Console.WriteLine($&quot;Processing credit card payment of ${amount:F2}&quot;);

        // Simulate processing
        System.Threading.Thread.Sleep(1000);

        // Simulate success/failure
        bool success = random.Next(1, 10) &gt; 2; // 80% success rate

        if (success)
        {
            Console.WriteLine($&quot;Payment successful. Transaction ID: {GetTransactionId()}&quot;);
        }
        else
        {
            Console.WriteLine(&quot;Payment failed. Please try again.&quot;);
        }

        return success;
    }

    public string GetTransactionId()
    {
        return $&quot;TXN{random.Next(100000, 999999)}&quot;;
    }
}
</code></pre>
<h4 id="why-this-proves-c-is-object-oriented">Why This Proves C# is Object-Oriented:</h4>
<ol>
<li><strong>Classes and Objects</strong>: C# allows creating custom data types (classes) and instances (objects)</li>
<li><strong>Encapsulation</strong>: Private fields with public methods/properties control data access</li>
<li><strong>Data Hiding</strong>: Implementation details are hidden from external code</li>
<li><strong>Method Binding</strong>: Data and methods that operate on that data are bundled together</li>
<li><strong>Access Control</strong>: Access modifiers (private, public, protected) enforce proper encapsulation</li>
</ol>
<p>This example shows that <strong>C# treats everything as objects</strong> (except primitive types, which are also represented as objects through boxing), and <strong>enforces proper data encapsulation through access modifiers</strong>, which is the fundamental principle of Object-Oriented Programming.</p>
<h3 id="question-20-explain-garbage-collection">Question 20: Explain Garbage collection.</h3>
<h4 id="what-is-garbage-collection">What is Garbage Collection?</h4>
<p><strong>Garbage Collection (GC)</strong> in C# is an automatic memory management feature that automatically frees memory occupied by objects that are no longer reachable or referenced by the application. It's handled by the .NET runtime's Garbage Collector.</p>
<h4 id="how-garbage-collection-works">How Garbage Collection Works:</h4>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;

public class GarbageCollectionDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Garbage Collection Demonstration ===\n&quot;);

        // Show initial memory state
        ShowMemoryInfo(&quot;Initial state&quot;);

        // Create objects that will become eligible for GC
        CreateObjectsForGC();

        // Force garbage collection
        Console.WriteLine(&quot;Forcing garbage collection...&quot;);
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();

        ShowMemoryInfo(&quot;After forced GC&quot;);

        // Demonstrate different generations
        DemonstrateGenerations();

        // Demonstrate finalizers
        DemonstrateFinalization();

        // Demonstrate weak references
        DemonstrateWeakReferences();
    }

    public static void CreateObjectsForGC()
    {
        Console.WriteLine(&quot;Creating objects that will become garbage...&quot;);

        // Create many objects in local scope
        for (int i = 0; i &lt; 100000; i++)
        {
            var tempObject = new TempClass($&quot;Object {i}&quot;);
            var tempList = new List&lt;int&gt; { 1, 2, 3, 4, 5 };
            var tempString = $&quot;Temporary string {i}&quot;;
        }
        // Objects go out of scope here and become eligible for GC

        ShowMemoryInfo(&quot;After creating temporary objects&quot;);
    }

    public static void ShowMemoryInfo(string label)
    {
        long memoryBefore = GC.GetTotalMemory(false);

        Console.WriteLine($&quot;\n--- {label} ---&quot;);
        Console.WriteLine($&quot;Total Memory: {memoryBefore:N0} bytes&quot;);
        Console.WriteLine($&quot;Gen 0 Collections: {GC.CollectionCount(0)}&quot;);
        Console.WriteLine($&quot;Gen 1 Collections: {GC.CollectionCount(1)}&quot;);
        Console.WriteLine($&quot;Gen 2 Collections: {GC.CollectionCount(2)}&quot;);
        Console.WriteLine($&quot;Max Generation: {GC.MaxGeneration}&quot;);
    }

    public static void DemonstrateGenerations()
    {
        Console.WriteLine(&quot;\n=== Generation Demonstration ===&quot;);

        // Create objects of different lifespans
        var shortLived = new TempClass(&quot;Short-lived&quot;);
        var mediumLived = new TempClass(&quot;Medium-lived&quot;);
        var longLived = new TempClass(&quot;Long-lived&quot;);

        // Check generations
        Console.WriteLine($&quot;Short-lived generation: {GC.GetGeneration(shortLived)}&quot;);
        Console.WriteLine($&quot;Medium-lived generation: {GC.GetGeneration(mediumLived)}&quot;);
        Console.WriteLine($&quot;Long-lived generation: {GC.GetGeneration(longLived)}&quot;);

        // Create pressure to trigger Gen 0 collection
        for (int i = 0; i &lt; 10000; i++)
        {
            var temp = new TempClass($&quot;Pressure {i}&quot;);
        }

        Console.WriteLine($&quot;\nAfter memory pressure:&quot;);
        Console.WriteLine($&quot;Medium-lived generation: {GC.GetGeneration(mediumLived)}&quot;);
        Console.WriteLine($&quot;Long-lived generation: {GC.GetGeneration(longLived)}&quot;);

        // Keep references to prevent collection
        GC.KeepAlive(mediumLived);
        GC.KeepAlive(longLived);
    }

    public static void DemonstrateFinalization()
    {
        Console.WriteLine(&quot;\n=== Finalization Demonstration ===&quot;);

        // Create objects with finalizers
        for (int i = 0; i &lt; 5; i++)
        {
            var finalizableObject = new FinalizableClass(i);
        }

        Console.WriteLine(&quot;Objects with finalizers created&quot;);

        // Force collection and finalization
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();

        Console.WriteLine(&quot;Finalization completed&quot;);
    }

    public static void DemonstrateWeakReferences()
    {
        Console.WriteLine(&quot;\n=== Weak References Demonstration ===&quot;);

        // Create object and weak reference
        var strongRef = new TempClass(&quot;Strong Reference&quot;);
        var weakRef = new WeakReference(strongRef);

        Console.WriteLine($&quot;Strong ref alive: {strongRef != null}&quot;);
        Console.WriteLine($&quot;Weak ref alive: {weakRef.IsAlive}&quot;);
        Console.WriteLine($&quot;Weak ref target: {weakRef.Target}&quot;);

        // Remove strong reference
        strongRef = null;

        Console.WriteLine(&quot;\nAfter removing strong reference:&quot;);
        Console.WriteLine($&quot;Weak ref alive (before GC): {weakRef.IsAlive}&quot;);

        // Force garbage collection
        GC.Collect();
        GC.WaitForPendingFinalizers();

        Console.WriteLine($&quot;Weak ref alive (after GC): {weakRef.IsAlive}&quot;);
        Console.WriteLine($&quot;Weak ref target: {weakRef.Target}&quot;);
    }
}

// Example class for GC demonstration
public class TempClass
{
    public string Name { get; set; }
    public DateTime CreatedAt { get; set; }
    private byte[] data; // Some data to make object larger

    public TempClass(string name)
    {
        Name = name;
        CreatedAt = DateTime.Now;
        data = new byte[1024]; // 1KB of data
    }

    public override string ToString()
    {
        return $&quot;TempClass: {Name} (Created: {CreatedAt:HH:mm:ss})&quot;;
    }
}

// Class with finalizer (destructor)
public class FinalizableClass : IDisposable
{
    private int id;
    private bool disposed = false;

    public FinalizableClass(int id)
    {
        this.id = id;
        Console.WriteLine($&quot;FinalizableClass {id} created&quot;);
    }

    // Finalizer (destructor) - called by GC
    ~FinalizableClass()
    {
        Console.WriteLine($&quot;FinalizableClass {id} finalized&quot;);
        Dispose(false);
    }

    // IDisposable implementation
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Don't call finalizer if disposed manually
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Dispose managed resources
                Console.WriteLine($&quot;FinalizableClass {id} disposing managed resources&quot;);
            }

            // Dispose unmanaged resources
            Console.WriteLine($&quot;FinalizableClass {id} disposing unmanaged resources&quot;);
            disposed = true;
        }
    }
}

// Advanced GC concepts demonstration
public class AdvancedGCDemo
{
    private static List&lt;object&gt; keepAlive = new List&lt;object&gt;();

    public static void DemonstrateGCPressure()
    {
        Console.WriteLine(&quot;\n=== GC Pressure Demonstration ===&quot;);

        // Create memory pressure
        for (int i = 0; i &lt; 1000; i++)
        {
            var largeObject = new byte[85000]; // Large Object Heap (LOH)
            if (i % 100 == 0)
            {
                keepAlive.Add(largeObject); // Keep some alive
            }
        }

        ShowMemoryInfo(&quot;After creating large objects&quot;);

        // Clear references
        keepAlive.Clear();

        GC.Collect();
        GC.WaitForPendingFinalizers();

        ShowMemoryInfo(&quot;After clearing references and GC&quot;);
    }

    public static void DemonstrateGCNotifications()
    {
        Console.WriteLine(&quot;\n=== GC Notifications ===&quot;);

        // Register for GC notifications
        GC.RegisterForFullGCNotification(10, 10);

        // Create memory pressure to trigger GC
        for (int i = 0; i &lt; 50000; i++)
        {
            var temp = new byte[1024];
        }

        // Check for GC notification
        var status = GC.WaitForFullGCApproach(1000);
        if (status == GCNotificationStatus.Succeeded)
        {
            Console.WriteLine(&quot;Full GC is approaching&quot;);
        }
    }

    private static void ShowMemoryInfo(string label)
    {
        Console.WriteLine($&quot;\n{label}:&quot;);
        Console.WriteLine($&quot;Total Memory: {GC.GetTotalMemory(false):N0} bytes&quot;);
        Console.WriteLine($&quot;Collections - Gen0: {GC.CollectionCount(0)}, Gen1: {GC.CollectionCount(1)}, Gen2: {GC.CollectionCount(2)}&quot;);
    }
}

// Resource management best practices
public class ProperResourceManagement : IDisposable
{
    private System.IO.FileStream fileStream;
    private bool disposed = false;

    public ProperResourceManagement(string filename)
    {
        fileStream = new System.IO.FileStream(filename, System.IO.FileMode.Create);
    }

    public void WriteData(string data)
    {
        if (disposed) throw new ObjectDisposedException(nameof(ProperResourceManagement));

        byte[] bytes = System.Text.Encoding.UTF8.GetBytes(data);
        fileStream.Write(bytes, 0, bytes.Length);
    }

    // Proper dispose pattern
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Dispose managed resources
                fileStream?.Dispose();
            }

            disposed = true;
        }
    }

    // Finalizer as safety net
    ~ProperResourceManagement()
    {
        Dispose(false);
    }
}
</code></pre>
<h4 id="garbage-collection-process">Garbage Collection Process:</h4>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Description</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mark</strong></td>
<td>Identify reachable objects</td>
<td>GC walks object graph from roots</td>
</tr>
<tr>
<td><strong>Sweep</strong></td>
<td>Free unreachable objects</td>
<td>Deallocate memory of unmarked objects</td>
</tr>
<tr>
<td><strong>Compact</strong></td>
<td>Defragment heap</td>
<td>Move objects to eliminate fragmentation</td>
</tr>
</tbody>
</table>
<h4 id="generation-based-collection">Generation-Based Collection:</h4>
<pre><code class="language-csharp">public class GenerationDemo
{
    public static void ExplainGenerations()
    {
        Console.WriteLine(&quot;=== Generation-Based Collection ===&quot;);

        /*
         * Generation 0: New objects, collected frequently
         * Generation 1: Objects that survived one GC, collected less frequently
         * Generation 2: Long-lived objects, collected rarely
         * Large Object Heap (LOH): Objects &gt;= 85KB, collected with Gen 2
         */

        // Gen 0 objects (short-lived)
        for (int i = 0; i &lt; 1000; i++)
        {
            var temp = new StringBuilder($&quot;Temp {i}&quot;);
            // These become eligible for collection immediately
        }

        // Gen 1/2 objects (longer-lived)
        var persistent = new List&lt;string&gt;();
        for (int i = 0; i &lt; 100; i++)
        {
            persistent.Add($&quot;Persistent {i}&quot;);
        }

        Console.WriteLine($&quot;List generation: {GC.GetGeneration(persistent)}&quot;);

        // Trigger collections to promote objects
        GC.Collect(0); // Collect Gen 0 only
        GC.Collect(1); // Collect Gen 0 and 1
        GC.Collect(2); // Full collection (all generations)

        Console.WriteLine($&quot;List generation after GC: {GC.GetGeneration(persistent)}&quot;);
    }
}
</code></pre>
<h4 id="key-points-about-garbage-collection">Key Points about Garbage Collection:</h4>
<ol>
<li><strong>Automatic</strong>: No manual memory deallocation needed</li>
<li><strong>Generational</strong>: Different generations collected at different frequencies</li>
<li><strong>Mark and Sweep</strong>: Identifies and frees unreachable objects</li>
<li><strong>Compacting</strong>: Reduces heap fragmentation</li>
<li><strong>Concurrent</strong>: Can run concurrently with application (in some modes)</li>
<li><strong>Tunable</strong>: Various GC modes available (Workstation, Server, Concurrent, etc.)</li>
</ol>
<h4 id="best-practices-1">Best Practices:</h4>
<ul>
<li><strong>Implement IDisposable</strong> for resources that need deterministic cleanup</li>
<li><strong>Use <code>using</code> statements</strong> for automatic disposal</li>
<li><strong>Avoid unnecessary object creation</strong> in tight loops</li>
<li><strong>Be careful with event handlers</strong> - they can prevent garbage collection</li>
<li><strong>Use weak references</strong> when appropriate to avoid memory leaks</li>
<li><strong>Don't call GC.Collect() manually</strong> unless absolutely necessary</li>
</ul>
<h3 id="question-21-what-are-the-roles-of-c-compiler-and-jit-compiler">Question 21: What are the roles of C# Compiler and JIT compiler?</h3>
<h4 id="c-compiler-vs-jit-compiler">C# Compiler vs JIT Compiler</h4>
<p>C# compilation involves a two-step process: <strong>C# Compiler</strong> compiles source code to Intermediate Language (IL), and <strong>JIT Compiler</strong> compiles IL to native machine code at runtime.</p>
<pre><code class="language-csharp">using System;
using System.Reflection;
using System.Reflection.Emit;

public class CompilerDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== C# Compiler vs JIT Compiler Demonstration ===\n&quot;);

        // Demonstrate compilation process
        DemonstrateCompilationProcess();

        // Show JIT compilation in action
        DemonstrateJITCompilation();

        // Show runtime code generation
        DemonstrateRuntimeCodeGeneration();

        // Performance comparison
        DemonstrateJITPerformance();
    }

    public static void DemonstrateCompilationProcess()
    {
        Console.WriteLine(&quot;1. COMPILATION PROCESS:&quot;);
        Console.WriteLine(&quot;   Source Code (.cs) -&gt; C# Compiler -&gt; IL Code (.dll/.exe) -&gt; JIT Compiler -&gt; Native Code&quot;);
        Console.WriteLine();

        // Get information about current assembly
        Assembly currentAssembly = Assembly.GetExecutingAssembly();
        Console.WriteLine($&quot;Assembly: {currentAssembly.GetName().Name}&quot;);
        Console.WriteLine($&quot;Location: {currentAssembly.Location}&quot;);
        Console.WriteLine($&quot;Runtime Version: {currentAssembly.ImageRuntimeVersion}&quot;);
        Console.WriteLine();
    }

    public static void DemonstrateJITCompilation()
    {
        Console.WriteLine(&quot;2. JIT COMPILATION DEMONSTRATION:&quot;);

        // First call - method gets JIT compiled
        Console.WriteLine(&quot;First call to SampleMethod (JIT compilation occurs):&quot;);
        var start = DateTime.UtcNow;
        int result1 = SampleMethod(10, 20);
        var duration1 = DateTime.UtcNow - start;
        Console.WriteLine($&quot;Result: {result1}, Duration: {duration1.TotalMilliseconds:F4} ms&quot;);

        // Second call - method already compiled
        Console.WriteLine(&quot;Second call to SampleMethod (already JIT compiled):&quot;);
        start = DateTime.UtcNow;
        int result2 = SampleMethod(30, 40);
        var duration2 = DateTime.UtcNow - start;
        Console.WriteLine($&quot;Result: {result2}, Duration: {duration2.TotalMilliseconds:F4} ms&quot;);

        Console.WriteLine($&quot;Performance improvement: {(duration1.TotalMilliseconds / duration2.TotalMilliseconds):F2}x faster&quot;);
        Console.WriteLine();
    }

    // Sample method for JIT demonstration
    public static int SampleMethod(int a, int b)
    {
        // Simulate some computation
        int result = 0;
        for (int i = 0; i &lt; 1000; i++)
        {
            result += (a * b) + (i % 10);
        }
        return result;
    }

    public static void DemonstrateRuntimeCodeGeneration()
    {
        Console.WriteLine(&quot;3. RUNTIME CODE GENERATION (Reflection.Emit):&quot;);

        // Create dynamic assembly
        AssemblyName assemblyName = new AssemblyName(&quot;DynamicAssembly&quot;);
        AssemblyBuilder assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(
            assemblyName, AssemblyBuilderAccess.Run);

        // Create dynamic module
        ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(&quot;DynamicModule&quot;);

        // Create dynamic type
        TypeBuilder typeBuilder = moduleBuilder.DefineType(&quot;DynamicCalculator&quot;,
            TypeAttributes.Public);

        // Create dynamic method
        MethodBuilder methodBuilder = typeBuilder.DefineMethod(&quot;Add&quot;,
            MethodAttributes.Public | MethodAttributes.Static,
            typeof(int), new Type[] { typeof(int), typeof(int) });

        // Generate IL code
        ILGenerator il = methodBuilder.GetILGenerator();
        il.Emit(OpCodes.Ldarg_0);  // Load first argument
        il.Emit(OpCodes.Ldarg_1);  // Load second argument
        il.Emit(OpCodes.Add);      // Add them
        il.Emit(OpCodes.Ret);      // Return result

        // Create type and get method
        Type dynamicType = typeBuilder.CreateType();
        MethodInfo dynamicMethod = dynamicType.GetMethod(&quot;Add&quot;);

        // Invoke dynamically generated method
        object result = dynamicMethod.Invoke(null, new object[] { 15, 25 });
        Console.WriteLine($&quot;Dynamic method result: 15 + 25 = {result}&quot;);
        Console.WriteLine();
    }

    public static void DemonstrateJITPerformance()
    {
        Console.WriteLine(&quot;4. JIT PERFORMANCE IMPACT:&quot;);

        const int iterations = 1000000;

        // Warm up JIT
        for (int i = 0; i &lt; 1000; i++)
        {
            MathOperations.ComplexCalculation(i);
        }

        // Measure performance after JIT compilation
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();

        for (int i = 0; i &lt; iterations; i++)
        {
            MathOperations.ComplexCalculation(i);
        }

        stopwatch.Stop();

        Console.WriteLine($&quot;Executed {iterations:N0} operations in {stopwatch.ElapsedMilliseconds} ms&quot;);
        Console.WriteLine($&quot;Average per operation: {(double)stopwatch.ElapsedTicks / iterations:F2} ticks&quot;);
        Console.WriteLine();
    }
}

// Class for performance testing
public static class MathOperations
{
    public static double ComplexCalculation(int input)
    {
        double result = Math.Sqrt(input);
        result = Math.Sin(result) + Math.Cos(result);
        result *= Math.PI;
        return Math.Abs(result);
    }
}

// IL Code inspection utility
public class ILInspection
{
    public static void InspectMethodIL()
    {
        Console.WriteLine(&quot;5. IL CODE INSPECTION:&quot;);

        MethodInfo method = typeof(CompilerDemo).GetMethod(&quot;SampleMethod&quot;);
        MethodBody methodBody = method.GetMethodBody();

        if (methodBody != null)
        {
            Console.WriteLine($&quot;Method: {method.Name}&quot;);
            Console.WriteLine($&quot;IL Code Size: {methodBody.GetILAsByteArray().Length} bytes&quot;);
            Console.WriteLine($&quot;Max Stack Size: {methodBody.MaxStackSize}&quot;);
            Console.WriteLine($&quot;Local Variables: {methodBody.LocalVariables.Count}&quot;);

            foreach (var localVar in methodBody.LocalVariables)
            {
                Console.WriteLine($&quot;  Local {localVar.LocalIndex}: {localVar.LocalType}&quot;);
            }
        }
        Console.WriteLine();
    }
}

// Custom JIT optimization demonstration
public class JITOptimizationDemo
{
    public static void DemonstrateOptimizations()
    {
        Console.WriteLine(&quot;6. JIT OPTIMIZATIONS:&quot;);

        // Method inlining demonstration
        Console.WriteLine(&quot;Testing method inlining...&quot;);

        var stopwatch = System.Diagnostics.Stopwatch.StartNew();

        for (int i = 0; i &lt; 10000000; i++)
        {
            int result = AddNumbers(i, i + 1); // Small method likely to be inlined
        }

        stopwatch.Stop();
        Console.WriteLine($&quot;Method calls completed in {stopwatch.ElapsedMilliseconds} ms&quot;);

        // Loop optimization
        Console.WriteLine(&quot;Testing loop optimization...&quot;);

        stopwatch.Restart();

        int sum = 0;
        for (int i = 0; i &lt; 10000000; i++)
        {
            sum += i; // JIT will optimize this loop
        }

        stopwatch.Stop();
        Console.WriteLine($&quot;Loop optimization completed in {stopwatch.ElapsedMilliseconds} ms&quot;);
        Console.WriteLine($&quot;Sum: {sum}&quot;);
        Console.WriteLine();
    }

    // Small method that may be inlined by JIT
    private static int AddNumbers(int a, int b)
    {
        return a + b;
    }
}
</code></pre>
<h4 id="detailed-comparison">Detailed Comparison:</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>C# Compiler (csc.exe/Roslyn)</th>
<th>JIT Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Input</strong></td>
<td>C# source code (.cs files)</td>
<td>IL code (.dll/.exe files)</td>
</tr>
<tr>
<td><strong>Output</strong></td>
<td>Intermediate Language (IL) code</td>
<td>Native machine code</td>
</tr>
<tr>
<td><strong>When</strong></td>
<td>Compile time (before execution)</td>
<td>Runtime (during execution)</td>
</tr>
<tr>
<td><strong>Platform</strong></td>
<td>Platform independent</td>
<td>Platform specific</td>
</tr>
<tr>
<td><strong>Optimization</strong></td>
<td>High-level optimizations</td>
<td>Low-level, runtime optimizations</td>
</tr>
<tr>
<td><strong>Speed</strong></td>
<td>Slower (full analysis)</td>
<td>Faster (targeted compilation)</td>
</tr>
</tbody>
</table>
<h4 id="c-compiler-role">C# Compiler Role:</h4>
<pre><code class="language-csharp">// Example showing what C# compiler does:

// 1. SYNTAX ANALYSIS
public class CompilerTasks
{
    // Compiler checks syntax, semantics, types
    public void CompilerResponsibilities()
    {
        // Syntax validation
        int number = 42; // âœ“ Valid syntax
        // int number = ; // âœ— Compiler error: syntax error

        // Type checking
        string text = &quot;Hello&quot;; // âœ“ Valid type assignment
        // int wrongType = &quot;Hello&quot;; // âœ— Compiler error: type mismatch

        // Method resolution
        Console.WriteLine(text); // âœ“ Compiler finds correct overload

        // Constant folding
        const int result = 10 + 20; // Compiler calculates at compile time
    }
}

// 2. IL CODE GENERATION
/*
Original C# code:
public int Add(int a, int b)
{
    return a + b;
}

Generated IL code (simplified):
.method public hidebysig instance int32 Add(int32 a, int32 b)
{
    .maxstack 2
    ldarg.1     // Load argument 'a'
    ldarg.2     // Load argument 'b'
    add         // Add them
    ret         // Return result
}
*/
</code></pre>
<h4 id="jit-compiler-role">JIT Compiler Role:</h4>
<pre><code class="language-csharp">public class JITCompilerTasks
{
    public static void JITResponsibilities()
    {
        Console.WriteLine(&quot;JIT Compiler Tasks:&quot;);
        Console.WriteLine(&quot;1. Convert IL to native machine code&quot;);
        Console.WriteLine(&quot;2. Perform runtime optimizations&quot;);
        Console.WriteLine(&quot;3. Handle platform-specific details&quot;);
        Console.WriteLine(&quot;4. Manage method compilation on-demand&quot;);
        Console.WriteLine(&quot;5. Apply processor-specific optimizations&quot;);

        // JIT compilation happens here (first call)
        PerformanceTestMethod();

        // Subsequent calls use already compiled native code
        PerformanceTestMethod();
    }

    private static void PerformanceTestMethod()
    {
        // JIT will optimize this based on:
        // - CPU architecture (x86, x64, ARM)
        // - Available CPU features (SSE, AVX)
        // - Runtime profiling data

        for (int i = 0; i &lt; 1000; i++)
        {
            double result = Math.Sqrt(i) * Math.PI;
        }
    }
}
</code></pre>
<h4 id="jit-optimization-examples">JIT Optimization Examples:</h4>
<pre><code class="language-csharp">public class JITOptimizations
{
    // 1. METHOD INLINING
    public static void InliningDemo()
    {
        // Small methods like GetConstant() may be inlined
        int value = GetConstant() * 2;
        Console.WriteLine(value);
    }

    private static int GetConstant() =&gt; 42; // Likely to be inlined

    // 2. DEAD CODE ELIMINATION
    public static void DeadCodeDemo()
    {
        bool condition = false; // JIT knows this is always false

        if (condition) // JIT will eliminate this entire block
        {
            Console.WriteLine(&quot;This code will be eliminated&quot;);
            ExpensiveOperation();
        }

        Console.WriteLine(&quot;This code remains&quot;);
    }

    // 3. LOOP OPTIMIZATION
    public static void LoopOptimizationDemo()
    {
        int[] array = new int[1000];

        // JIT will optimize bounds checking and loop structure
        for (int i = 0; i &lt; array.Length; i++)
        {
            array[i] = i * 2; // Bounds check may be eliminated
        }
    }

    // 4. REGISTER ALLOCATION
    public static int RegisterDemo(int a, int b, int c)
    {
        // JIT will efficiently allocate CPU registers for variables
        int temp1 = a + b;
        int temp2 = temp1 * c;
        int result = temp2 + a;
        return result;
    }

    private static void ExpensiveOperation()
    {
        System.Threading.Thread.Sleep(1000);
    }
}
</code></pre>
<h4 id="key-differences-summary">Key Differences Summary:</h4>
<p><strong>C# Compiler (Compile-time):</strong></p>
<ul>
<li>Converts source code to IL</li>
<li>Performs syntax and semantic analysis</li>
<li>Type checking and method resolution</li>
<li>High-level optimizations</li>
<li>Generates metadata</li>
<li>Platform independent output</li>
</ul>
<p><strong>JIT Compiler (Runtime):</strong></p>
<ul>
<li>Converts IL to native code</li>
<li>Just-in-time compilation (on first method call)</li>
<li>Platform-specific optimizations</li>
<li>Runtime profiling and adaptive optimization</li>
<li>Processor-specific code generation</li>
<li>Memory layout optimization</li>
</ul>
<p>This two-stage compilation allows C# to be both platform-independent (IL) and highly optimized (native code).</p>
<h3 id="question-22-define-an-interface-with-methods-area-volume.define-a-constant-pi-having-value-3.14.create-class-cylinder-which-implements-this-interface.create-one-object-and-calculate-area-and-volume">Question 22: Define an interface with methods Area(), Volume(). Define a constant PI having value 3.14. Create class Cylinder which implements this interface. Create one object and calculate area and volume.</h3>
<pre><code class="language-csharp">using System;

// Interface definition with methods and constant
public interface IShape3D
{
    // Constant PI with value 3.14
    const double PI = 3.14;

    // Abstract methods that implementing classes must define
    double Area();
    double Volume();

    // Optional: Additional interface members
    string GetShapeInfo();
}

// Cylinder class implementing the interface
public class Cylinder : IShape3D
{
    // Private fields
    private double radius;
    private double height;

    // Constructor
    public Cylinder(double radius, double height)
    {
        if (radius &lt;= 0 || height &lt;= 0)
            throw new ArgumentException(&quot;Radius and height must be positive&quot;);

        this.radius = radius;
        this.height = height;
    }

    // Properties
    public double Radius
    {
        get { return radius; }
        set
        {
            if (value &gt; 0)
                radius = value;
            else
                throw new ArgumentException(&quot;Radius must be positive&quot;);
        }
    }

    public double Height
    {
        get { return height; }
        set
        {
            if (value &gt; 0)
                height = value;
            else
                throw new ArgumentException(&quot;Height must be positive&quot;);
        }
    }

    // Implementation of Area() method - Surface Area of Cylinder
    public double Area()
    {
        // Surface Area = 2Ï€rÂ² + 2Ï€rh (top + bottom + lateral surface)
        double topAndBottom = 2 * IShape3D.PI * radius * radius;
        double lateralSurface = 2 * IShape3D.PI * radius * height;
        return topAndBottom + lateralSurface;
    }

    // Implementation of Volume() method
    public double Volume()
    {
        // Volume = Ï€rÂ²h
        return IShape3D.PI * radius * radius * height;
    }

    // Implementation of GetShapeInfo() method
    public string GetShapeInfo()
    {
        return $&quot;Cylinder - Radius: {radius:F2}, Height: {height:F2}&quot;;
    }

    // Additional methods specific to Cylinder
    public double GetLateralArea()
    {
        // Lateral Area = 2Ï€rh
        return 2 * IShape3D.PI * radius * height;
    }

    public double GetBaseArea()
    {
        // Base Area = Ï€rÂ²
        return IShape3D.PI * radius * radius;
    }

    public void DisplayDetails()
    {
        Console.WriteLine($&quot;=== Cylinder Details ===&quot;);
        Console.WriteLine($&quot;Radius: {radius:F2}&quot;);
        Console.WriteLine($&quot;Height: {height:F2}&quot;);
        Console.WriteLine($&quot;Base Area: {GetBaseArea():F2}&quot;);
        Console.WriteLine($&quot;Lateral Area: {GetLateralArea():F2}&quot;);
        Console.WriteLine($&quot;Total Surface Area: {Area():F2}&quot;);
        Console.WriteLine($&quot;Volume: {Volume():F2}&quot;);
        Console.WriteLine($&quot;========================&quot;);
    }
}

// Additional shape classes implementing the same interface
public class Sphere : IShape3D
{
    private double radius;

    public Sphere(double radius)
    {
        if (radius &lt;= 0)
            throw new ArgumentException(&quot;Radius must be positive&quot;);
        this.radius = radius;
    }

    public double Radius
    {
        get { return radius; }
        set
        {
            if (value &gt; 0)
                radius = value;
            else
                throw new ArgumentException(&quot;Radius must be positive&quot;);
        }
    }

    public double Area()
    {
        // Surface Area of Sphere = 4Ï€rÂ²
        return 4 * IShape3D.PI * radius * radius;
    }

    public double Volume()
    {
        // Volume of Sphere = (4/3)Ï€rÂ³
        return (4.0 / 3.0) * IShape3D.PI * radius * radius * radius;
    }

    public string GetShapeInfo()
    {
        return $&quot;Sphere - Radius: {radius:F2}&quot;;
    }
}

public class Cone : IShape3D
{
    private double radius;
    private double height;

    public Cone(double radius, double height)
    {
        if (radius &lt;= 0 || height &lt;= 0)
            throw new ArgumentException(&quot;Radius and height must be positive&quot;);
        this.radius = radius;
        this.height = height;
    }

    public double Radius =&gt; radius;
    public double Height =&gt; height;

    // Slant height calculation
    public double SlantHeight =&gt; Math.Sqrt(radius * radius + height * height);

    public double Area()
    {
        // Surface Area = Ï€rÂ² + Ï€rl (base + lateral surface)
        double baseArea = IShape3D.PI * radius * radius;
        double lateralArea = IShape3D.PI * radius * SlantHeight;
        return baseArea + lateralArea;
    }

    public double Volume()
    {
        // Volume = (1/3)Ï€rÂ²h
        return (1.0 / 3.0) * IShape3D.PI * radius * radius * height;
    }

    public string GetShapeInfo()
    {
        return $&quot;Cone - Radius: {radius:F2}, Height: {height:F2}, Slant Height: {SlantHeight:F2}&quot;;
    }
}

// Main program demonstrating interface implementation
public class InterfaceDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Interface Implementation Demonstration ===\n&quot;);

        try
        {
            // Create Cylinder object and calculate area and volume
            CreateAndTestCylinder();

            // Demonstrate polymorphism with interface
            DemonstratePolymorphism();

            // Interactive cylinder creation
            CreateInteractiveCylinder();

            // Compare different shapes
            CompareShapes();
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Unexpected error: {ex.Message}&quot;);
        }
    }

    public static void CreateAndTestCylinder()
    {
        Console.WriteLine(&quot;1. Creating and Testing Cylinder:&quot;);

        // Create cylinder object
        Cylinder cylinder = new Cylinder(5.0, 10.0);

        // Calculate and display area and volume
        double area = cylinder.Area();
        double volume = cylinder.Volume();

        Console.WriteLine($&quot;Cylinder: Radius = {cylinder.Radius}, Height = {cylinder.Height}&quot;);
        Console.WriteLine($&quot;Surface Area = {area:F2}&quot;);
        Console.WriteLine($&quot;Volume = {volume:F2}&quot;);
        Console.WriteLine($&quot;Shape Info: {cylinder.GetShapeInfo()}&quot;);

        // Display detailed information
        cylinder.DisplayDetails();

        Console.WriteLine();
    }

    public static void DemonstratePolymorphism()
    {
        Console.WriteLine(&quot;2. Polymorphism with Interface:&quot;);

        // Array of interface references
        IShape3D[] shapes = {
            new Cylinder(3, 8),
            new Sphere(4),
            new Cone(5, 12),
            new Cylinder(2.5, 6)
        };

        Console.WriteLine($&quot;{&quot;Shape&quot;,-20} {&quot;Area&quot;,-15} {&quot;Volume&quot;,-15}&quot;);
        Console.WriteLine(new string('-', 50));

        foreach (IShape3D shape in shapes)
        {
            Console.WriteLine($&quot;{shape.GetShapeInfo(),-20} {shape.Area(),-15:F2} {shape.Volume(),-15:F2}&quot;);
        }

        Console.WriteLine();
    }

    public static void CreateInteractiveCylinder()
    {
        Console.WriteLine(&quot;3. Interactive Cylinder Creation:&quot;);

        try
        {
            Console.Write(&quot;Enter cylinder radius: &quot;);
            double radius = double.Parse(Console.ReadLine());

            Console.Write(&quot;Enter cylinder height: &quot;);
            double height = double.Parse(Console.ReadLine());

            Cylinder userCylinder = new Cylinder(radius, height);

            Console.WriteLine(&quot;\nYour cylinder:&quot;);
            userCylinder.DisplayDetails();

            // Calculate some additional properties
            double baseArea = userCylinder.GetBaseArea();
            double lateralArea = userCylinder.GetLateralArea();

            Console.WriteLine($&quot;Additional calculations:&quot;);
            Console.WriteLine($&quot;Base Area: {baseArea:F2}&quot;);
            Console.WriteLine($&quot;Lateral Area: {lateralArea:F2}&quot;);
            Console.WriteLine($&quot;Total Surface Area: {userCylinder.Area():F2}&quot;);
            Console.WriteLine($&quot;Volume: {userCylinder.Volume():F2}&quot;);
        }
        catch (FormatException)
        {
            Console.WriteLine(&quot;Invalid input. Please enter numeric values.&quot;);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($&quot;Invalid values: {ex.Message}&quot;);
        }

        Console.WriteLine();
    }

    public static void CompareShapes()
    {
        Console.WriteLine(&quot;4. Shape Comparison:&quot;);

        // Create shapes with same dimensions where applicable
        double commonRadius = 3.0;
        double commonHeight = 6.0;

        IShape3D cylinder = new Cylinder(commonRadius, commonHeight);
        IShape3D sphere = new Sphere(commonRadius);
        IShape3D cone = new Cone(commonRadius, commonHeight);

        Console.WriteLine(&quot;Comparing shapes with radius = 3.0:&quot;);
        Console.WriteLine($&quot;Cylinder (h=6.0): Area = {cylinder.Area():F2}, Volume = {cylinder.Volume():F2}&quot;);
        Console.WriteLine($&quot;Sphere: Area = {sphere.Area():F2}, Volume = {sphere.Volume():F2}&quot;);
        Console.WriteLine($&quot;Cone (h=6.0): Area = {cone.Area():F2}, Volume = {cone.Volume():F2}&quot;);

        // Find shape with maximum volume
        IShape3D[] compareShapes = { cylinder, sphere, cone };
        IShape3D maxVolumeShape = null;
        double maxVolume = 0;

        foreach (IShape3D shape in compareShapes)
        {
            if (shape.Volume() &gt; maxVolume)
            {
                maxVolume = shape.Volume();
                maxVolumeShape = shape;
            }
        }

        Console.WriteLine($&quot;\nShape with maximum volume: {maxVolumeShape?.GetShapeInfo()} (Volume: {maxVolume:F2})&quot;);

        Console.WriteLine();
    }
}

// Utility class for shape calculations
public static class ShapeUtilities
{
    // Extension methods for interface
    public static double GetDensity(this IShape3D shape, double mass)
    {
        return mass / shape.Volume();
    }

    public static double GetSurfaceToVolumeRatio(this IShape3D shape)
    {
        return shape.Area() / shape.Volume();
    }

    // Helper method to convert degrees to radians
    public static double DegreesToRadians(double degrees)
    {
        return degrees * IShape3D.PI / 180.0;
    }

    // Calculate volume using different PI precision
    public static void ComparePrecision(IShape3D shape)
    {
        // Using interface constant PI = 3.14
        double volumeInterfacePI = shape.Volume();

        // Using Math.PI for comparison
        double precisePIRatio = Math.PI / IShape3D.PI;
        double volumeMathPI = volumeInterfacePI * precisePIRatio;

        Console.WriteLine($&quot;Volume with PI = 3.14: {volumeInterfacePI:F6}&quot;);
        Console.WriteLine($&quot;Volume with Math.PI: {volumeMathPI:F6}&quot;);
        Console.WriteLine($&quot;Difference: {Math.Abs(volumeMathPI - volumeInterfacePI):F6}&quot;);
    }
}

// Advanced interface example with generic constraints
public interface IComparable3DShape : IShape3D, IComparable&lt;IComparable3DShape&gt;
{
    double GetCharacteristicLength();
}

public class AdvancedCylinder : Cylinder, IComparable3DShape
{
    public AdvancedCylinder(double radius, double height) : base(radius, height)
    {
    }

    public double GetCharacteristicLength()
    {
        // Return the larger of diameter or height
        return Math.Max(2 * Radius, Height);
    }

    public int CompareTo(IComparable3DShape other)
    {
        if (other == null) return 1;
        return this.Volume().CompareTo(other.Volume());
    }
}
</code></pre>
<h4 id="key-interface-concepts-demonstrated">Key Interface Concepts Demonstrated:</h4>
<ol>
<li><strong>Interface Definition</strong>: <code>IShape3D</code> with methods <code>Area()</code>, <code>Volume()</code>, and constant <code>PI</code></li>
<li><strong>Interface Implementation</strong>: <code>Cylinder</code> class implements all interface members</li>
<li><strong>Constant Usage</strong>: Interface constant <code>PI = 3.14</code> used in calculations</li>
<li><strong>Polymorphism</strong>: Different shapes can be treated uniformly through interface</li>
<li><strong>Multiple Implementations</strong>: Several classes implement the same interface</li>
</ol>
<h4 id="output-example">Output Example:</h4>
<pre><code>Cylinder: Radius = 5, Height = 10
Surface Area = 471.00
Volume = 785.00
Shape Info: Cylinder - Radius: 5.00, Height: 10.00
</code></pre>
<p>This demonstrates how interfaces provide a contract that implementing classes must follow, enabling polymorphism and code reusability.</p>
<h3 id="question-23-what-are-the-streams-in-c-write-a-program-to-save-content-to-file-and-read-from-it-using-stream">Question 23: What are the streams in C#? Write a program to save content to file and read from it using stream.</h3>
<h4 id="what-are-streams">What are Streams?</h4>
<p><strong>Streams</strong> in C# represent a sequence of bytes that can be read from or written to. They provide a unified way to work with different data sources like files, memory, network connections, etc.</p>
<h4 id="stream-hierarchy-and-types">Stream Hierarchy and Types:</h4>
<pre><code class="language-csharp">using System;
using System.IO;
using System.Text;

public class StreamDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== C# Streams Demonstration ===\n&quot;);

        // Basic file stream operations
        BasicFileStreamDemo();

        // StreamWriter and StreamReader
        StreamWriterReaderDemo();

        // Binary streams
        BinaryStreamDemo();

        // Memory streams
        MemoryStreamDemo();

        // Buffered streams
        BufferedStreamDemo();

        // Advanced stream operations
        AdvancedStreamOperations();
    }

    public static void BasicFileStreamDemo()
    {
        Console.WriteLine(&quot;1. Basic FileStream Operations:&quot;);

        string fileName = &quot;basic_stream_demo.txt&quot;;

        try
        {
            // WRITING to file using FileStream
            using (FileStream writeStream = new FileStream(fileName, FileMode.Create, FileAccess.Write))
            {
                string content = &quot;Hello, World! This is written using FileStream.&quot;;
                byte[] data = Encoding.UTF8.GetBytes(content);

                writeStream.Write(data, 0, data.Length);
                Console.WriteLine($&quot;âœ“ Written {data.Length} bytes to {fileName}&quot;);
            }

            // READING from file using FileStream
            using (FileStream readStream = new FileStream(fileName, FileMode.Open, FileAccess.Read))
            {
                byte[] buffer = new byte[readStream.Length];
                int bytesRead = readStream.Read(buffer, 0, buffer.Length);

                string content = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                Console.WriteLine($&quot;âœ“ Read {bytesRead} bytes from {fileName}&quot;);
                Console.WriteLine($&quot;Content: {content}&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
        finally
        {
            // Cleanup
            if (File.Exists(fileName))
                File.Delete(fileName);
        }

        Console.WriteLine();
    }

    public static void StreamWriterReaderDemo()
    {
        Console.WriteLine(&quot;2. StreamWriter and StreamReader:&quot;);

        string fileName = &quot;text_stream_demo.txt&quot;;

        try
        {
            // WRITING text using StreamWriter
            using (FileStream fileStream = new FileStream(fileName, FileMode.Create))
            using (StreamWriter writer = new StreamWriter(fileStream, Encoding.UTF8))
            {
                writer.WriteLine(&quot;=== Student Records ===&quot;);
                writer.WriteLine($&quot;Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}&quot;);
                writer.WriteLine();

                // Write multiple lines
                string[] students = {
                    &quot;John Doe, 23, Computer Science&quot;,
                    &quot;Jane Smith, 22, Mathematics&quot;,
                    &quot;Bob Johnson, 24, Physics&quot;,
                    &quot;Alice Brown, 21, Chemistry&quot;
                };

                foreach (string student in students)
                {
                    writer.WriteLine(student);
                }

                writer.WriteLine();
                writer.WriteLine($&quot;Total students: {students.Length}&quot;);

                Console.WriteLine($&quot;âœ“ Written student records to {fileName}&quot;);
            }

            // READING text using StreamReader
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open))
            using (StreamReader reader = new StreamReader(fileStream, Encoding.UTF8))
            {
                Console.WriteLine(&quot;âœ“ Reading content from file:&quot;);

                string line;
                int lineNumber = 1;

                while ((line = reader.ReadLine()) != null)
                {
                    Console.WriteLine($&quot;Line {lineNumber:D2}: {line}&quot;);
                    lineNumber++;
                }

                // Alternative: Read entire file at once
                // string allContent = reader.ReadToEnd();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
        finally
        {
            if (File.Exists(fileName))
                File.Delete(fileName);
        }

        Console.WriteLine();
    }

    public static void BinaryStreamDemo()
    {
        Console.WriteLine(&quot;3. Binary Stream Operations:&quot;);

        string fileName = &quot;binary_stream_demo.dat&quot;;

        try
        {
            // WRITING binary data
            using (FileStream fileStream = new FileStream(fileName, FileMode.Create))
            using (BinaryWriter writer = new BinaryWriter(fileStream))
            {
                // Write different data types
                writer.Write(42);                          // int
                writer.Write(3.14159);                     // double
                writer.Write(&quot;Binary Stream Demo&quot;);        // string
                writer.Write(true);                        // bool
                writer.Write(DateTime.Now.ToBinary());     // DateTime as binary

                // Write array
                int[] numbers = { 1, 2, 3, 4, 5 };
                writer.Write(numbers.Length);
                foreach (int number in numbers)
                {
                    writer.Write(number);
                }

                Console.WriteLine(&quot;âœ“ Written binary data to file&quot;);
            }

            // READING binary data
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open))
            using (BinaryReader reader = new BinaryReader(fileStream))
            {
                int intValue = reader.ReadInt32();
                double doubleValue = reader.ReadDouble();
                string stringValue = reader.ReadString();
                bool boolValue = reader.ReadBoolean();
                DateTime dateValue = DateTime.FromBinary(reader.ReadInt64());

                Console.WriteLine(&quot;âœ“ Read binary data from file:&quot;);
                Console.WriteLine($&quot;  Integer: {intValue}&quot;);
                Console.WriteLine($&quot;  Double: {doubleValue}&quot;);
                Console.WriteLine($&quot;  String: {stringValue}&quot;);
                Console.WriteLine($&quot;  Boolean: {boolValue}&quot;);
                Console.WriteLine($&quot;  DateTime: {dateValue:yyyy-MM-dd HH:mm:ss}&quot;);

                // Read array
                int arrayLength = reader.ReadInt32();
                int[] numbers = new int[arrayLength];
                for (int i = 0; i &lt; arrayLength; i++)
                {
                    numbers[i] = reader.ReadInt32();
                }
                Console.WriteLine($&quot;  Array: [{string.Join(&quot;, &quot;, numbers)}]&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
        finally
        {
            if (File.Exists(fileName))
                File.Delete(fileName);
        }

        Console.WriteLine();
    }

    public static void MemoryStreamDemo()
    {
        Console.WriteLine(&quot;4. Memory Stream Operations:&quot;);

        try
        {
            // Create and work with MemoryStream
            using (MemoryStream memoryStream = new MemoryStream())
            {
                // Write to memory stream
                string data = &quot;This data is stored in memory, not on disk!&quot;;
                byte[] bytes = Encoding.UTF8.GetBytes(data);

                memoryStream.Write(bytes, 0, bytes.Length);
                Console.WriteLine($&quot;âœ“ Written {bytes.Length} bytes to memory stream&quot;);

                // Reset position to beginning
                memoryStream.Position = 0;

                // Read from memory stream
                byte[] readBuffer = new byte[memoryStream.Length];
                int bytesRead = memoryStream.Read(readBuffer, 0, readBuffer.Length);

                string readData = Encoding.UTF8.GetString(readBuffer, 0, bytesRead);
                Console.WriteLine($&quot;âœ“ Read {bytesRead} bytes from memory stream&quot;);
                Console.WriteLine($&quot;Content: {readData}&quot;);

                // Get all data as byte array
                byte[] allData = memoryStream.ToArray();
                Console.WriteLine($&quot;Total memory stream size: {allData.Length} bytes&quot;);
            }

            // Memory stream with initial data
            byte[] initialData = Encoding.UTF8.GetBytes(&quot;Initial memory data&quot;);
            using (MemoryStream preloadedStream = new MemoryStream(initialData))
            {
                using (StreamReader reader = new StreamReader(preloadedStream))
                {
                    string content = reader.ReadToEnd();
                    Console.WriteLine($&quot;Preloaded content: {content}&quot;);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }

        Console.WriteLine();
    }

    public static void BufferedStreamDemo()
    {
        Console.WriteLine(&quot;5. Buffered Stream Operations:&quot;);

        string fileName = &quot;buffered_stream_demo.txt&quot;;

        try
        {
            // Writing with BufferedStream
            using (FileStream fileStream = new FileStream(fileName, FileMode.Create))
            using (BufferedStream bufferedStream = new BufferedStream(fileStream, 4096)) // 4KB buffer
            {
                byte[] data = Encoding.UTF8.GetBytes(&quot;Buffered stream improves performance for small, frequent operations.\n&quot;);

                // Write the same data multiple times
                for (int i = 0; i &lt; 100; i++)
                {
                    bufferedStream.Write(data, 0, data.Length);
                }

                Console.WriteLine(&quot;âœ“ Written data using BufferedStream&quot;);
            }

            // Reading with BufferedStream
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open))
            using (BufferedStream bufferedStream = new BufferedStream(fileStream, 4096))
            {
                byte[] buffer = new byte[1024];
                int totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = bufferedStream.Read(buffer, 0, buffer.Length)) &gt; 0)
                {
                    totalBytesRead += bytesRead;
                }

                Console.WriteLine($&quot;âœ“ Read {totalBytesRead} bytes using BufferedStream&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
        finally
        {
            if (File.Exists(fileName))
                File.Delete(fileName);
        }

        Console.WriteLine();
    }

    public static void AdvancedStreamOperations()
    {
        Console.WriteLine(&quot;6. Advanced Stream Operations:&quot;);

        string fileName = &quot;advanced_stream_demo.json&quot;;

        try
        {
            // Create complex data structure
            var studentData = new
            {
                Students = new[]
                {
                    new { Name = &quot;John Doe&quot;, Age = 23, GPA = 3.75 },
                    new { Name = &quot;Jane Smith&quot;, Age = 22, GPA = 3.95 },
                    new { Name = &quot;Bob Johnson&quot;, Age = 24, GPA = 3.60 }
                },
                CourseCode = &quot;CS101&quot;,
                Semester = &quot;Fall 2024&quot;
            };

            // Write JSON-like data
            using (FileStream fileStream = new FileStream(fileName, FileMode.Create))
            using (StreamWriter writer = new StreamWriter(fileStream, Encoding.UTF8))
            {
                writer.WriteLine(&quot;{&quot;);
                writer.WriteLine($&quot;  \&quot;CourseCode\&quot;: \&quot;{studentData.CourseCode}\&quot;,&quot;);
                writer.WriteLine($&quot;  \&quot;Semester\&quot;: \&quot;{studentData.Semester}\&quot;,&quot;);
                writer.WriteLine(&quot;  \&quot;Students\&quot;: [&quot;);

                for (int i = 0; i &lt; studentData.Students.Length; i++)
                {
                    var student = studentData.Students[i];
                    writer.WriteLine(&quot;    {&quot;);
                    writer.WriteLine($&quot;      \&quot;Name\&quot;: \&quot;{student.Name}\&quot;,&quot;);
                    writer.WriteLine($&quot;      \&quot;Age\&quot;: {student.Age},&quot;);
                    writer.WriteLine($&quot;      \&quot;GPA\&quot;: {student.GPA}&quot;);
                    writer.Write(&quot;    }&quot;);

                    if (i &lt; studentData.Students.Length - 1)
                        writer.WriteLine(&quot;,&quot;);
                    else
                        writer.WriteLine();
                }

                writer.WriteLine(&quot;  ]&quot;);
                writer.WriteLine(&quot;}&quot;);
            }

            Console.WriteLine(&quot;âœ“ Written JSON-like data to file&quot;);

            // Read and parse the data
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open))
            using (StreamReader reader = new StreamReader(fileStream))
            {
                Console.WriteLine(&quot;âœ“ File contents:&quot;);

                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    Console.WriteLine($&quot;  {line}&quot;);
                }
            }

            // Demonstrate stream copying
            CopyStreamDemo(fileName);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
        finally
        {
            if (File.Exists(fileName))
                File.Delete(fileName);
            if (File.Exists(&quot;copied_&quot; + fileName))
                File.Delete(&quot;copied_&quot; + fileName);
        }
    }

    public static void CopyStreamDemo(string sourceFileName)
    {
        string targetFileName = &quot;copied_&quot; + sourceFileName;

        try
        {
            using (FileStream source = new FileStream(sourceFileName, FileMode.Open, FileAccess.Read))
            using (FileStream target = new FileStream(targetFileName, FileMode.Create, FileAccess.Write))
            {
                source.CopyTo(target);
                Console.WriteLine($&quot;âœ“ Copied {sourceFileName} to {targetFileName}&quot;);
            }

            // Verify copy
            FileInfo sourceInfo = new FileInfo(sourceFileName);
            FileInfo targetInfo = new FileInfo(targetFileName);

            Console.WriteLine($&quot;Source size: {sourceInfo.Length} bytes&quot;);
            Console.WriteLine($&quot;Target size: {targetInfo.Length} bytes&quot;);
            Console.WriteLine($&quot;Copy successful: {sourceInfo.Length == targetInfo.Length}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Copy error: {ex.Message}&quot;);
        }
    }
}

// Utility class for stream operations
public static class StreamUtilities
{
    // Read entire file as string
    public static string ReadAllText(string fileName)
    {
        using (FileStream stream = new FileStream(fileName, FileMode.Open))
        using (StreamReader reader = new StreamReader(stream))
        {
            return reader.ReadToEnd();
        }
    }

    // Write string to file
    public static void WriteAllText(string fileName, string content)
    {
        using (FileStream stream = new FileStream(fileName, FileMode.Create))
        using (StreamWriter writer = new StreamWriter(stream))
        {
            writer.Write(content);
        }
    }

    // Append text to file
    public static void AppendText(string fileName, string content)
    {
        using (FileStream stream = new FileStream(fileName, FileMode.Append))
        using (StreamWriter writer = new StreamWriter(stream))
        {
            writer.WriteLine(content);
        }
    }

    // Count lines in a text file
    public static int CountLines(string fileName)
    {
        int lineCount = 0;
        using (FileStream stream = new FileStream(fileName, FileMode.Open))
        using (StreamReader reader = new StreamReader(stream))
        {
            while (reader.ReadLine() != null)
            {
                lineCount++;
            }
        }
        return lineCount;
    }

    // Convert stream to byte array
    public static byte[] StreamToByteArray(Stream stream)
    {
        using (MemoryStream memoryStream = new MemoryStream())
        {
            stream.CopyTo(memoryStream);
            return memoryStream.ToArray();
        }
    }
}

// Custom stream wrapper example
public class LoggingStream : Stream
{
    private Stream baseStream;
    private string logPrefix;

    public LoggingStream(Stream baseStream, string logPrefix)
    {
        this.baseStream = baseStream;
        this.logPrefix = logPrefix;
    }

    public override bool CanRead =&gt; baseStream.CanRead;
    public override bool CanSeek =&gt; baseStream.CanSeek;
    public override bool CanWrite =&gt; baseStream.CanWrite;
    public override long Length =&gt; baseStream.Length;

    public override long Position
    {
        get =&gt; baseStream.Position;
        set =&gt; baseStream.Position = value;
    }

    public override void Flush()
    {
        Console.WriteLine($&quot;{logPrefix}: Flushing stream&quot;);
        baseStream.Flush();
    }

    public override int Read(byte[] buffer, int offset, int count)
    {
        int bytesRead = baseStream.Read(buffer, offset, count);
        Console.WriteLine($&quot;{logPrefix}: Read {bytesRead} bytes&quot;);
        return bytesRead;
    }

    public override long Seek(long offset, SeekOrigin origin)
    {
        long position = baseStream.Seek(offset, origin);
        Console.WriteLine($&quot;{logPrefix}: Seek to position {position}&quot;);
        return position;
    }

    public override void SetLength(long value)
    {
        Console.WriteLine($&quot;{logPrefix}: Set length to {value}&quot;);
        baseStream.SetLength(value);
    }

    public override void Write(byte[] buffer, int offset, int count)
    {
        Console.WriteLine($&quot;{logPrefix}: Writing {count} bytes&quot;);
        baseStream.Write(buffer, offset, count);
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            Console.WriteLine($&quot;{logPrefix}: Disposing stream&quot;);
            baseStream?.Dispose();
        }
        base.Dispose(disposing);
    }
}
</code></pre>
<h4 id="types-of-streams-in-c">Types of Streams in C#:</h4>
<table>
<thead>
<tr>
<th>Stream Type</th>
<th>Purpose</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FileStream</strong></td>
<td>File I/O operations</td>
<td>Reading/writing files</td>
</tr>
<tr>
<td><strong>MemoryStream</strong></td>
<td>In-memory data</td>
<td>Temporary data storage</td>
</tr>
<tr>
<td><strong>NetworkStream</strong></td>
<td>Network communication</td>
<td>TCP/UDP data transfer</td>
</tr>
<tr>
<td><strong>BufferedStream</strong></td>
<td>Buffered I/O</td>
<td>Performance improvement</td>
</tr>
<tr>
<td><strong>StreamReader/Writer</strong></td>
<td>Text operations</td>
<td>Reading/writing text</td>
</tr>
<tr>
<td><strong>BinaryReader/Writer</strong></td>
<td>Binary operations</td>
<td>Reading/writing binary data</td>
</tr>
</tbody>
</table>
<h4 id="key-stream-properties">Key Stream Properties:</h4>
<ul>
<li><strong>CanRead</strong>: Whether stream supports reading</li>
<li><strong>CanWrite</strong>: Whether stream supports writing</li>
<li><strong>CanSeek</strong>: Whether stream supports seeking</li>
<li><strong>Length</strong>: Total length of stream</li>
<li><strong>Position</strong>: Current position in stream</li>
</ul>
<h4 id="best-practices-2">Best Practices:</h4>
<ol>
<li><strong>Always use <code>using</code> statements</strong> for automatic disposal</li>
<li><strong>Choose appropriate stream type</strong> for your data</li>
<li><strong>Use buffered streams</strong> for frequent small operations</li>
<li><strong>Handle exceptions</strong> properly</li>
<li><strong>Set appropriate buffer sizes</strong> for performance</li>
<li><strong>Close streams explicitly</strong> or use <code>using</code> blocks</li>
</ol>
<h3 id="question-24-write-a-program-to-create-a-thread-along-with-main-thread">Question 24: Write a program to create a thread along with main thread.</h3>
<pre><code class="language-csharp">using System;
using System.Threading;

public class ThreadDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Threading Demonstration ===\n&quot;);

        // Show main thread information
        ShowMainThreadInfo();

        // Basic thread creation
        BasicThreadCreation();

        // Thread with parameters
        ThreadWithParameters();

        // Multiple threads
        MultipleThreadsDemo();

        // Thread synchronization
        ThreadSynchronizationDemo();

        // Background vs Foreground threads
        BackgroundThreadDemo();

        Console.WriteLine(&quot;\n=== Main thread ending ===&quot;);
    }

    public static void ShowMainThreadInfo()
    {
        Thread mainThread = Thread.CurrentThread;
        Console.WriteLine(&quot;MAIN THREAD INFORMATION:&quot;);
        Console.WriteLine($&quot;Thread ID: {mainThread.ManagedThreadId}&quot;);
        Console.WriteLine($&quot;Thread Name: {mainThread.Name ?? &quot;Not Set&quot;}&quot;);
        Console.WriteLine($&quot;Is Background: {mainThread.IsBackground}&quot;);
        Console.WriteLine($&quot;Thread State: {mainThread.ThreadState}&quot;);
        Console.WriteLine($&quot;Priority: {mainThread.Priority}&quot;);
        Console.WriteLine();

        // Set main thread name
        mainThread.Name = &quot;MainThread&quot;;
    }

    public static void BasicThreadCreation()
    {
        Console.WriteLine(&quot;1. BASIC THREAD CREATION:&quot;);

        // Create and start a new thread
        Thread workerThread = new Thread(WorkerMethod);
        workerThread.Name = &quot;WorkerThread1&quot;;

        Console.WriteLine($&quot;Main thread: Creating worker thread...&quot;);
        workerThread.Start();

        // Main thread continues its work
        for (int i = 0; i &lt; 5; i++)
        {
            Console.WriteLine($&quot;Main thread: Working step {i + 1}&quot;);
            Thread.Sleep(500); // Sleep for 500ms
        }

        // Wait for worker thread to complete
        workerThread.Join();
        Console.WriteLine(&quot;Main thread: Worker thread completed\n&quot;);
    }

    public static void WorkerMethod()
    {
        Thread currentThread = Thread.CurrentThread;
        Console.WriteLine($&quot;Worker thread started - ID: {currentThread.ManagedThreadId}, Name: {currentThread.Name}&quot;);

        for (int i = 0; i &lt; 5; i++)
        {
            Console.WriteLine($&quot;  Worker thread: Task {i + 1} executing...&quot;);
            Thread.Sleep(700); // Simulate work
        }

        Console.WriteLine(&quot;Worker thread finished&quot;);
    }

    public static void ThreadWithParameters()
    {
        Console.WriteLine(&quot;2. THREAD WITH PARAMETERS:&quot;);

        // Using ParameterizedThreadStart
        Thread paramThread = new Thread(ParameterizedWorker);
        paramThread.Name = &quot;ParameterThread&quot;;

        // Pass parameter to thread
        string message = &quot;Hello from parameterized thread!&quot;;
        paramThread.Start(message);

        // Using lambda expression with captured variables
        int count = 3;
        string prefix = &quot;Lambda&quot;;

        Thread lambdaThread = new Thread(() =&gt; LambdaWorker(count, prefix));
        lambdaThread.Name = &quot;LambdaThread&quot;;
        lambdaThread.Start();

        // Wait for both threads
        paramThread.Join();
        lambdaThread.Join();

        Console.WriteLine();
    }

    public static void ParameterizedWorker(object parameter)
    {
        string message = parameter as string;
        Thread currentThread = Thread.CurrentThread;

        Console.WriteLine($&quot;Parameterized worker started - Thread: {currentThread.Name}&quot;);
        Console.WriteLine($&quot;Received parameter: {message}&quot;);

        for (int i = 0; i &lt; 3; i++)
        {
            Console.WriteLine($&quot;  {currentThread.Name}: Processing {i + 1}&quot;);
            Thread.Sleep(400);
        }
    }

    public static void LambdaWorker(int count, string prefix)
    {
        Thread currentThread = Thread.CurrentThread;
        Console.WriteLine($&quot;Lambda worker started - Thread: {currentThread.Name}&quot;);

        for (int i = 0; i &lt; count; i++)
        {
            Console.WriteLine($&quot;  {prefix} thread: Item {i + 1}&quot;);
            Thread.Sleep(300);
        }
    }

    public static void MultipleThreadsDemo()
    {
        Console.WriteLine(&quot;3. MULTIPLE THREADS:&quot;);

        // Create array of threads
        Thread[] threads = new Thread[3];

        for (int i = 0; i &lt; threads.Length; i++)
        {
            int threadNumber = i + 1; // Capture loop variable
            threads[i] = new Thread(() =&gt; MultiWorker(threadNumber));
            threads[i].Name = $&quot;MultiThread{threadNumber}&quot;;
            threads[i].Start();
        }

        Console.WriteLine(&quot;Main thread: All worker threads started&quot;);

        // Wait for all threads to complete
        foreach (Thread thread in threads)
        {
            thread.Join();
        }

        Console.WriteLine(&quot;Main thread: All worker threads completed\n&quot;);
    }

    public static void MultiWorker(int threadNumber)
    {
        Thread currentThread = Thread.CurrentThread;

        for (int i = 0; i &lt; 4; i++)
        {
            Console.WriteLine($&quot;  Thread {threadNumber}: Step {i + 1} (ID: {currentThread.ManagedThreadId})&quot;);
            Thread.Sleep(200 * threadNumber); // Different sleep times
        }
    }

    // Shared resource for synchronization demo
    private static int sharedCounter = 0;
    private static readonly object lockObject = new object();

    public static void ThreadSynchronizationDemo()
    {
        Console.WriteLine(&quot;4. THREAD SYNCHRONIZATION:&quot;);

        sharedCounter = 0;

        // Create threads that access shared resource
        Thread[] syncThreads = new Thread[3];

        for (int i = 0; i &lt; syncThreads.Length; i++)
        {
            int threadId = i + 1;
            syncThreads[i] = new Thread(() =&gt; SynchronizedWorker(threadId));
            syncThreads[i].Name = $&quot;SyncThread{threadId}&quot;;
            syncThreads[i].Start();
        }

        // Wait for all threads
        foreach (Thread thread in syncThreads)
        {
            thread.Join();
        }

        Console.WriteLine($&quot;Final shared counter value: {sharedCounter}&quot;);
        Console.WriteLine();
    }

    public static void SynchronizedWorker(int threadId)
    {
        for (int i = 0; i &lt; 5; i++)
        {
            // Synchronize access to shared resource
            lock (lockObject)
            {
                int currentValue = sharedCounter;
                Console.WriteLine($&quot;  Thread {threadId}: Reading counter = {currentValue}&quot;);

                // Simulate some processing time
                Thread.Sleep(10);

                sharedCounter = currentValue + 1;
                Console.WriteLine($&quot;  Thread {threadId}: Updated counter = {sharedCounter}&quot;);
            }

            // Do some work outside the lock
            Thread.Sleep(50);
        }
    }

    public static void BackgroundThreadDemo()
    {
        Console.WriteLine(&quot;5. BACKGROUND vs FOREGROUND THREADS:&quot;);

        // Foreground thread (default)
        Thread foregroundThread = new Thread(LongRunningTask);
        foregroundThread.Name = &quot;ForegroundThread&quot;;
        foregroundThread.IsBackground = false;

        // Background thread
        Thread backgroundThread = new Thread(LongRunningTask);
        backgroundThread.Name = &quot;BackgroundThread&quot;;
        backgroundThread.IsBackground = true;

        Console.WriteLine(&quot;Starting foreground and background threads...&quot;);

        foregroundThread.Start();
        backgroundThread.Start();

        // Wait for foreground thread only
        // Background thread will be terminated when main thread ends
        foregroundThread.Join();

        Console.WriteLine(&quot;Foreground thread completed&quot;);
    }

    public static void LongRunningTask()
    {
        Thread currentThread = Thread.CurrentThread;

        for (int i = 0; i &lt; 10; i++)
        {
            Console.WriteLine($&quot;  {currentThread.Name}: Long task step {i + 1}&quot;);
            Thread.Sleep(200);

            // Check if thread should abort
            if (currentThread.IsBackground &amp;&amp; i &gt; 5)
            {
                Console.WriteLine($&quot;  {currentThread.Name}: Background thread may be terminated soon&quot;);
            }
        }

        Console.WriteLine($&quot;  {currentThread.Name}: Long task completed&quot;);
    }
}

// Advanced threading examples
public class AdvancedThreadingDemo
{
    private static AutoResetEvent autoEvent = new AutoResetEvent(false);
    private static ManualResetEvent manualEvent = new ManualResetEvent(false);

    public static void WaitHandleDemo()
    {
        Console.WriteLine(&quot;\n6. WAIT HANDLES DEMONSTRATION:&quot;);

        // AutoResetEvent example
        Thread autoResetThread = new Thread(AutoResetWorker);
        autoResetThread.Name = &quot;AutoResetThread&quot;;
        autoResetThread.Start();

        Thread.Sleep(1000);
        Console.WriteLine(&quot;Main: Signaling AutoResetEvent&quot;);
        autoEvent.Set(); // Signal the waiting thread

        autoResetThread.Join();

        // ManualResetEvent example
        Thread[] manualResetThreads = new Thread[3];

        for (int i = 0; i &lt; manualResetThreads.Length; i++)
        {
            int threadNum = i + 1;
            manualResetThreads[i] = new Thread(() =&gt; ManualResetWorker(threadNum));
            manualResetThreads[i].Name = $&quot;ManualResetThread{threadNum}&quot;;
            manualResetThreads[i].Start();
        }

        Thread.Sleep(1000);
        Console.WriteLine(&quot;Main: Signaling ManualResetEvent (all threads will proceed)&quot;);
        manualEvent.Set(); // Signal all waiting threads

        foreach (Thread thread in manualResetThreads)
        {
            thread.Join();
        }

        Console.WriteLine();
    }

    public static void AutoResetWorker()
    {
        Console.WriteLine(&quot;AutoReset worker: Waiting for signal...&quot;);
        autoEvent.WaitOne(); // Wait for signal
        Console.WriteLine(&quot;AutoReset worker: Received signal, continuing work&quot;);

        Thread.Sleep(500);
        Console.WriteLine(&quot;AutoReset worker: Work completed&quot;);
    }

    public static void ManualResetWorker(int threadNumber)
    {
        Console.WriteLine($&quot;ManualReset worker {threadNumber}: Waiting for signal...&quot;);
        manualEvent.WaitOne(); // Wait for signal
        Console.WriteLine($&quot;ManualReset worker {threadNumber}: Received signal, doing work&quot;);

        Thread.Sleep(300 * threadNumber);
        Console.WriteLine($&quot;ManualReset worker {threadNumber}: Work completed&quot;);
    }
}

// Producer-Consumer pattern example
public class ProducerConsumerDemo
{
    private static Queue&lt;int&gt; queue = new Queue&lt;int&gt;();
    private static readonly object queueLock = new object();
    private static bool stopProducing = false;

    public static void RunDemo()
    {
        Console.WriteLine(&quot;\n7. PRODUCER-CONSUMER PATTERN:&quot;);

        // Create producer thread
        Thread producer = new Thread(Producer);
        producer.Name = &quot;Producer&quot;;
        producer.Start();

        // Create consumer threads
        Thread consumer1 = new Thread(Consumer);
        Thread consumer2 = new Thread(Consumer);
        consumer1.Name = &quot;Consumer1&quot;;
        consumer2.Name = &quot;Consumer2&quot;;

        consumer1.Start();
        consumer2.Start();

        // Let them run for a while
        Thread.Sleep(3000);

        // Signal to stop producing
        stopProducing = true;

        // Wait for all threads
        producer.Join();
        consumer1.Join();
        consumer2.Join();

        Console.WriteLine(&quot;Producer-Consumer demo completed\n&quot;);
    }

    public static void Producer()
    {
        int item = 1;

        while (!stopProducing)
        {
            lock (queueLock)
            {
                queue.Enqueue(item);
                Console.WriteLine($&quot;Producer: Produced item {item}&quot;);
                item++;
            }

            Thread.Sleep(100); // Produce every 100ms
        }

        Console.WriteLine(&quot;Producer: Stopped producing&quot;);
    }

    public static void Consumer()
    {
        Thread currentThread = Thread.CurrentThread;

        while (!stopProducing || queue.Count &gt; 0)
        {
            int item = -1;
            bool hasItem = false;

            lock (queueLock)
            {
                if (queue.Count &gt; 0)
                {
                    item = queue.Dequeue();
                    hasItem = true;
                }
            }

            if (hasItem)
            {
                Console.WriteLine($&quot;{currentThread.Name}: Consumed item {item}&quot;);
                Thread.Sleep(150); // Simulate processing time
            }
            else
            {
                Thread.Sleep(50); // Wait a bit before checking again
            }
        }

        Console.WriteLine($&quot;{currentThread.Name}: Stopped consuming&quot;);
    }
}
</code></pre>
<h4 id="key-threading-concepts">Key Threading Concepts:</h4>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
<th>Example Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Thread Creation</strong></td>
<td><code>new Thread(method)</code></td>
<td>Basic thread creation</td>
</tr>
<tr>
<td><strong>Thread.Start()</strong></td>
<td>Begin thread execution</td>
<td>Start the thread</td>
</tr>
<tr>
<td><strong>Thread.Join()</strong></td>
<td>Wait for thread completion</td>
<td>Synchronize threads</td>
</tr>
<tr>
<td><strong>Thread.Sleep()</strong></td>
<td>Pause thread execution</td>
<td>Delay operations</td>
</tr>
<tr>
<td><strong>Lock statement</strong></td>
<td>Synchronize access</td>
<td>Protect shared resources</td>
</tr>
<tr>
<td><strong>Background threads</strong></td>
<td>Die with main thread</td>
<td>Service operations</td>
</tr>
</tbody>
</table>
<h4 id="thread-states">Thread States:</h4>
<ul>
<li><strong>Unstarted</strong>: Created but not started</li>
<li><strong>Running</strong>: Currently executing</li>
<li><strong>WaitSleepJoin</strong>: Waiting or sleeping</li>
<li><strong>Stopped</strong>: Execution completed</li>
<li><strong>Aborted</strong>: Thread was aborted</li>
</ul>
<h4 id="best-practices-3">Best Practices:</h4>
<ol>
<li><strong>Use <code>Thread.Join()</code></strong> to wait for thread completion</li>
<li><strong>Synchronize access</strong> to shared resources with <code>lock</code></li>
<li><strong>Set meaningful thread names</strong> for debugging</li>
<li><strong>Handle exceptions</strong> within thread methods</li>
<li><strong>Consider using <code>Task</code></strong> instead of <code>Thread</code> for newer applications</li>
<li><strong>Use background threads</strong> for cleanup operations</li>
</ol>
<h3 id="question-25-what-is-polymorphism-explain-with-a-brief-example">Question 25: What is polymorphism? Explain with a brief example.</h3>
<h4 id="what-is-polymorphism">What is Polymorphism?</h4>
<p><strong>Polymorphism</strong> (Greek: &quot;many forms&quot;) is an Object-Oriented Programming principle that allows objects of different types to be treated as instances of the same base type, while each object maintains its own specific behavior.</p>
<h4 id="types-of-polymorphism-in-c">Types of Polymorphism in C#:</h4>
<ol>
<li><strong>Compile-time Polymorphism</strong> (Method Overloading, Operator Overloading)</li>
<li><strong>Runtime Polymorphism</strong> (Method Overriding, Interface Implementation)</li>
</ol>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;

// Base class for runtime polymorphism
public abstract class Animal
{
    public string Name { get; set; }
    public int Age { get; set; }

    public Animal(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Virtual method - can be overridden
    public virtual void MakeSound()
    {
        Console.WriteLine($&quot;{Name} makes a generic animal sound&quot;);
    }

    // Abstract method - must be overridden
    public abstract void Move();

    // Regular method - inherited as-is
    public void DisplayInfo()
    {
        Console.WriteLine($&quot;Animal: {Name}, Age: {Age}&quot;);
    }
}

// Derived classes demonstrating polymorphism
public class Dog : Animal
{
    public string Breed { get; set; }

    public Dog(string name, int age, string breed) : base(name, age)
    {
        Breed = breed;
    }

    // Override virtual method - Runtime Polymorphism
    public override void MakeSound()
    {
        Console.WriteLine($&quot;{Name} the {Breed} says: Woof! Woof!&quot;);
    }

    // Override abstract method
    public override void Move()
    {
        Console.WriteLine($&quot;{Name} runs around energetically&quot;);
    }

    // Dog-specific method
    public void Fetch()
    {
        Console.WriteLine($&quot;{Name} fetches the ball&quot;);
    }
}

public class Cat : Animal
{
    public bool IsIndoor { get; set; }

    public Cat(string name, int age, bool isIndoor) : base(name, age)
    {
        IsIndoor = isIndoor;
    }

    public override void MakeSound()
    {
        Console.WriteLine($&quot;{Name} the cat says: Meow! Meow!&quot;);
    }

    public override void Move()
    {
        Console.WriteLine($&quot;{Name} moves gracefully and silently&quot;);
    }

    public void Purr()
    {
        Console.WriteLine($&quot;{Name} purrs contentedly&quot;);
    }
}

public class Bird : Animal
{
    public bool CanFly { get; set; }

    public Bird(string name, int age, bool canFly) : base(name, age)
    {
        CanFly = canFly;
    }

    public override void MakeSound()
    {
        Console.WriteLine($&quot;{Name} the bird says: Tweet! Tweet!&quot;);
    }

    public override void Move()
    {
        if (CanFly)
            Console.WriteLine($&quot;{Name} soars through the sky&quot;);
        else
            Console.WriteLine($&quot;{Name} hops around on the ground&quot;);
    }

    public void BuildNest()
    {
        Console.WriteLine($&quot;{Name} builds a cozy nest&quot;);
    }
}

// Interface for polymorphism
public interface IPlayable
{
    void Play();
    void Rest();
}

// Classes implementing interface polymorphism
public class PlayfulDog : Dog, IPlayable
{
    public PlayfulDog(string name, int age, string breed) : base(name, age, breed)
    {
    }

    public void Play()
    {
        Console.WriteLine($&quot;{Name} plays fetch and runs around happily&quot;);
    }

    public void Rest()
    {
        Console.WriteLine($&quot;{Name} takes a nap in the sun&quot;);
    }
}

public class PlayfulCat : Cat, IPlayable
{
    public PlayfulCat(string name, int age, bool isIndoor) : base(name, age, isIndoor)
    {
    }

    public void Play()
    {
        Console.WriteLine($&quot;{Name} plays with a ball of yarn&quot;);
    }

    public void Rest()
    {
        Console.WriteLine($&quot;{Name} curls up for a cozy nap&quot;);
    }
}

// Demonstration of compile-time polymorphism (Method Overloading)
public class Calculator
{
    // Method overloading - same name, different parameters
    public int Add(int a, int b)
    {
        Console.WriteLine(&quot;Adding two integers&quot;);
        return a + b;
    }

    public double Add(double a, double b)
    {
        Console.WriteLine(&quot;Adding two doubles&quot;);
        return a + b;
    }

    public int Add(int a, int b, int c)
    {
        Console.WriteLine(&quot;Adding three integers&quot;);
        return a + b + c;
    }

    public string Add(string a, string b)
    {
        Console.WriteLine(&quot;Concatenating two strings&quot;);
        return a + b;
    }
}

// Main demonstration program
public class PolymorphismDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Polymorphism Demonstration ===\n&quot;);

        // Runtime Polymorphism Demo
        RuntimePolymorphismDemo();

        // Interface Polymorphism Demo
        InterfacePolymorphismDemo();

        // Compile-time Polymorphism Demo
        CompileTimePolymorphismDemo();

        // Advanced Polymorphism Examples
        AdvancedPolymorphismDemo();
    }

    public static void RuntimePolymorphismDemo()
    {
        Console.WriteLine(&quot;1. RUNTIME POLYMORPHISM (Method Overriding):&quot;);

        // Create array of Animal references pointing to different derived objects
        Animal[] animals = {
            new Dog(&quot;Buddy&quot;, 5, &quot;Golden Retriever&quot;),
            new Cat(&quot;Whiskers&quot;, 3, true),
            new Bird(&quot;Tweety&quot;, 2, true),
            new Dog(&quot;Rex&quot;, 7, &quot;German Shepherd&quot;)
        };

        Console.WriteLine(&quot;Polymorphic behavior - same method call, different implementations:&quot;);

        foreach (Animal animal in animals)
        {
            // Polymorphic method calls
            animal.DisplayInfo();           // Inherited method
            animal.MakeSound();            // Virtual method - different implementation for each type
            animal.Move();                 // Abstract method - must be implemented by each type
            Console.WriteLine();
        }

        // Demonstrate virtual method behavior
        Console.WriteLine(&quot;Virtual method demonstration:&quot;);
        Animal genericAnimal = new Dog(&quot;Max&quot;, 4, &quot;Labrador&quot;);
        genericAnimal.MakeSound(); // Calls Dog's implementation, not Animal's

        Console.WriteLine();
    }

    public static void InterfacePolymorphismDemo()
    {
        Console.WriteLine(&quot;2. INTERFACE POLYMORPHISM:&quot;);

        // Create array of interface references
        IPlayable[] playableAnimals = {
            new PlayfulDog(&quot;Rover&quot;, 3, &quot;Beagle&quot;),
            new PlayfulCat(&quot;Mittens&quot;, 2, false),
            new PlayfulDog(&quot;Spot&quot;, 6, &quot;Dalmatian&quot;)
        };

        Console.WriteLine(&quot;Interface polymorphism - different classes, same interface:&quot;);

        foreach (IPlayable playable in playableAnimals)
        {
            playable.Play();
            playable.Rest();
            Console.WriteLine();
        }
    }

    public static void CompileTimePolymorphismDemo()
    {
        Console.WriteLine(&quot;3. COMPILE-TIME POLYMORPHISM (Method Overloading):&quot;);

        Calculator calc = new Calculator();

        // Same method name, different parameter types - resolved at compile time
        Console.WriteLine($&quot;Result 1: {calc.Add(5, 10)}&quot;);                    // int version
        Console.WriteLine($&quot;Result 2: {calc.Add(3.14, 2.86)}&quot;);               // double version
        Console.WriteLine($&quot;Result 3: {calc.Add(1, 2, 3)}&quot;);                  // three int version
        Console.WriteLine($&quot;Result 4: {calc.Add(&quot;Hello &quot;, &quot;World&quot;)}&quot;);        // string version

        Console.WriteLine();
    }

    public static void AdvancedPolymorphismDemo()
    {
        Console.WriteLine(&quot;4. ADVANCED POLYMORPHISM EXAMPLES:&quot;);

        // Polymorphic collection processing
        List&lt;Animal&gt; animalShelter = new List&lt;Animal&gt;
        {
            new Dog(&quot;Luna&quot;, 2, &quot;Husky&quot;),
            new Cat(&quot;Shadow&quot;, 4, true),
            new Bird(&quot;Phoenix&quot;, 1, false)
        };

        Console.WriteLine(&quot;Animal shelter daily routine:&quot;);
        ProcessAnimals(animalShelter);

        // Type checking and casting
        Console.WriteLine(&quot;\nType checking and specific behaviors:&quot;);
        foreach (Animal animal in animalShelter)
        {
            // Check type and call specific methods
            if (animal is Dog dog)
            {
                dog.Fetch();
            }
            else if (animal is Cat cat)
            {
                cat.Purr();
            }
            else if (animal is Bird bird)
            {
                bird.BuildNest();
            }
        }

        // Using 'as' operator
        Console.WriteLine(&quot;\nUsing 'as' operator for safe casting:&quot;);
        foreach (Animal animal in animalShelter)
        {
            Dog dog = animal as Dog;
            if (dog != null)
            {
                Console.WriteLine($&quot;{dog.Name} is a {dog.Breed}&quot;);
            }
        }

        Console.WriteLine();
    }

    // Polymorphic method - works with any Animal type
    public static void ProcessAnimals(List&lt;Animal&gt; animals)
    {
        foreach (Animal animal in animals)
        {
            Console.WriteLine($&quot;Processing {animal.GetType().Name}: {animal.Name}&quot;);
            animal.MakeSound();
            animal.Move();

            // Polymorphic feeding
            FeedAnimal(animal);
            Console.WriteLine();
        }
    }

    // Another polymorphic method
    public static void FeedAnimal(Animal animal)
    {
        switch (animal)
        {
            case Dog _:
                Console.WriteLine($&quot;Giving {animal.Name} dog food and treats&quot;);
                break;
            case Cat _:
                Console.WriteLine($&quot;Giving {animal.Name} cat food and milk&quot;);
                break;
            case Bird _:
                Console.WriteLine($&quot;Giving {animal.Name} seeds and water&quot;);
                break;
            default:
                Console.WriteLine($&quot;Giving {animal.Name} generic animal food&quot;);
                break;
        }
    }
}

// Additional polymorphism example - Shape hierarchy
public abstract class Shape
{
    public abstract double CalculateArea();
    public abstract double CalculatePerimeter();

    public virtual void DisplayInfo()
    {
        Console.WriteLine($&quot;{GetType().Name}: Area = {CalculateArea():F2}, Perimeter = {CalculatePerimeter():F2}&quot;);
    }
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }

    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
    }

    public override double CalculateArea()
    {
        return Width * Height;
    }

    public override double CalculatePerimeter()
    {
        return 2 * (Width + Height);
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }

    public Circle(double radius)
    {
        Radius = radius;
    }

    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }

    public override double CalculatePerimeter()
    {
        return 2 * Math.PI * Radius;
    }
}

public class Triangle : Shape
{
    public double Base { get; set; }
    public double Height { get; set; }
    public double Side1 { get; set; }
    public double Side2 { get; set; }

    public Triangle(double baseLength, double height, double side1, double side2)
    {
        Base = baseLength;
        Height = height;
        Side1 = side1;
        Side2 = side2;
    }

    public override double CalculateArea()
    {
        return 0.5 * Base * Height;
    }

    public override double CalculatePerimeter()
    {
        return Base + Side1 + Side2;
    }
}

// Demonstration of shape polymorphism
public class ShapeDemo
{
    public static void DemonstrateShapePolymorphism()
    {
        Console.WriteLine(&quot;5. SHAPE POLYMORPHISM EXAMPLE:&quot;);

        Shape[] shapes = {
            new Rectangle(5, 4),
            new Circle(3),
            new Triangle(6, 4, 5, 5)
        };

        Console.WriteLine(&quot;Calculating areas and perimeters polymorphically:&quot;);

        double totalArea = 0;
        foreach (Shape shape in shapes)
        {
            shape.DisplayInfo();
            totalArea += shape.CalculateArea();
        }

        Console.WriteLine($&quot;Total area of all shapes: {totalArea:F2}&quot;);
    }
}
</code></pre>
<h4 id="key-benefits-of-polymorphism">Key Benefits of Polymorphism:</h4>
<ol>
<li><strong>Code Reusability</strong>: Same interface works with different implementations</li>
<li><strong>Flexibility</strong>: Easy to add new types without changing existing code</li>
<li><strong>Maintainability</strong>: Changes in implementation don't affect client code</li>
<li><strong>Abstraction</strong>: Client code works with abstractions, not concrete types</li>
</ol>
<h4 id="polymorphism-summary">Polymorphism Summary:</h4>
<table>
<thead>
<tr>
<th>Type</th>
<th>Mechanism</th>
<th>Resolution Time</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Compile-time</strong></td>
<td>Method Overloading</td>
<td>Compile time</td>
<td><code>Add(int, int)</code> vs <code>Add(double, double)</code></td>
</tr>
<tr>
<td><strong>Runtime</strong></td>
<td>Method Overriding</td>
<td>Runtime</td>
<td>Virtual/Abstract method calls</td>
</tr>
<tr>
<td><strong>Interface</strong></td>
<td>Interface Implementation</td>
<td>Runtime</td>
<td>Different classes implementing same interface</td>
</tr>
</tbody>
</table>
<h4 id="real-world-example">Real-world Example:</h4>
<pre><code>Animal shelter = new Dog();  // Dog treated as Animal
shelter.MakeSound();         // Calls Dog's MakeSound(), not Animal's
// Output: &quot;Buddy the Golden Retriever says: Woof! Woof!&quot;
</code></pre>
<p><strong>This demonstrates polymorphism</strong>: same method call (<code>MakeSound()</code>), different behavior based on the actual object type at runtime.</p>
<h3 id="question-26-what-is-the-use-of-using-block-in-c">Question 26: What is the use of using block in C#?</h3>
<h4 id="what-is-the-using-block">What is the Using Block?</h4>
<p>The <strong>using block</strong> in C# provides a convenient syntax to ensure that resources are properly disposed of when they go out of scope. It automatically calls the <code>Dispose()</code> method on objects that implement the <code>IDisposable</code> interface.</p>
<pre><code class="language-csharp">using System;
using System.IO;
using System.Data.SqlClient;

public class UsingBlockDemo
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Using Block Demonstration ===\n&quot;);

        // File operations with using block
        FileOperationsDemo();

        // Database operations with using block
        DatabaseOperationsDemo();

        // Multiple resources in using block
        MultipleResourcesDemo();

        // Custom disposable resources
        CustomDisposableDemo();

        // Nested using blocks
        NestedUsingDemo();

        // Using block vs manual disposal
        ComparisonDemo();
    }

    public static void FileOperationsDemo()
    {
        Console.WriteLine(&quot;1. FILE OPERATIONS WITH USING BLOCK:&quot;);

        string fileName = &quot;using_demo.txt&quot;;

        // WRITING to file with using block
        using (FileStream fileStream = new FileStream(fileName, FileMode.Create))
        using (StreamWriter writer = new StreamWriter(fileStream))
        {
            writer.WriteLine(&quot;This file was created using 'using' block&quot;);
            writer.WriteLine($&quot;Created at: {DateTime.Now}&quot;);
            writer.WriteLine(&quot;The file stream will be automatically disposed&quot;);

            Console.WriteLine(&quot;âœ“ File written successfully&quot;);
            // FileStream and StreamWriter automatically disposed here
        }

        // READING from file with using block
        using (FileStream fileStream = new FileStream(fileName, FileMode.Open))
        using (StreamReader reader = new StreamReader(fileStream))
        {
            Console.WriteLine(&quot;File contents:&quot;);
            string line;
            while ((line = reader.ReadLine()) != null)
            {
                Console.WriteLine($&quot;  {line}&quot;);
            }
            // FileStream and StreamReader automatically disposed here
        }

        // Cleanup
        if (File.Exists(fileName))
            File.Delete(fileName);

        Console.WriteLine();
    }

    public static void DatabaseOperationsDemo()
    {
        Console.WriteLine(&quot;2. DATABASE OPERATIONS WITH USING BLOCK:&quot;);

        // Note: This example shows the pattern, actual connection string would be needed
        string connectionString = &quot;Server=localhost;Database=TestDB;Integrated Security=true;&quot;;

        try
        {
            // Database connection with using block
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                Console.WriteLine(&quot;âœ“ Database connection opened&quot;);

                using (SqlCommand command = new SqlCommand(&quot;SELECT COUNT(*) FROM Users&quot;, connection))
                {
                    // Simulate database operation
                    Console.WriteLine(&quot;âœ“ Executing SQL command&quot;);

                    // In real scenario, you would execute the command
                    // object result = command.ExecuteScalar();

                    Console.WriteLine(&quot;âœ“ Command executed successfully&quot;);
                    // SqlCommand automatically disposed here
                }

                Console.WriteLine(&quot;âœ“ Database operations completed&quot;);
                // SqlConnection automatically disposed here (connection closed)
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Database error: {ex.Message}&quot;);
        }

        Console.WriteLine();
    }

    public static void MultipleResourcesDemo()
    {
        Console.WriteLine(&quot;3. MULTIPLE RESOURCES WITH USING BLOCK:&quot;);

        string sourceFile = &quot;source.txt&quot;;
        string targetFile = &quot;target.txt&quot;;

        try
        {
            // Create source file
            File.WriteAllText(sourceFile, &quot;This content will be copied to another file.&quot;);

            // Multiple using statements for file copying
            using (FileStream source = new FileStream(sourceFile, FileMode.Open))
            using (FileStream target = new FileStream(targetFile, FileMode.Create))
            using (StreamReader reader = new StreamReader(source))
            using (StreamWriter writer = new StreamWriter(target))
            {
                string content = reader.ReadToEnd();
                writer.Write(content);

                Console.WriteLine(&quot;âœ“ File copied successfully using multiple using statements&quot;);
                // All four resources automatically disposed here
            }

            // Verify copy
            string copiedContent = File.ReadAllText(targetFile);
            Console.WriteLine($&quot;Copied content: {copiedContent}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;File operation error: {ex.Message}&quot;);
        }
        finally
        {
            // Cleanup
            if (File.Exists(sourceFile)) File.Delete(sourceFile);
            if (File.Exists(targetFile)) File.Delete(targetFile);
        }

        Console.WriteLine();
    }

    public static void CustomDisposableDemo()
    {
        Console.WriteLine(&quot;4. CUSTOM DISPOSABLE RESOURCES:&quot;);

        // Using custom disposable class
        using (var resource = new CustomResource(&quot;ResourceA&quot;))
        {
            resource.DoWork();
            resource.ProcessData(&quot;Important data&quot;);

            Console.WriteLine(&quot;âœ“ Custom resource work completed&quot;);
            // CustomResource.Dispose() automatically called here
        }

        // Nested using with custom resources
        using (var resource1 = new CustomResource(&quot;Resource1&quot;))
        using (var resource2 = new CustomResource(&quot;Resource2&quot;))
        {
            resource1.DoWork();
            resource2.DoWork();

            Console.WriteLine(&quot;âœ“ Multiple custom resources used&quot;);
            // Both resources automatically disposed in reverse order
        }

        Console.WriteLine();
    }

    public static void NestedUsingDemo()
    {
        Console.WriteLine(&quot;5. NESTED USING BLOCKS:&quot;);

        string outerFile = &quot;outer.txt&quot;;
        string innerFile = &quot;inner.txt&quot;;

        try
        {
            using (var outerStream = new FileStream(outerFile, FileMode.Create))
            using (var outerWriter = new StreamWriter(outerStream))
            {
                outerWriter.WriteLine(&quot;Outer file content&quot;);

                using (var innerStream = new FileStream(innerFile, FileMode.Create))
                using (var innerWriter = new StreamWriter(innerStream))
                {
                    innerWriter.WriteLine(&quot;Inner file content&quot;);

                    Console.WriteLine(&quot;âœ“ Both files written in nested using blocks&quot;);

                    // Inner resources disposed first, then outer resources
                }

                outerWriter.WriteLine(&quot;Back to outer file&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error in nested operations: {ex.Message}&quot;);
        }
        finally
        {
            if (File.Exists(outerFile)) File.Delete(outerFile);
            if (File.Exists(innerFile)) File.Delete(innerFile);
        }

        Console.WriteLine();
    }

    public static void ComparisonDemo()
    {
        Console.WriteLine(&quot;6. USING BLOCK vs MANUAL DISPOSAL:&quot;);

        // WITHOUT using block (manual disposal)
        Console.WriteLine(&quot;Manual disposal approach:&quot;);
        FileStream manualStream = null;
        StreamWriter manualWriter = null;

        try
        {
            manualStream = new FileStream(&quot;manual.txt&quot;, FileMode.Create);
            manualWriter = new StreamWriter(manualStream);

            manualWriter.WriteLine(&quot;Manually managed resources&quot;);
            Console.WriteLine(&quot;âœ“ Manual approach - resources created and used&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
        finally
        {
            // Must manually dispose in finally block
            manualWriter?.Dispose();
            manualStream?.Dispose();
            Console.WriteLine(&quot;âœ“ Manual approach - resources manually disposed&quot;);
        }

        // WITH using block (automatic disposal)
        Console.WriteLine(&quot;\nUsing block approach:&quot;);
        using (var autoStream = new FileStream(&quot;auto.txt&quot;, FileMode.Create))
        using (var autoWriter = new StreamWriter(autoStream))
        {
            autoWriter.WriteLine(&quot;Automatically managed resources&quot;);
            Console.WriteLine(&quot;âœ“ Using block approach - resources created and used&quot;);
            // Automatic disposal happens here, even if exception occurs
        }
        Console.WriteLine(&quot;âœ“ Using block approach - resources automatically disposed&quot;);

        // Cleanup
        if (File.Exists(&quot;manual.txt&quot;)) File.Delete(&quot;manual.txt&quot;);
        if (File.Exists(&quot;auto.txt&quot;)) File.Delete(&quot;auto.txt&quot;);

        Console.WriteLine();
    }
}

// Custom disposable class for demonstration
public class CustomResource : IDisposable
{
    private string resourceName;
    private bool disposed = false;

    public CustomResource(string name)
    {
        resourceName = name;
        Console.WriteLine($&quot;  {resourceName} created&quot;);
    }

    public void DoWork()
    {
        if (disposed)
            throw new ObjectDisposedException(resourceName);

        Console.WriteLine($&quot;  {resourceName} is doing work&quot;);
    }

    public void ProcessData(string data)
    {
        if (disposed)
            throw new ObjectDisposedException(resourceName);

        Console.WriteLine($&quot;  {resourceName} processing: {data}&quot;);
    }

    // IDisposable implementation
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Prevent finalizer from running
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Dispose managed resources
                Console.WriteLine($&quot;  {resourceName} disposed (managed resources cleaned up)&quot;);
            }

            // Dispose unmanaged resources
            // (None in this example)

            disposed = true;
        }
    }

    // Finalizer (destructor)
    ~CustomResource()
    {
        Dispose(false);
    }
}

// Advanced using block examples
public class AdvancedUsingExamples
{
    public static void UsingWithVariableDeclaration()
    {
        Console.WriteLine(&quot;7. USING WITH VARIABLE DECLARATION:&quot;);

        // C# 8.0+ using declaration (without block)
        using var file = new FileStream(&quot;declaration.txt&quot;, FileMode.Create);
        using var writer = new StreamWriter(file);

        writer.WriteLine(&quot;Using declaration syntax&quot;);
        Console.WriteLine(&quot;âœ“ Resources declared with 'using' keyword&quot;);

        // Resources automatically disposed at end of enclosing scope
        // No explicit block needed

        if (File.Exists(&quot;declaration.txt&quot;))
            File.Delete(&quot;declaration.txt&quot;);
    }

    public static void UsingWithExceptionHandling()
    {
        Console.WriteLine(&quot;8. USING WITH EXCEPTION HANDLING:&quot;);

        try
        {
            using (var resource = new CustomResource(&quot;ExceptionResource&quot;))
            {
                resource.DoWork();

                // Simulate an exception
                throw new InvalidOperationException(&quot;Simulated error&quot;);

                // This line won't execute
                resource.ProcessData(&quot;This won't be processed&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;  Exception caught: {ex.Message}&quot;);
            Console.WriteLine(&quot;  Resource was still properly disposed despite exception&quot;);
        }

        Console.WriteLine();
    }

    public static void UsingReturnEarly()
    {
        Console.WriteLine(&quot;9. USING WITH EARLY RETURN:&quot;);

        using (var resource = new CustomResource(&quot;EarlyReturnResource&quot;))
        {
            resource.DoWork();

            if (DateTime.Now.Millisecond &gt; 500)
            {
                Console.WriteLine(&quot;  Early return condition met&quot;);
                return; // Resource still gets disposed
            }

            resource.ProcessData(&quot;Additional processing&quot;);
        }
        // Resource disposed here if no early return

        Console.WriteLine();
    }
}
</code></pre>
<h4 id="key-benefits-of-using-block">Key Benefits of Using Block:</h4>
<table>
<thead>
<tr>
<th>Benefit</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Automatic Disposal</strong></td>
<td>Resources disposed automatically</td>
<td><code>using (var file = ...) { }</code></td>
</tr>
<tr>
<td><strong>Exception Safety</strong></td>
<td>Disposal happens even if exception occurs</td>
<td>Resources cleaned up in finally</td>
</tr>
<tr>
<td><strong>Cleaner Code</strong></td>
<td>No need for explicit try-finally blocks</td>
<td>Less boilerplate code</td>
</tr>
<tr>
<td><strong>Deterministic Cleanup</strong></td>
<td>Resources released immediately</td>
<td>Not dependent on GC timing</td>
</tr>
</tbody>
</table>
<h4 id="what-using-block-does">What Using Block Does:</h4>
<pre><code class="language-csharp">// Using block syntax:
using (FileStream fs = new FileStream(&quot;file.txt&quot;, FileMode.Create))
{
    // Use the resource
}

// Is equivalent to:
FileStream fs = new FileStream(&quot;file.txt&quot;, FileMode.Create);
try
{
    // Use the resource
}
finally
{
    fs?.Dispose(); // Always called, even if exception occurs
}
</code></pre>
<h4 id="common-use-cases">Common Use Cases:</h4>
<ol>
<li><strong>File Operations</strong>: FileStream, StreamReader, StreamWriter</li>
<li><strong>Database Connections</strong>: SqlConnection, SqlCommand</li>
<li><strong>Network Streams</strong>: NetworkStream, TcpClient</li>
<li><strong>Graphics Resources</strong>: Bitmap, Graphics objects</li>
<li><strong>Custom Resources</strong>: Any class implementing IDisposable</li>
</ol>
<h4 id="best-practices-4">Best Practices:</h4>
<ul>
<li><strong>Always use <code>using</code> blocks</strong> for IDisposable objects</li>
<li><strong>Prefer using blocks over manual disposal</strong> for exception safety</li>
<li><strong>Use multiple using statements</strong> for multiple resources</li>
<li><strong>Consider using declarations (C# 8+)</strong> for simpler syntax</li>
<li><strong>Implement IDisposable properly</strong> in custom classes</li>
</ul>
<p>The using block ensures that resources are always properly cleaned up, making your code more reliable and preventing resource leaks.</p>
<h3 id="question-27-differentiate-between-using-block-and-using-statement">Question 27: Differentiate between using block and using statement.</h3>
<h4 id="using-block-vs-using-statement-in-c">Using Block vs Using Statement in C#</h4>
<p>While often confused, &quot;using block&quot; and &quot;using statement&quot; refer to different concepts in C#. Let me clarify the differences:</p>
<pre><code class="language-csharp">using System;           // &lt;- Using STATEMENT (directive)
using System.IO;        // &lt;- Using STATEMENT (directive)
using MyAlias = System.Collections.Generic.List&lt;string&gt;; // &lt;- Using STATEMENT (alias)

public class UsingComparison
{
    public static void Main()
    {
        Console.WriteLine(&quot;=== Using Block vs Using Statement Comparison ===\n&quot;);

        // Demonstrate using statements (directives)
        UsingStatementDemo();

        // Demonstrate using blocks
        UsingBlockDemo();

        // Demonstrate using declarations (C# 8+)
        UsingDeclarationDemo();

        // Show practical differences
        PracticalDifferencesDemo();
    }

    public static void UsingStatementDemo()
    {
        Console.WriteLine(&quot;1. USING STATEMENTS (Directives):&quot;);
        Console.WriteLine(&quot;   - Located at the top of source files&quot;);
        Console.WriteLine(&quot;   - Import namespaces or create aliases&quot;);
        Console.WriteLine(&quot;   - Compile-time feature&quot;);
        Console.WriteLine(&quot;   - Examples:&quot;);
        Console.WriteLine(&quot;     using System;&quot;);
        Console.WriteLine(&quot;     using System.IO;&quot;);
        Console.WriteLine(&quot;     using MyList = System.Collections.Generic.List&lt;int&gt;;&quot;);
        Console.WriteLine();

        // Using an alias defined with using statement
        MyAlias stringList = new MyAlias { &quot;Item1&quot;, &quot;Item2&quot;, &quot;Item3&quot; };
        Console.WriteLine($&quot;   Using alias: MyAlias contains {stringList.Count} items&quot;);
        Console.WriteLine();
    }

    public static void UsingBlockDemo()
    {
        Console.WriteLine(&quot;2. USING BLOCKS:&quot;);
        Console.WriteLine(&quot;   - Used within method bodies&quot;);
        Console.WriteLine(&quot;   - Ensures automatic disposal of resources&quot;);
        Console.WriteLine(&quot;   - Runtime feature&quot;);
        Console.WriteLine(&quot;   - Example:&quot;);

        string fileName = &quot;using_block_example.txt&quot;;

        // This is a USING BLOCK
        using (FileStream fileStream = new FileStream(fileName, FileMode.Create))
        using (StreamWriter writer = new StreamWriter(fileStream))
        {
            writer.WriteLine(&quot;This demonstrates a using BLOCK&quot;);
            writer.WriteLine(&quot;Resources are automatically disposed&quot;);
            Console.WriteLine(&quot;   âœ“ File written using using block&quot;);
        } // &lt;- Resources automatically disposed here

        // Cleanup
        if (File.Exists(fileName))
        {
            File.Delete(fileName);
            Console.WriteLine(&quot;   âœ“ Temporary file cleaned up&quot;);
        }

        Console.WriteLine();
    }

    public static void UsingDeclarationDemo()
    {
        Console.WriteLine(&quot;3. USING DECLARATIONS (C# 8.0+):&quot;);
        Console.WriteLine(&quot;   - Simplified syntax without explicit block&quot;);
        Console.WriteLine(&quot;   - Resources disposed at end of enclosing scope&quot;);
        Console.WriteLine(&quot;   - Example:&quot;);

        string fileName = &quot;using_declaration_example.txt&quot;;

        // This is a USING DECLARATION (no explicit block)
        using var fileStream = new FileStream(fileName, FileMode.Create);
        using var writer = new StreamWriter(fileStream);

        writer.WriteLine(&quot;This demonstrates a using DECLARATION&quot;);
        writer.WriteLine(&quot;No explicit block needed&quot;);
        Console.WriteLine(&quot;   âœ“ File written using using declaration&quot;);

        // Resources automatically disposed at end of method

        // Cleanup
        if (File.Exists(fileName))
        {
            File.Delete(fileName);
            Console.WriteLine(&quot;   âœ“ Temporary file cleaned up&quot;);
        }

        Console.WriteLine();
    }

    public static void PracticalDifferencesDemo()
    {
        Console.WriteLine(&quot;4. PRACTICAL DIFFERENCES:&quot;);

        DemonstrateNamespaceImport();
        DemonstrateAliasCreation();
        DemonstrateResourceManagement();
        DemonstrateGlobalUsings();
    }

    public static void DemonstrateNamespaceImport()
    {
        Console.WriteLine(&quot;   a) Namespace Import with Using Statements:&quot;);

        // Without using statement, you would need to write:
        // System.DateTime now = System.DateTime.Now;
        // System.Console.WriteLine(&quot;Full namespace required&quot;);

        // With using statement at top of file:
        DateTime now = DateTime.Now; // 'using System;' allows this
        Console.WriteLine($&quot;   Current time: {now:HH:mm:ss}&quot;);

        // Using alias for long namespace names
        var list = new MyAlias(); // MyAlias = List&lt;string&gt; defined at top
        list.Add(&quot;Demonstration&quot;);
        Console.WriteLine($&quot;   Alias usage: {list[0]}&quot;);
        Console.WriteLine();
    }

    public static void DemonstrateAliasCreation()
    {
        Console.WriteLine(&quot;   b) Alias Creation with Using Statements:&quot;);

        // Example of using statement for alias
        // using StringDictionary = System.Collections.Generic.Dictionary&lt;string, string&gt;;

        var dict = new System.Collections.Generic.Dictionary&lt;string, string&gt;
        {
            {&quot;Key1&quot;, &quot;Value1&quot;},
            {&quot;Key2&quot;, &quot;Value2&quot;}
        };

        Console.WriteLine($&quot;   Dictionary contains {dict.Count} items&quot;);
        Console.WriteLine(&quot;   (Would be simpler with alias: using StringDict = Dictionary&lt;string, string&gt;)&quot;);
        Console.WriteLine();
    }

    public static void DemonstrateResourceManagement()
    {
        Console.WriteLine(&quot;   c) Resource Management with Using Blocks:&quot;);

        // Demonstrate proper resource disposal
        string tempFile = &quot;resource_demo.tmp&quot;;

        try
        {
            // Using block ensures disposal
            using (var resource = new DisposableResource(&quot;ResourceA&quot;))
            {
                resource.UseResource();
                Console.WriteLine(&quot;   âœ“ Resource used within using block&quot;);

                // Even if exception occurs, resource is disposed
                if (DateTime.Now.Millisecond &gt; 900) // Rare condition
                {
                    throw new Exception(&quot;Simulated exception&quot;);
                }
            } // Resource automatically disposed here

            Console.WriteLine(&quot;   âœ“ Resource automatically disposed&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;   Exception handled: {ex.Message}&quot;);
            Console.WriteLine(&quot;   âœ“ Resource still disposed despite exception&quot;);
        }

        Console.WriteLine();
    }

    public static void DemonstrateGlobalUsings()
    {
        Console.WriteLine(&quot;   d) Global Using Statements (C# 10+):&quot;);
        Console.WriteLine(&quot;   - Can use 'global using' for project-wide imports&quot;);
        Console.WriteLine(&quot;   - Example: global using System;&quot;);
        Console.WriteLine(&quot;   - Available in all files in the project&quot;);
        Console.WriteLine(&quot;   - Reduces repetitive using statements&quot;);
        Console.WriteLine();
    }
}

// Custom disposable class for demonstration
public class DisposableResource : IDisposable
{
    private string resourceName;
    private bool disposed = false;

    public DisposableResource(string name)
    {
        resourceName = name;
        Console.WriteLine($&quot;     {resourceName} created&quot;);
    }

    public void UseResource()
    {
        if (disposed)
            throw new ObjectDisposedException(resourceName);

        Console.WriteLine($&quot;     {resourceName} is being used&quot;);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            Console.WriteLine($&quot;     {resourceName} disposed&quot;);
            disposed = true;
        }
    }
}

// Demonstrate different using scenarios
public class AdvancedUsingScenarios
{
    // Using statements at different levels
    using System.Text; // &lt;- Using statement (namespace import)

    public static void ComprehensiveDemo()
    {
        Console.WriteLine(&quot;5. COMPREHENSIVE USING SCENARIOS:&quot;);

        // Scenario 1: Multiple using blocks
        Console.WriteLine(&quot;   Scenario 1: Multiple using blocks&quot;);
        using (var resource1 = new DisposableResource(&quot;Resource1&quot;))
        using (var resource2 = new DisposableResource(&quot;Resource2&quot;))
        {
            resource1.UseResource();
            resource2.UseResource();
            // Both disposed in reverse order
        }

        // Scenario 2: Nested using blocks
        Console.WriteLine(&quot;\n   Scenario 2: Nested using blocks&quot;);
        using (var outer = new DisposableResource(&quot;Outer&quot;))
        {
            outer.UseResource();

            using (var inner = new DisposableResource(&quot;Inner&quot;))
            {
                inner.UseResource();
                // Inner disposed first
            }
            // Outer disposed after inner
        }

        // Scenario 3: Using declarations
        Console.WriteLine(&quot;\n   Scenario 3: Using declarations&quot;);
        using var declaration1 = new DisposableResource(&quot;Declaration1&quot;);
        using var declaration2 = new DisposableResource(&quot;Declaration2&quot;);

        declaration1.UseResource();
        declaration2.UseResource();

        // Both disposed at end of method in reverse order
        Console.WriteLine(&quot;   End of method - declarations will be disposed&quot;);
    }
}
</code></pre>
<h4 id="detailed-comparison-table">Detailed Comparison Table:</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Using Statement (Directive)</th>
<th>Using Block</th>
<th>Using Declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Location</strong></td>
<td>Top of source file</td>
<td>Inside method body</td>
<td>Inside method body</td>
</tr>
<tr>
<td><strong>Purpose</strong></td>
<td>Import namespaces/create aliases</td>
<td>Resource management</td>
<td>Resource management</td>
</tr>
<tr>
<td><strong>Syntax</strong></td>
<td><code>using System;</code></td>
<td><code>using (var x = ...) { }</code></td>
<td><code>using var x = ...;</code></td>
</tr>
<tr>
<td><strong>When Applied</strong></td>
<td>Compile time</td>
<td>Runtime</td>
<td>Runtime</td>
</tr>
<tr>
<td><strong>Scope</strong></td>
<td>Entire file</td>
<td>Block only</td>
<td>Method/scope</td>
</tr>
<tr>
<td><strong>Disposal</strong></td>
<td>N/A</td>
<td>Automatic at end of block</td>
<td>Automatic at end of scope</td>
</tr>
<tr>
<td><strong>C# Version</strong></td>
<td>C# 1.0+</td>
<td>C# 1.0+</td>
<td>C# 8.0+</td>
</tr>
</tbody>
</table>
<h4 id="real-examples">Real Examples:</h4>
<pre><code class="language-csharp">// USING STATEMENTS (at top of file)
using System;                    // Namespace import
using System.IO;                 // Namespace import
using FileStream = System.IO.FileStream;  // Alias
global using System.Collections.Generic;  // Global using (C# 10+)

public class Examples
{
    public void DemonstrateAll()
    {
        // USING BLOCK
        using (var stream = new FileStream(&quot;file.txt&quot;, FileMode.Create))
        {
            // Use stream
        } // stream.Dispose() called automatically

        // USING DECLARATION (C# 8+)
        using var reader = new StreamReader(&quot;file.txt&quot;);
        // Use reader
        // reader.Dispose() called at end of method
    }
}
</code></pre>
<h4 id="key-takeaways">Key Takeaways:</h4>
<ol>
<li><strong>Using Statement</strong>: Compile-time directive for namespace imports and aliases</li>
<li><strong>Using Block</strong>: Runtime construct for automatic resource disposal with explicit scope</li>
<li><strong>Using Declaration</strong>: Modern syntax for resource disposal without explicit blocks</li>
<li><strong>Different Purposes</strong>: Statements are for namespaces, blocks/declarations are for resource management</li>
<li><strong>Choose Based on Need</strong>: Use statements for imports, blocks/declarations for IDisposable objects</li>
</ol>
<p>The confusion often arises because both use the <code>using</code> keyword, but they serve completely different purposes in the language.</p>
<h3 id="question-28-explain-following-terms-assembly-namespace-class-property-field-methods">Question 28: Explain following terms: Assembly, Namespace, Class, Property, Field, Methods.</h3>
<h4 id="fundamental-c-concepts-explained">Fundamental C# Concepts Explained</h4>
<p>Let me explain each of these important C# concepts with practical examples:</p>
<pre><code class="language-csharp">// NAMESPACE - A logical grouping of types
namespace MyCompany.EmployeeManagement  // &lt;- This is a NAMESPACE
{
    using System;
    using System.Collections.Generic;

    // CLASS - A blueprint for creating objects
    public class Employee  // &lt;- This is a CLASS
    {
        // FIELDS - Private data storage (variables)
        private int employeeId;           // &lt;- This is a FIELD
        private string firstName;         // &lt;- This is a FIELD
        private string lastName;          // &lt;- This is a FIELD
        private decimal salary;           // &lt;- This is a FIELD
        private DateTime hireDate;        // &lt;- This is a FIELD
        private List&lt;string&gt; skills;      // &lt;- This is a FIELD

        // PROPERTIES - Public interface to access private fields
        public int EmployeeId             // &lt;- This is a PROPERTY
        {
            get { return employeeId; }
            private set
            {
                if (value &gt; 0)
                    employeeId = value;
                else
                    throw new ArgumentException(&quot;Employee ID must be positive&quot;);
            }
        }

        public string FirstName           // &lt;- This is a PROPERTY
        {
            get { return firstName; }
            set
            {
                if (!string.IsNullOrWhiteSpace(value))
                    firstName = value.Trim();
                else
                    throw new ArgumentException(&quot;First name cannot be empty&quot;);
            }
        }

        public string LastName            // &lt;- This is a PROPERTY
        {
            get { return lastName; }
            set
            {
                if (!string.IsNullOrWhiteSpace(value))
                    lastName = value.Trim();
                else
                    throw new ArgumentException(&quot;Last name cannot be empty&quot;);
            }
        }

        public decimal Salary             // &lt;- This is a PROPERTY
        {
            get { return salary; }
            set
            {
                if (value &gt;= 0)
                    salary = value;
                else
                    throw new ArgumentException(&quot;Salary cannot be negative&quot;);
            }
        }

        public DateTime HireDate          // &lt;- This is a PROPERTY
        {
            get { return hireDate; }
            set { hireDate = value; }
        }

        // Auto-implemented property (compiler creates backing field)
        public string Department { get; set; }  // &lt;- This is a PROPERTY

        // Read-only property
        public string FullName            // &lt;- This is a PROPERTY
        {
            get { return $&quot;{firstName} {lastName}&quot;; }
        }

        // Read-only property with calculation
        public int YearsOfService         // &lt;- This is a PROPERTY
        {
            get { return DateTime.Now.Year - hireDate.Year; }
        }

        // METHODS - Functions that define behavior

        // Constructor METHOD
        public Employee(int id, string first, string last, decimal sal, DateTime hire)  // &lt;- This is a METHOD
        {
            EmployeeId = id;
            FirstName = first;
            LastName = last;
            Salary = sal;
            HireDate = hire;
            skills = new List&lt;string&gt;();
        }

        // Instance METHOD
        public void AddSkill(string skill)   // &lt;- This is a METHOD
        {
            if (!string.IsNullOrWhiteSpace(skill) &amp;&amp; !skills.Contains(skill))
            {
                skills.Add(skill);
                Console.WriteLine($&quot;Added skill '{skill}' to {FullName}&quot;);
            }
        }

        // Instance METHOD with return value
        public List&lt;string&gt; GetSkills()      // &lt;- This is a METHOD
        {
            return new List&lt;string&gt;(skills); // Return copy to maintain encapsulation
        }

        // Instance METHOD with parameters
        public void GiveRaise(decimal percentage)  // &lt;- This is a METHOD
        {
            if (percentage &gt; 0 &amp;&amp; percentage &lt;= 50)
            {
                decimal oldSalary = salary;
                salary += salary * (percentage / 100);
                Console.WriteLine($&quot;{FullName} received a {percentage}% raise&quot;);
                Console.WriteLine($&quot;Salary increased from ${oldSalary:F2} to ${salary:F2}&quot;);
            }
            else
            {
                throw new ArgumentException(&quot;Raise percentage must be between 0 and 50&quot;);
            }
        }

        // Static METHOD (belongs to class, not instance)
        public static Employee CreateTemporaryEmployee(string first, string last)  // &lt;- This is a METHOD
        {
            return new Employee(0, first, last, 0, DateTime.Now);
        }

        // Virtual METHOD (can be overridden)
        public virtual void DisplayInfo()    // &lt;- This is a METHOD
        {
            Console.WriteLine($&quot;=== Employee Information ===&quot;);
            Console.WriteLine($&quot;ID: {EmployeeId}&quot;);
            Console.WriteLine($&quot;Name: {FullName}&quot;);
            Console.WriteLine($&quot;Department: {Department ?? &quot;Not Assigned&quot;}&quot;);
            Console.WriteLine($&quot;Salary: ${Salary:F2}&quot;);
            Console.WriteLine($&quot;Hire Date: {HireDate:yyyy-MM-dd}&quot;);
            Console.WriteLine($&quot;Years of Service: {YearsOfService}&quot;);
            Console.WriteLine($&quot;Skills: {(skills.Count &gt; 0 ? string.Join(&quot;, &quot;, skills) : &quot;None&quot;)}&quot;);
            Console.WriteLine($&quot;============================&quot;);
        }

        // Override Object.ToString() METHOD
        public override string ToString()    // &lt;- This is a METHOD
        {
            return $&quot;Employee {EmployeeId}: {FullName} ({Department})&quot;;
        }
    }

    // Another CLASS demonstrating inheritance
    public class Manager : Employee      // &lt;- This is a CLASS inheriting from Employee
    {
        // Additional FIELDS for Manager
        private List&lt;Employee&gt; subordinates;  // &lt;- This is a FIELD

        // Additional PROPERTIES for Manager
        public int TeamSize               // &lt;- This is a PROPERTY
        {
            get { return subordinates.Count; }
        }

        public decimal BonusBudget { get; set; }  // &lt;- This is a PROPERTY

        // Constructor METHOD
        public Manager(int id, string first, string last, decimal sal, DateTime hire, decimal bonus)
            : base(id, first, last, sal, hire)  // &lt;- This is a METHOD (constructor)
        {
            subordinates = new List&lt;Employee&gt;();
            BonusBudget = bonus;
        }

        // Manager-specific METHODS
        public void AddSubordinate(Employee employee)  // &lt;- This is a METHOD
        {
            if (employee != null &amp;&amp; !subordinates.Contains(employee))
            {
                subordinates.Add(employee);
                Console.WriteLine($&quot;{employee.FullName} added to {FullName}'s team&quot;);
            }
        }

        public void RemoveSubordinate(Employee employee)  // &lt;- This is a METHOD
        {
            if (subordinates.Remove(employee))
            {
                Console.WriteLine($&quot;{employee.FullName} removed from {FullName}'s team&quot;);
            }
        }

        public List&lt;Employee&gt; GetTeamMembers()  // &lt;- This is a METHOD
        {
            return new List&lt;Employee&gt;(subordinates);
        }

        // Override parent METHOD
        public override void DisplayInfo()   // &lt;- This is a METHOD (overridden)
        {
            base.DisplayInfo(); // Call parent method
            Console.WriteLine($&quot;Team Size: {TeamSize}&quot;);
            Console.WriteLine($&quot;Bonus Budget: ${BonusBudget:F2}&quot;);
            if (subordinates.Count &gt; 0)
            {
                Console.WriteLine(&quot;Team Members:&quot;);
                foreach (var emp in subordinates)
                {
                    Console.WriteLine($&quot;  - {emp.FullName}&quot;);
                }
            }
        }
    }
}

// Demonstration program
namespace MyCompany.Demo  // &lt;- Another NAMESPACE
{
    using System;
    using MyCompany.EmployeeManagement;

    public class Program     // &lt;- This is a CLASS
    {
        // Static METHOD - entry point
        public static void Main()  // &lt;- This is a METHOD
        {
            Console.WriteLine(&quot;=== C# Concepts Demonstration ===\n&quot;);

            DemonstrateAssembly();
            DemonstrateNamespace();
            DemonstrateClassAndObjects();
            DemonstrateFieldsAndProperties();
            DemonstrateMethods();
        }

        public static void DemonstrateAssembly()  // &lt;- This is a METHOD
        {
            Console.WriteLine(&quot;1. ASSEMBLY:&quot;);
            Console.WriteLine(&quot;   - This entire compiled program is an ASSEMBLY&quot;);
            Console.WriteLine(&quot;   - Assembly contains all compiled code (.exe or .dll)&quot;);
            Console.WriteLine(&quot;   - Provides security and versioning boundary&quot;);
            Console.WriteLine($&quot;   - Current assembly: {System.Reflection.Assembly.GetExecutingAssembly().GetName().Name}&quot;);
            Console.WriteLine();
        }

        public static void DemonstrateNamespace()  // &lt;- This is a METHOD
        {
            Console.WriteLine(&quot;2. NAMESPACE:&quot;);
            Console.WriteLine(&quot;   - MyCompany.EmployeeManagement contains Employee and Manager classes&quot;);
            Console.WriteLine(&quot;   - MyCompany.Demo contains this Program class&quot;);
            Console.WriteLine(&quot;   - Namespaces prevent name conflicts&quot;);
            Console.WriteLine(&quot;   - Organize related classes logically&quot;);
            Console.WriteLine();
        }

        public static void DemonstrateClassAndObjects()  // &lt;- This is a METHOD
        {
            Console.WriteLine(&quot;3. CLASSES AND OBJECTS:&quot;);

            // Create objects from classes
            Employee emp1 = new Employee(101, &quot;John&quot;, &quot;Doe&quot;, 50000, new DateTime(2020, 3, 15));
            Employee emp2 = new Employee(102, &quot;Jane&quot;, &quot;Smith&quot;, 55000, new DateTime(2019, 7, 22));
            Manager mgr1 = new Manager(201, &quot;Bob&quot;, &quot;Johnson&quot;, 75000, new DateTime(2018, 1, 10), 10000);

            Console.WriteLine(&quot;   âœ“ Created Employee and Manager objects from classes&quot;);
            Console.WriteLine($&quot;   - {emp1}&quot;);
            Console.WriteLine($&quot;   - {emp2}&quot;);
            Console.WriteLine($&quot;   - {mgr1}&quot;);
            Console.WriteLine();
        }

        public static void DemonstrateFieldsAndProperties()  // &lt;- This is a METHOD
        {
            Console.WriteLine(&quot;4. FIELDS vs PROPERTIES:&quot;);

            Employee employee = new Employee(103, &quot;Alice&quot;, &quot;Brown&quot;, 60000, new DateTime(2021, 5, 1));

            Console.WriteLine(&quot;   FIELDS (private, internal storage):&quot;);
            Console.WriteLine(&quot;   - employeeId, firstName, lastName, salary, etc.&quot;);
            Console.WriteLine(&quot;   - Not directly accessible from outside the class&quot;);
            Console.WriteLine();

            Console.WriteLine(&quot;   PROPERTIES (public interface):&quot;);
            Console.WriteLine($&quot;   - EmployeeId: {employee.EmployeeId}&quot;);
            Console.WriteLine($&quot;   - FirstName: {employee.FirstName}&quot;);
            Console.WriteLine($&quot;   - LastName: {employee.LastName}&quot;);
            Console.WriteLine($&quot;   - FullName: {employee.FullName} (read-only)&quot;);
            Console.WriteLine($&quot;   - YearsOfService: {employee.YearsOfService} (calculated)&quot;);

            // Demonstrate property validation
            try
            {
                employee.Salary = 65000;  // Valid
                Console.WriteLine($&quot;   - Salary updated to: ${employee.Salary:F2}&quot;);

                // employee.Salary = -1000;  // Would throw exception
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($&quot;   - Property validation: {ex.Message}&quot;);
            }

            Console.WriteLine();
        }

        public static void DemonstrateMethods()  // &lt;- This is a METHOD
        {
            Console.WriteLine(&quot;5. METHODS:&quot;);

            // Create objects
            Employee emp = new Employee(104, &quot;Charlie&quot;, &quot;Wilson&quot;, 58000, new DateTime(2020, 8, 12));
            Manager mgr = new Manager(202, &quot;Diana&quot;, &quot;Taylor&quot;, 80000, new DateTime(2017, 4, 3), 15000);

            Console.WriteLine(&quot;   Instance Methods:&quot;);

            // Call instance methods
            emp.AddSkill(&quot;C#&quot;);
            emp.AddSkill(&quot;SQL&quot;);
            emp.AddSkill(&quot;JavaScript&quot;);

            emp.GiveRaise(5);

            Console.WriteLine();
            Console.WriteLine(&quot;   Method with return value:&quot;);
            var skills = emp.GetSkills();
            Console.WriteLine($&quot;   {emp.FullName} has {skills.Count} skills: {string.Join(&quot;, &quot;, skills)}&quot;);

            Console.WriteLine();
            Console.WriteLine(&quot;   Static Method:&quot;);
            Employee tempEmp = Employee.CreateTemporaryEmployee(&quot;Temp&quot;, &quot;Worker&quot;);
            Console.WriteLine($&quot;   Created temporary employee: {tempEmp}&quot;);

            Console.WriteLine();
            Console.WriteLine(&quot;   Virtual Method Override:&quot;);
            mgr.AddSubordinate(emp);
            mgr.DisplayInfo();  // Calls overridden version

            Console.WriteLine();
        }
    }
}
</code></pre>
<h4 id="summary-of-concepts">Summary of Concepts:</h4>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Definition</th>
<th>Example</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Assembly</strong></td>
<td>Compiled unit (.exe/.dll)</td>
<td>Entire application</td>
<td>Security, versioning, deployment</td>
</tr>
<tr>
<td><strong>Namespace</strong></td>
<td>Logical grouping of types</td>
<td><code>MyCompany.EmployeeManagement</code></td>
<td>Organization, prevent conflicts</td>
</tr>
<tr>
<td><strong>Class</strong></td>
<td>Blueprint for objects</td>
<td><code>Employee</code>, <code>Manager</code></td>
<td>Define structure and behavior</td>
</tr>
<tr>
<td><strong>Field</strong></td>
<td>Private data storage</td>
<td><code>private string firstName</code></td>
<td>Internal state storage</td>
</tr>
<tr>
<td><strong>Property</strong></td>
<td>Public interface to data</td>
<td><code>public string FirstName { get; set; }</code></td>
<td>Controlled access to data</td>
</tr>
<tr>
<td><strong>Method</strong></td>
<td>Function that defines behavior</td>
<td><code>public void AddSkill(string skill)</code></td>
<td>Define what objects can do</td>
</tr>
</tbody>
</table>
<h4 id="key-relationships">Key Relationships:</h4>
<ol>
<li><strong>Assembly</strong> contains multiple <strong>Namespaces</strong></li>
<li><strong>Namespace</strong> contains multiple <strong>Classes</strong></li>
<li><strong>Class</strong> contains <strong>Fields</strong>, <strong>Properties</strong>, and <strong>Methods</strong></li>
<li><strong>Properties</strong> often provide access to <strong>Fields</strong></li>
<li><strong>Methods</strong> operate on <strong>Fields</strong> and <strong>Properties</strong></li>
</ol>
<h4 id="hierarchy-example">Hierarchy Example:</h4>
<pre><code>Assembly: MyApplication.exe
|-- Namespace: MyCompany.EmployeeManagement
|   |-- Class: Employee
|   |   |-- Fields: employeeId, firstName, lastName
|   |   |-- Properties: EmployeeId, FirstName, LastName
|   |   |-- Methods: AddSkill(), GiveRaise(), DisplayInfo()
|   |-- Class: Manager (inherits from Employee)
|-- Namespace: MyCompany.Demo
    |-- Class: Program
        |-- Methods: Main(), DemonstrateAssembly()
</code></pre>
<p>This structure provides organization, encapsulation, and reusability in C# applications.</p>
<h3 id="exam-tips">Exam Tips</h3>
<ol>
<li><strong>Practice Code Examples</strong>: Type out the examples yourself</li>
<li><strong>Understand Patterns</strong>: Know when to use abstract vs interface, DataReader vs DataSet</li>
<li><strong>Remember Architecture</strong>: Know the layers and how they interact</li>
<li><strong>Security</strong>: Understand authentication vs authorization</li>
<li><strong>Performance</strong>: Know when to use async, parallel processing, proper data access</li>
</ol>
<p>Your comprehensive exam preparation notes are now complete! This document covers all the topics your teacher specified with practical examples, comparisons, and detailed explanations. You can now compile this into a PDF for printing and study.</p>

</body>
</html>
