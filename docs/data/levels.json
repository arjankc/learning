{
  "levels": [
    {
      "id": 1,
      "tier": 1,
      "title": "Hello World",
      "description": "Create and run your first C# program.",
      "requirements": [
        "Install .NET SDK",
        "Create a new console app",
        "Run the app"
      ],
      "theory": "<div class='theory-content'><h4>üöÄ Welcome to C# Programming!</h4><p><strong>C# (pronounced 'C-Sharp')</strong> is a modern, object-oriented programming language developed by Microsoft. It's part of the .NET ecosystem and is widely used for building desktop applications, web applications, mobile apps, games, and more.</p><h4>üèóÔ∏è Understanding Your First Program</h4><p>Every C# console application starts with the <code>Main</code> method, which serves as the <strong>entry point</strong> of your program. Think of it as the front door of your application - when you run your program, the operating system looks for this method and starts executing code from there.</p><pre><code>static void Main()</code></pre><ul><li><strong>static</strong>: The method belongs to the class itself, not to any instance of the class</li><li><strong>void</strong>: The method doesn't return any value</li><li><strong>Main</strong>: The special name that tells .NET this is where to start</li></ul><h4>üìö Namespaces - Organizing Your Code</h4><p>The <code>using System;</code> directive at the top tells the compiler that we want to use types from the <code>System</code> namespace without having to type the full name every time. It's like importing a library of pre-built functionality.</p><p>Without this directive, you'd have to write <code>System.Console.WriteLine()</code> instead of just <code>Console.WriteLine()</code>.</p><h4>üñ•Ô∏è Console.WriteLine() - Your First Output</h4><p><code>Console.WriteLine()</code> is a method that prints text to the console (command line) and moves to a new line. It's your primary way of seeing output when learning C#.</p><h4>üîß The Compilation Process</h4><ol><li><strong>Source Code (.cs)</strong>: You write human-readable C# code</li><li><strong>Compiler (csc.exe)</strong>: Converts your C# code into Intermediate Language (IL)</li><li><strong>Common Language Runtime (CLR)</strong>: Executes the IL code using Just-In-Time (JIT) compilation</li></ol><p>This process makes C# both powerful and portable across different platforms!</p><h4>üéØ Best Practices from Day One</h4><ul><li>Always use meaningful names for your classes and methods</li><li>Indent your code properly for readability</li><li>Add comments to explain complex logic</li><li>Follow C# naming conventions (PascalCase for classes and methods)</li></ul></div>",
      "code": "using System;\nclass Program {\n    static void Main() {\n        Console.WriteLine(\"Hello, World!\");\n    }\n}",
      "quiz": [
        { "q": "What is the entry point in a C# console program?", "options": ["Main", "Start", "Run", "Init"], "answer": 0 },
        { "q": "Which type prints to the console?", "options": ["System.IO.File", "System.Console", "System.Text.StringBuilder"], "answer": 1 }
      ],
      "completionCriteria": "Console prints 'Hello, World!'",
      "nextLevel": 2
    },
    {
      "id": 2,
      "tier": 1,
      "title": "Data Types",
      "description": "Understand value vs reference types and primitives.",
      "requirements": [
        "Declare value types (int, bool)",
        "Declare reference types (string, arrays)"
      ],
      "theory": "<div class='theory-content'><h4>üéØ Understanding Data Types - The Foundation of Programming</h4><p>Data types are the building blocks of any program. They tell the computer how to interpret and store different kinds of information. In C#, all data types fall into two main categories: <strong>Value Types</strong> and <strong>Reference Types</strong>.</p><h4>üì¶ Value Types - Stored Directly</h4><p><strong>Value types</strong> store their data directly in memory. When you assign one value type variable to another, you're making a complete copy of the data.</p><h5>üìä Common Value Types:</h5><ul><li><strong>int</strong>: Whole numbers (-2,147,483,648 to 2,147,483,647)</li><li><strong>double</strong>: Decimal numbers with high precision</li><li><strong>float</strong>: Decimal numbers with lower precision (faster)</li><li><strong>bool</strong>: True or false values</li><li><strong>char</strong>: Single character ('A', '5', '$')</li><li><strong>DateTime</strong>: Date and time values</li><li><strong>decimal</strong>: High precision decimal numbers (perfect for money)</li></ul><h4>üîó Reference Types - Stored with Pointers</h4><p><strong>Reference types</strong> store a reference (pointer) to the actual data location in memory. When you assign one reference type variable to another, both variables point to the same object.</p><h5>üè∑Ô∏è Common Reference Types:</h5><ul><li><strong>string</strong>: Text data (\"Hello World\")</li><li><strong>object</strong>: The base type for all other types</li><li><strong>Arrays</strong>: Collections of data (int[], string[])</li><li><strong>Classes</strong>: Custom types you define</li></ul><h4>üß† Memory Management Deep Dive</h4><h5>Stack vs Heap:</h5><ul><li><strong>Stack</strong>: Fast, limited space, stores value types and references</li><li><strong>Heap</strong>: Larger space, stores reference type objects, managed by Garbage Collector</li></ul><h4>‚ö†Ô∏è Special Case: Strings</h4><p>Strings are reference types, but they behave like value types due to <strong>immutability</strong>. When you modify a string, you're actually creating a new string object:</p><pre><code>string s1 = \"Hello\";\nstring s2 = s1;     // Both point to same \"Hello\" object\ns1 += \" World\";     // Creates new \"Hello World\" object\n// s1 now points to \"Hello World\", s2 still points to \"Hello\"</code></pre><h4>üé™ Boxing and Unboxing</h4><ul><li><strong>Boxing</strong>: Converting a value type to object (int ‚Üí object)</li><li><strong>Unboxing</strong>: Converting back to value type (object ‚Üí int)</li><li>These operations have performance costs, so avoid when possible</li></ul><h4>üèÜ Pro Tips</h4><ul><li>Use <code>decimal</code> for financial calculations to avoid floating-point errors</li><li>Be aware that string concatenation in loops can be expensive</li><li>Value types can't be null (unless nullable: int?)</li><li>Reference types can be null and may cause NullReferenceException</li></ul></div>",
      "code": "int x = 42;\nint y = x; // copy\ny++; // x remains 42\nstring s1 = \"hi\";\nstring s2 = s1; // reference to same string instance\ns2 += \"!\"; // new string created, s1 unchanged",
      "quiz": [
        { "q": "Select all value types.", "options": ["int", "string", "bool", "DateTime"], "answer": [0,2,3], "multi": true }
      ],
      "completionCriteria": "Explain value vs reference behavior with an example.",
      "nextLevel": 3
    },
    {
      "id": 3,
      "tier": 1,
      "title": "Variables, Operators, Expressions",
      "description": "Work with variables and operators.",
      "requirements": [
        "Use arithmetic and comparison operators",
        "Use var with type inference"
      ],
      "theory": "<div class='theory-content'><h4>üîß Variables - Containers for Your Data</h4><p>Variables are named storage locations that hold data. Think of them as labeled boxes where you can store different types of information. In C#, every variable must have a specific type that determines what kind of data it can hold.</p><h4>üìù Variable Declaration and Initialization</h4><h5>Explicit Type Declaration:</h5><pre><code>int age = 25;              // Declare and initialize\ndouble price;              // Declare only\nprice = 99.99;             // Initialize later\nstring name = \"John\";       // String variable</code></pre><h5>Type Inference with 'var':</h5><p>The <code>var</code> keyword lets the compiler figure out the type based on the assigned value:</p><pre><code>var age = 25;              // Compiler infers int\nvar price = 99.99;         // Compiler infers double\nvar name = \"John\";          // Compiler infers string</code></pre><p><strong>Important:</strong> <code>var</code> still creates strongly-typed variables. You can't change the type later!</p><h4>üßÆ Operators - Performing Operations</h4><h5>Arithmetic Operators:</h5><ul><li><strong>+</strong> Addition: <code>5 + 3 = 8</code></li><li><strong>-</strong> Subtraction: <code>5 - 3 = 2</code></li><li><strong>*</strong> Multiplication: <code>5 * 3 = 15</code></li><li><strong>/</strong> Division: <code>10 / 3 = 3</code> (integer division!)</li><li><strong>%</strong> Modulus (remainder): <code>10 % 3 = 1</code></li></ul><h5>‚ö†Ô∏è Integer Division Gotcha:</h5><p>When dividing two integers, C# performs integer division and truncates the decimal part:</p><pre><code>int result = 10 / 3;       // result = 3, not 3.333...\ndouble result = 10.0 / 3;  // result = 3.333...\ndouble result = (double)10 / 3; // Casting to get decimal result</code></pre><h5>Comparison Operators:</h5><ul><li><strong>==</strong> Equal to: <code>5 == 5</code> ‚Üí true</li><li><strong>!=</strong> Not equal to: <code>5 != 3</code> ‚Üí true</li><li><strong><</strong> Less than: <code>3 < 5</code> ‚Üí true</li><li><strong>></strong> Greater than: <code>5 > 3</code> ‚Üí true</li><li><strong><=</strong> Less than or equal: <code>3 <= 3</code> ‚Üí true</li><li><strong>>=</strong> Greater than or equal: <code>5 >= 3</code> ‚Üí true</li></ul><h5>Logical Operators:</h5><ul><li><strong>&&</strong> AND: Both must be true</li><li><strong>||</strong> OR: At least one must be true</li><li><strong>!</strong> NOT: Flips true/false</li></ul><h4>üéØ Assignment Operators:</h4><ul><li><strong>=</strong> Simple assignment: <code>x = 5</code></li><li><strong>+=</strong> Add and assign: <code>x += 3</code> (same as <code>x = x + 3</code>)</li><li><strong>-=</strong> Subtract and assign: <code>x -= 2</code></li><li><strong>*=</strong> Multiply and assign: <code>x *= 4</code></li><li><strong>/=</strong> Divide and assign: <code>x /= 2</code></li></ul><h4>üîÑ Increment and Decrement:</h4><ul><li><strong>++</strong> Increment by 1: <code>x++</code> or <code>++x</code></li><li><strong>--</strong> Decrement by 1: <code>x--</code> or <code>--x</code></li></ul><p><strong>Prefix vs Postfix:</strong></p><pre><code>int x = 5;\nint a = ++x;  // x becomes 6, then a gets 6\nint b = x++;  // b gets 6, then x becomes 7</code></pre><h4>üìê Expressions and Operator Precedence</h4><p>Expressions combine variables, operators, and values. C# follows mathematical precedence:</p><ol><li>Parentheses: <code>()</code></li><li>Multiplication, Division, Modulus: <code>* / %</code></li><li>Addition, Subtraction: <code>+ -</code></li><li>Comparison: <code>< > <= >=</code></li><li>Equality: <code>== !=</code></li><li>Logical AND: <code>&&</code></li><li>Logical OR: <code>||</code></li></ol><h4>üèÜ Best Practices</h4><ul><li>Use descriptive variable names: <code>customerAge</code> instead of <code>a</code></li><li>Initialize variables when declaring them when possible</li><li>Be careful with integer division - cast to double when needed</li><li>Use parentheses to make complex expressions clear</li><li>Consider using <code>var</code> when the type is obvious from the right side</li></ul></div>",
      "code": "var a = 5; var b = 2;\nint sum = a + b; // 7\nint div = a / b; // 2 (integer division)\ndouble d = (double)a / b; // 2.5",
      "quiz": [
        { "q": "What is 5/2 with int operands?", "options": ["2", "2.5", "3"], "answer": 0 }
      ],
      "completionCriteria": "Program prints correct results for mixed int/double division.",
      "nextLevel": 4
    },
    {
      "id": 4,
      "tier": 1,
      "title": "Type Conversion",
      "description": "Implicit/explicit conversions, boxing/unboxing.",
      "requirements": [
        "Cast between numeric types",
        "Box and unbox value types"
      ],
      "theory": "<div class='theory-content'><h4>üîÑ Type Conversion - Transforming Data Between Types</h4><p>Type conversion is the process of changing a value from one data type to another. This is essential when working with different types of data, receiving user input, or calling methods that expect specific types.</p><h4>‚úÖ Implicit Conversions (Safe and Automatic)</h4><p><strong>Implicit conversions</strong> happen automatically when there's no risk of data loss. The compiler performs these conversions for you:</p><h5>Widening Conversions (Safe):</h5><ul><li><code>int</code> ‚Üí <code>long</code> ‚Üí <code>float</code> ‚Üí <code>double</code></li><li><code>char</code> ‚Üí <code>int</code> ‚Üí <code>long</code></li><li><code>byte</code> ‚Üí <code>short</code> ‚Üí <code>int</code></li></ul><pre><code>int smallNumber = 42;\nlong bigNumber = smallNumber;      // Implicit conversion\ndouble decimal = smallNumber;      // Also implicit\nchar letter = 'A';\nint asciiValue = letter;           // 'A' becomes 65</code></pre><h4>‚ö†Ô∏è Explicit Conversions (Casting - Potential Data Loss)</h4><p><strong>Explicit conversions</strong> require a cast operator because they might lose data or precision:</p><pre><code>double bigDecimal = 123.456;\nint wholeNumber = (int)bigDecimal; // Explicit cast, loses .456\n// wholeNumber = 123\n\nlong bigNumber = 1000000000000;\nint smaller = (int)bigNumber;      // Might overflow!</code></pre><h4>üéØ Safe Conversion Methods</h4><p>C# provides safer ways to convert that won't throw exceptions:</p><h5>Convert Class Methods:</h5><pre><code>string numberText = \"123\";\nint number = Convert.ToInt32(numberText);     // Converts string to int\nbool flag = Convert.ToBoolean(\"true\");       // Converts string to bool\ndouble price = Convert.ToDouble(\"99.99\");    // Converts string to double</code></pre><h5>Parse Methods:</h5><pre><code>int age = int.Parse(\"25\");                   // Throws exception if invalid\ndouble price = double.Parse(\"19.99\");\nDateTime date = DateTime.Parse(\"2023-12-25\");</code></pre><h5>TryParse Methods (Recommended):</h5><pre><code>string input = \"123\";\nif (int.TryParse(input, out int result))\n{\n    // Conversion successful, use 'result'\n    Console.WriteLine($\"Number: {result}\");\n}\nelse\n{\n    // Conversion failed, handle error\n    Console.WriteLine(\"Invalid number\");\n}</code></pre><h4>üì¶ Boxing and Unboxing - Value Types ‚Üî Object</h4><h5>Boxing (Value Type ‚Üí Object):</h5><p>Boxing wraps a value type in an object wrapper, moving it from stack to heap:</p><pre><code>int number = 42;\nobject boxed = number;        // Boxing happens automatically\nArrayList list = new ArrayList();\nlist.Add(123);               // Boxing int to object</code></pre><h5>Unboxing (Object ‚Üí Value Type):</h5><p>Unboxing extracts the value type from the object wrapper:</p><pre><code>object boxed = 42;\nint unboxed = (int)boxed;    // Explicit unboxing required\n\n// ‚ö†Ô∏è Must unbox to the EXACT same type!\nobject boxedInt = 42;\nlong wrongType = (long)boxedInt;  // Runtime exception!</nlong correct = (long)(int)boxedInt; // First unbox to int, then convert</code></pre><h4>‚ö° Performance Considerations</h4><ul><li><strong>Boxing/Unboxing</strong> has performance overhead - avoid in loops</li><li><strong>Use Generics</strong> instead of object collections to avoid boxing</li><li><strong>String conversions</strong> create new objects - consider StringBuilder for many operations</li></ul><h4>üõ°Ô∏è Null Safety and Nullable Types</h4><pre><code>// Nullable value types (C# 2.0+)\nint? nullableInt = null;             // Can be null\nif (nullableInt.HasValue)\n{\n    int actualValue = nullableInt.Value;\n}\n\n// Null-coalescing operator\nint safeValue = nullableInt ?? 0;    // Use 0 if null</code></pre><h4>üîß Advanced Conversion Techniques</h4><h5>Custom Conversion Operators:</h5><pre><code>public class Temperature\n{\n    public double Celsius { get; set; }\n    \n    // Implicit conversion from double\n    public static implicit operator Temperature(double celsius)\n    {\n        return new Temperature { Celsius = celsius };\n    }\n    \n    // Explicit conversion to double\n    public static explicit operator double(Temperature temp)\n    {\n        return temp.Celsius;\n    }\n}</code></pre><h4>‚ö†Ô∏è Common Pitfalls</h4><ul><li><strong>Overflow:</strong> Converting large numbers to smaller types</li><li><strong>Precision Loss:</strong> double ‚Üí float ‚Üí int</li><li><strong>Invalid Casts:</strong> Unboxing to wrong type</li><li><strong>Culture Issues:</strong> Parsing numbers/dates in different locales</li></ul><h4>üèÜ Best Practices</h4><ul><li>Use TryParse instead of Parse for user input</li><li>Check for overflow with <code>checked</code> keyword when needed</li><li>Prefer implicit conversions when safe</li><li>Use generics to avoid boxing/unboxing</li><li>Be aware of precision loss in floating-point conversions</li></ul></div>",
      "code": "int i = 42; double d = i; // implicit\nd = 3.14; i = (int)d; // explicit (i = 3)\nobject o = i; // boxing\nint j = (int)o; // unboxing",
      "quiz": [
        { "q": "Which is boxing?", "options": ["int i = 1; object o = i;", "object o = \"x\"; string s = (string)o;"], "answer": 0 }
      ],
      "completionCriteria": "Demonstrate boxing/unboxing without InvalidCastException.",
      "nextLevel": 5
    },
    {
      "id": 5,
      "tier": 1,
      "title": "Namespaces",
      "description": "Organize code with namespaces and using directives.",
      "requirements": [
        "Declare a namespace",
        "Use using directives"
      ],
      "theory": "<div class='theory-content'><h4>üìÅ Namespaces - Organizing Your Code Universe</h4><p>Namespaces are like folders for your code. They provide a way to organize related classes, interfaces, and other types into logical groups. This prevents naming conflicts and makes large codebases manageable.</p><h4>üéØ Why Namespaces Matter</h4><p>Imagine if every file on your computer had to have a unique name - no two files could be called \"document.txt\" anywhere! Namespaces solve this problem for code by creating different \"folders\" where the same class name can exist without conflict.</p><h5>Real-World Example:</h5><pre><code>// Both classes are named \"Timer\" but in different namespaces\nSystem.Timers.Timer serverTimer;        // For server applications\nSystem.Windows.Forms.Timer uiTimer;     // For UI applications</code></pre><h4>üì¶ Declaring Namespaces</h4><h5>Basic Namespace Declaration:</h5><pre><code>namespace MyCompany.ProjectName.Features\n{\n    public class CustomerService\n    {\n        // Class implementation\n    }\n    \n    public class OrderService\n    {\n        // Class implementation\n    }\n}</code></pre><h5>Nested Namespaces:</h5><pre><code>namespace MyCompany\n{\n    namespace ECommerce\n    {\n        namespace Services\n        {\n            public class PaymentProcessor { }\n        }\n        \n        namespace Models\n        {\n            public class Product { }\n            public class Customer { }\n        }\n    }\n}</code></pre><h4>üîß Using Directives - Importing Functionality</h4><h5>Basic Using Statement:</h5><pre><code>using System;                    // Import entire namespace\nusing System.Collections.Generic; // Import collections\nusing MyCompany.ECommerce.Models; // Import your custom namespace\n\n// Now you can use types without full qualification\nConsole.WriteLine(\"Hello\");      // Instead of System.Console.WriteLine\nList<string> names = new List<string>(); // Instead of System.Collections.Generic.List</code></pre><h5>Alias Directives:</h5><pre><code>using WinForms = System.Windows.Forms;  // Create an alias\nusing WebControls = System.Web.UI.WebControls;\n\n// Now use the aliases\nWinForms.Button winButton = new WinForms.Button();\nWebControls.Button webButton = new WebControls.Button();</code></pre><h4>üåç Global Using (C# 10+)</h4><p>Global using statements apply to all files in the project:</p><pre><code>// In GlobalUsings.cs or any .cs file\nglobal using System;\nglobal using System.Collections.Generic;\nglobal using Microsoft.Extensions.Logging;\n\n// Now these are available in ALL files without explicit using statements</code></pre><h4>üèóÔ∏è Common Namespace Patterns</h4><h5>Microsoft's Naming Convention:</h5><ul><li><strong>Company.Product.Feature:</strong> Microsoft.AspNetCore.Mvc</li><li><strong>Company.Technology:</strong> Microsoft.EntityFrameworkCore</li><li><strong>System.Area:</strong> System.IO, System.Net.Http</li></ul><h5>Your Project Structure:</h5><pre><code>MyCompany.ProjectName.Controllers    // Web controllers\nMyCompany.ProjectName.Services      // Business logic\nMyCompany.ProjectName.Models        // Data models\nMyCompany.ProjectName.Data          // Data access\nMyCompany.ProjectName.Utilities     // Helper classes</code></pre><h4>üîç Fully Qualified Names</h4><p>Sometimes you need to use the full namespace path:</p><pre><code>// When there are naming conflicts\nSystem.Console.WriteLine(\"Hello\");           // System's Console\nMyCompany.Logging.Console.WriteLine(\"Hi\");   // Your custom Console class\n\n// When you don't have a using statement\nvar timer = new System.Timers.Timer(1000);</code></pre><h4>üé™ Special Namespace Features</h4><h5>Root Namespace (Global Namespace):</h5><pre><code>// Classes without namespace are in the global namespace\nclass GlobalClass\n{\n    // This is in the root/global namespace\n}\n\n// Access from any namespace:\nglobal::GlobalClass instance = new global::GlobalClass();</code></pre><h5>Extern Alias:</h5><p>Used when you have different versions of the same assembly:</p><pre><code>extern alias OldVersion;\nextern alias NewVersion;\n\nOldVersion::MyNamespace.MyClass oldClass;\nNewVersion::MyNamespace.MyClass newClass;</code></pre><h4>üìö Built-in .NET Namespaces</h4><ul><li><strong>System:</strong> Core functionality (Console, DateTime, Math)</li><li><strong>System.IO:</strong> File and stream operations</li><li><strong>System.Collections.Generic:</strong> Generic collections (List, Dictionary)</li><li><strong>System.Linq:</strong> LINQ query operations</li><li><strong>System.Threading.Tasks:</strong> Asynchronous programming</li><li><strong>System.Text:</strong> String manipulation and encoding</li><li><strong>System.Net.Http:</strong> HTTP client operations</li></ul><h4>‚ö†Ô∏è Common Pitfalls</h4><ul><li><strong>Circular Dependencies:</strong> Namespace A references B, B references A</li><li><strong>Too Many Using Statements:</strong> Can slow compilation and cause ambiguity</li><li><strong>Namespace vs Assembly Confusion:</strong> Namespaces are logical, assemblies are physical</li><li><strong>Global Namespace Pollution:</strong> Putting too much in the root namespace</li></ul><h4>üèÜ Best Practices</h4><ul><li>Use your company/project name as the root namespace</li><li>Keep namespace hierarchy 2-4 levels deep</li><li>Match folder structure to namespace structure</li><li>Don't put types directly in the root namespace</li><li>Use meaningful, descriptive names</li><li>Avoid abbreviations in namespace names</li><li>Place using statements at the top of files</li><li>Order using statements: System namespaces first, then third-party, then your own</li></ul><h4>üîß IDE Tips</h4><ul><li><strong>Visual Studio:</strong> Ctrl+. to add missing using statements</li><li><strong>Organize usings:</strong> Remove unused using statements automatically</li><li><strong>Code completion:</strong> Type a class name and the IDE suggests the namespace</li></ul></div>",
      "code": "namespace MyApp.Models {\n    public class Person { public string Name { get; set; } }\n}\nusing MyApp.Models;\nvar p = new Person { Name = \"Ada\" };",
      "quiz": [
        { "q": "Primary purpose of namespaces?", "options": ["Performance", "Security", "Organization"], "answer": 2 }
      ],
      "completionCriteria": "Type compiles in declared namespace and is used via using.",
      "nextLevel": 6
    },
    {
      "id": 6,
      "tier": 1,
      "title": "Branching",
      "description": "if/else and switch expressions.",
      "requirements": [
        "Implement if/else",
        "Use switch expression"
      ],
      "theory": "<div class='theory-content'><h4>üõ§Ô∏è Branching - Making Decisions in Code</h4><p>Branching allows your program to make decisions and execute different code paths based on conditions. It's like a choose-your-own-adventure book for your program!</p><h4>üîÄ If-Else Statements - The Foundation of Decision Making</h4><h5>Basic If Statement:</h5><pre><code>int age = 18;\nif (age >= 18)\n{\n    Console.WriteLine(\"You can vote!\");\n}</code></pre><h5>If-Else Structure:</h5><pre><code>int score = 85;\nif (score >= 90)\n{\n    Console.WriteLine(\"Grade: A\");\n}\nelse if (score >= 80)\n{\n    Console.WriteLine(\"Grade: B\");\n}\nelse if (score >= 70)\n{\n    Console.WriteLine(\"Grade: C\");\n}\nelse\n{\n    Console.WriteLine(\"Grade: F\");\n}</code></pre><h4>üéØ Switch Statements - Multiple Choice Made Easy</h4><h5>Traditional Switch Statement:</h5><pre><code>int dayOfWeek = 3;\nswitch (dayOfWeek)\n{\n    case 1:\n        Console.WriteLine(\"Monday\");\n        break;\n    case 2:\n        Console.WriteLine(\"Tuesday\");\n        break;\n    case 3:\n        Console.WriteLine(\"Wednesday\");\n        break;\n    default:\n        Console.WriteLine(\"Weekend!\");\n        break;\n}</code></pre><h4>üöÄ Switch Expressions (C# 8.0+) - Modern and Concise</h4><p>Switch expressions provide a more functional approach to branching:</p><h5>Basic Switch Expression:</h5><pre><code>int dayNumber = 3;\nstring dayName = dayNumber switch\n{\n    1 => \"Monday\",\n    2 => \"Tuesday\",\n    3 => \"Wednesday\",\n    4 => \"Thursday\",\n    5 => \"Friday\",\n    _ => \"Weekend\"  // _ is the discard pattern (default)\n};</code></pre><h5>Pattern Matching with Switch Expressions:</h5><pre><code>object value = 42;\nstring description = value switch\n{\n    int i when i > 0 => \"Positive integer\",\n    int i when i < 0 => \"Negative integer\",\n    int => \"Zero\",\n    string s when s.Length > 5 => \"Long string\",\n    string s => \"Short string\",\n    null => \"It's null\",\n    _ => \"Something else\"\n};</code></pre><h4>üé® Advanced Pattern Matching</h4><h5>Type Patterns:</h5><pre><code>object obj = \"Hello\";\nstring result = obj switch\n{\n    string s => $\"String: {s}\",\n    int i => $\"Integer: {i}\",\n    bool b => $\"Boolean: {b}\",\n    null => \"Null value\",\n    _ => \"Unknown type\"\n};</code></pre><h5>Property Patterns:</h5><pre><code>public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\n// Pattern matching on properties\nstring GetCategory(Person person) => person switch\n{\n    { Age: < 13 } => \"Child\",\n    { Age: >= 13 and < 20 } => \"Teenager\",\n    { Age: >= 20 and < 65 } => \"Adult\",\n    { Age: >= 65 } => \"Senior\",\n    _ => \"Unknown\"\n};</code></pre><h5>Tuple Patterns:</h5><pre><code>(int x, int y) point = (3, 4);\nstring quadrant = point switch\n{\n    (0, 0) => \"Origin\",\n    (var x, var y) when x > 0 && y > 0 => \"Quadrant I\",\n    (var x, var y) when x < 0 && y > 0 => \"Quadrant II\",\n    (var x, var y) when x < 0 && y < 0 => \"Quadrant III\",\n    (var x, var y) when x > 0 && y < 0 => \"Quadrant IV\",\n    _ => \"On axis\"\n};</code></pre><h4>‚ö° Performance Considerations</h4><ul><li><strong>Switch expressions</strong> can be more efficient than if-else chains</li><li><strong>Jump tables</strong> are used for contiguous integer cases</li><li><strong>String switches</strong> use hash codes for fast lookup</li><li><strong>Pattern matching</strong> may have overhead compared to simple value checks</li></ul><h4>üõ°Ô∏è Null Safety in Branching</h4><pre><code>string text = GetSomeString();\n\n// Traditional null check\nif (text != null && text.Length > 0)\n{\n    Console.WriteLine(text);\n}\n\n// Null-conditional operator\nif (text?.Length > 0)\n{\n    Console.WriteLine(text);\n}\n\n// Pattern matching with null check\nstring result = text switch\n{\n    null => \"No text\",\n    \"\" => \"Empty text\",\n    var t when t.Length < 5 => \"Short text\",\n    _ => \"Long text\"\n};</code></pre><h4>üé≠ Conditional (Ternary) Operator</h4><p>For simple conditions, the ternary operator provides a concise alternative:</p><pre><code>int age = 20;\nstring status = age >= 18 ? \"Adult\" : \"Minor\";\n\n// Nested ternary (use sparingly)\nstring grade = score >= 90 ? \"A\" : \n               score >= 80 ? \"B\" : \n               score >= 70 ? \"C\" : \"F\";</code></pre><h4>üîß Logical Operators in Conditions</h4><h5>AND Operator (&&):</h5><pre><code>if (age >= 18 && hasLicense)\n{\n    Console.WriteLine(\"Can drive\");\n}</code></pre><h5>OR Operator (||):</h5><pre><code>if (isWeekend || isHoliday)\n{\n    Console.WriteLine(\"No work today!\");\n}</code></pre><h5>NOT Operator (!):</h5><pre><code>if (!isLoggedIn)\n{\n    Console.WriteLine(\"Please log in\");\n}</code></pre><h4>‚ö†Ô∏è Common Pitfalls</h4><ul><li><strong>Missing breaks</strong> in switch statements (fall-through)</li><li><strong>Complex conditions</strong> that are hard to read</li><li><strong>Deep nesting</strong> of if-else statements</li><li><strong>Comparing floats</strong> with == (use tolerance instead)</li><li><strong>Assignment vs comparison</strong> (= vs ==)</li></ul><h4>üèÜ Best Practices</h4><ul><li>Use switch expressions for multiple value comparisons</li><li>Keep conditions simple and readable</li><li>Use early returns to reduce nesting</li><li>Consider guard clauses for validation</li><li>Use meaningful variable names in conditions</li><li>Extract complex conditions into well-named methods</li><li>Prefer pattern matching for type checking</li></ul><h4>üéØ When to Use What</h4><ul><li><strong>If-else:</strong> Complex conditions, different data types</li><li><strong>Switch statement:</strong> Many discrete values, need multiple statements per case</li><li><strong>Switch expression:</strong> Mapping values, functional style, single expressions</li><li><strong>Ternary operator:</strong> Simple conditions with two outcomes</li></ul></div>",
      "code": "int n = 3;\nstring desc = n switch { 1 => \"one\", 2 => \"two\", _ => \"many\" };",
      "quiz": [
        { "q": "Which is a valid switch expression arm?", "options": ["case 1:", "1 => \"one\""], "answer": 1 }
      ],
      "completionCriteria": "Program uses switch expression for mapping values.",
      "nextLevel": 7
    },
    {
      "id": 7,
      "tier": 1,
      "title": "Looping",
      "description": "for, while, foreach patterns.",
      "requirements": [
        "Iterate arrays and lists",
        "Avoid off-by-one errors"
      ],
      "theory": "<div class='theory-content'><h4>üîÑ Looping - Repeating Code Efficiently</h4><p>Loops are fundamental programming constructs that allow you to execute code repeatedly. Instead of writing the same code multiple times, loops provide an elegant solution for repetitive tasks.</p><h4>üéØ For Loop - When You Know the Count</h4><h5>Basic For Loop Structure:</h5><pre><code>for (int i = 0; i < 10; i++)\n{\n    Console.WriteLine($\"Count: {i}\");\n}</code></pre><p><strong>Components of a for loop:</strong></p><ul><li><strong>Initialization:</strong> <code>int i = 0</code> - executed once at the start</li><li><strong>Condition:</strong> <code>i < 10</code> - checked before each iteration</li><li><strong>Increment:</strong> <code>i++</code> - executed after each iteration</li></ul><h5>Practical Examples:</h5><pre><code>// Print multiplication table\nfor (int i = 1; i <= 10; i++)\n{\n    Console.WriteLine($\"5 x {i} = {5 * i}\");\n}\n\n// Iterate through array indices\nint[] numbers = {1, 2, 3, 4, 5};\nfor (int i = 0; i < numbers.Length; i++)\n{\n    Console.WriteLine($\"Index {i}: {numbers[i]}\");\n}\n\n// Reverse iteration\nfor (int i = 10; i >= 1; i--)\n{\n    Console.WriteLine($\"Countdown: {i}\");\n}</code></pre><h4>üîÑ While Loop - Condition-Based Repetition</h4><h5>Basic While Loop:</h5><pre><code>int count = 0;\nwhile (count < 5)\n{\n    Console.WriteLine($\"Count: {count}\");\n    count++; // Don't forget to update the condition!\n}</code></pre><h5>Practical Examples:</h5><pre><code>// User input validation\nint userInput;\nwhile (true)\n{\n    Console.Write(\"Enter a number (1-10): \");\n    if (int.TryParse(Console.ReadLine(), out userInput) && \n        userInput >= 1 && userInput <= 10)\n    {\n        break; // Exit the loop when valid input is received\n    }\n    Console.WriteLine(\"Invalid input. Try again.\");\n}\n\n// Reading from a stream\nusing var reader = new StreamReader(\"file.txt\");\nstring line;\nwhile ((line = reader.ReadLine()) != null)\n{\n    Console.WriteLine(line);\n}</code></pre><h4>üé≤ Do-While Loop - Execute At Least Once</h4><h5>Basic Do-While Structure:</h5><pre><code>int attempts = 0;\ndo\n{\n    Console.WriteLine(\"Attempting connection...\");\n    attempts++;\n} while (attempts < 3);</code></pre><h5>Use Case - Menu Systems:</h5><pre><code>char choice;\ndo\n{\n    Console.WriteLine(\"Menu:\");\n    Console.WriteLine(\"1. Option A\");\n    Console.WriteLine(\"2. Option B\");\n    Console.WriteLine(\"3. Quit\");\n    Console.Write(\"Choose: \");\n    choice = Console.ReadKey().KeyChar;\n    Console.WriteLine();\n    \n    switch (choice)\n    {\n        case '1':\n            Console.WriteLine(\"You chose Option A\");\n            break;\n        case '2':\n            Console.WriteLine(\"You chose Option B\");\n            break;\n    }\n} while (choice != '3');</code></pre><h4>üé® Foreach Loop - Iterating Collections</h4><h5>Basic Foreach Syntax:</h5><pre><code>int[] numbers = {1, 2, 3, 4, 5};\nforeach (int number in numbers)\n{\n    Console.WriteLine(number);\n}</code></pre><h5>Advanced Foreach Examples:</h5><pre><code>// With different collection types\nList<string> names = new List<string> {\"Alice\", \"Bob\", \"Charlie\"};\nforeach (string name in names)\n{\n    Console.WriteLine($\"Hello, {name}!\");\n}\n\n// With dictionaries\nDictionary<string, int> scores = new Dictionary<string, int>\n{\n    {\"Alice\", 95},\n    {\"Bob\", 87},\n    {\"Charlie\", 92}\n};\n\nforeach (KeyValuePair<string, int> kvp in scores)\n{\n    Console.WriteLine($\"{kvp.Key}: {kvp.Value}\");\n}\n\n// Using var for type inference\nforeach (var item in scores)\n{\n    Console.WriteLine($\"{item.Key} scored {item.Value}\");\n}</code></pre><h4>üîß Loop Control Statements</h4><h5>Break Statement - Exit the Loop:</h5><pre><code>for (int i = 0; i < 100; i++)\n{\n    if (i == 50)\n    {\n        Console.WriteLine(\"Breaking at 50\");\n        break; // Exits the loop immediately\n    }\n    Console.WriteLine(i);\n}</code></pre><h5>Continue Statement - Skip Current Iteration:</h5><pre><code>for (int i = 0; i < 10; i++)\n{\n    if (i % 2 == 0) // Skip even numbers\n    {\n        continue; // Skip to next iteration\n    }\n    Console.WriteLine($\"Odd number: {i}\");\n}</code></pre><h4>üîÄ Nested Loops - Loops Within Loops</h4><h5>Matrix Operations:</h5><pre><code>int[,] matrix = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\n\nfor (int row = 0; row < 3; row++)\n{\n    for (int col = 0; col < 3; col++)\n    {\n        Console.Write($\"{matrix[row, col]} \");\n    }\n    Console.WriteLine(); // New line after each row\n}</code></pre><h5>Pattern Generation:</h5><pre><code>// Generate a multiplication table\nfor (int i = 1; i <= 10; i++)\n{\n    for (int j = 1; j <= 10; j++)\n    {\n        Console.Write($\"{i * j:D3} \"); // D3 formats to 3 digits\n    }\n    Console.WriteLine();\n}</code></pre><h4>‚ö° Performance Considerations</h4><ul><li><strong>For loops</strong> are fastest for indexed access</li><li><strong>Foreach loops</strong> are optimized for collections and are often as fast as for loops</li><li><strong>While loops</strong> have minimal overhead but require manual index management</li><li><strong>Avoid expensive operations</strong> in loop conditions</li><li><strong>Cache collection.Count</strong> in for loops when the collection doesn't change</li></ul><h5>Performance Example:</h5><pre><code>// Inefficient - Count is called every iteration\nfor (int i = 0; i < myList.Count; i++) { }\n\n// Better - Cache the count\nint count = myList.Count;\nfor (int i = 0; i < count; i++) { }\n\n// Best for this case - use foreach\nforeach (var item in myList) { }</code></pre><h4>üî¢ Loop Patterns and Techniques</h4><h5>Accumulator Pattern:</h5><pre><code>int[] numbers = {1, 2, 3, 4, 5};\nint sum = 0;\nforeach (int number in numbers)\n{\n    sum += number; // Accumulate the sum\n}\nConsole.WriteLine($\"Sum: {sum}\");</code></pre><h5>Counter Pattern:</h5><pre><code>string[] words = {\"apple\", \"banana\", \"cherry\", \"apple\"};\nint appleCount = 0;\nforeach (string word in words)\n{\n    if (word == \"apple\")\n    {\n        appleCount++;\n    }\n}\nConsole.WriteLine($\"Apples found: {appleCount}\");</code></pre><h5>Search Pattern:</h5><pre><code>int[] numbers = {1, 3, 7, 12, 18};\nint target = 12;\nbool found = false;\nint index = -1;\n\nfor (int i = 0; i < numbers.Length; i++)\n{\n    if (numbers[i] == target)\n    {\n        found = true;\n        index = i;\n        break; // Stop searching once found\n    }\n}\n\nif (found)\n{\n    Console.WriteLine($\"Found {target} at index {index}\");\n}\nelse\n{\n    Console.WriteLine($\"{target} not found\");\n}</code></pre><h4>‚ö†Ô∏è Common Pitfalls</h4><ul><li><strong>Infinite loops:</strong> Forgetting to update loop variables</li><li><strong>Off-by-one errors:</strong> Using <= instead of < with array.Length</li><li><strong>Modifying collections:</strong> Changing a collection while iterating</li><li><strong>Nested loop performance:</strong> O(n¬≤) complexity can be expensive</li><li><strong>Floating-point comparisons:</strong> Precision issues in loop conditions</li></ul><h4>üèÜ Best Practices</h4><ul><li>Use foreach for simple iteration over collections</li><li>Use for loops when you need the index</li><li>Use while loops for unknown iteration counts</li><li>Always ensure loop termination conditions</li><li>Keep loop bodies focused and simple</li><li>Extract complex loop logic into methods</li><li>Use meaningful variable names for loop counters</li><li>Consider LINQ for complex collection operations</li></ul><h4>üöÄ Modern C# Loop Features</h4><h5>Index and Range (C# 8.0+):</h5><pre><code>int[] numbers = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n// Using ranges in loops\nfor (int i = 2; i < 8; i++)\n{\n    Console.WriteLine(numbers[i]);\n}\n\n// Equivalent using range\nforeach (int number in numbers[2..8])\n{\n    Console.WriteLine(number);\n}</code></pre><h5>Parallel Loops:</h5><pre><code>using System.Threading.Tasks;\n\n// Parallel foreach for CPU-intensive operations\nParallel.ForEach(largeCollection, item =>\n{\n    // Process item in parallel\n    ProcessItem(item);\n});</code></pre></div>",
      "code": "var nums = new[] {1,2,3};\nforeach(var n in nums) Console.WriteLine(n);",
      "quiz": [
        { "q": "Which loop guarantees at least one iteration?", "options": ["for", "while", "do-while"], "answer": 2 }
      ],
      "completionCriteria": "Loop prints all items exactly once.",
      "nextLevel": 8
    },
    {
      "id": 8,
      "tier": 1,
      "title": "Iterators",
      "description": "yield return and IEnumerable.",
      "requirements": [
        "Implement an iterator method",
        "Use deferred execution"
      ],
      "theory": "<div class='theory-content'><h4>üé≠ Iterators - Creating Custom Sequences</h4><p>Iterators are a powerful C# feature that allows you to create custom enumerable sequences efficiently. They use the <code>yield</code> keyword to implement lazy evaluation and deferred execution.</p><h4>üéØ The yield Keyword - Lazy Evaluation</h4><h5>Basic Iterator Method:</h5><pre><code>public static IEnumerable<int> GetNumbers()\n{\n    yield return 1;\n    yield return 2;\n    yield return 3;\n}\n\n// Usage\nforeach (int number in GetNumbers())\n{\n    Console.WriteLine(number); // Prints 1, 2, 3\n}</code></pre><h5>Dynamic Iterator with Logic:</h5><pre><code>public static IEnumerable<int> GetEvenNumbers(int max)\n{\n    for (int i = 0; i <= max; i += 2)\n    {\n        Console.WriteLine($\"Generating: {i}\"); // This proves lazy evaluation\n        yield return i;\n    }\n}\n\n// Only generates values when enumerated\nvar evens = GetEvenNumbers(10); // No output yet!\nforeach (var num in evens.Take(3)) // Only generates 0, 2, 4\n{\n    Console.WriteLine($\"Received: {num}\");\n}</code></pre><h4>üîÑ How Iterators Work - State Machines</h4><p>When you use <code>yield return</code>, the C# compiler generates a state machine that implements <code>IEnumerable<T></code> and <code>IEnumerator<T></code>:</p><pre><code>// This method...\npublic static IEnumerable<string> GetMessages()\n{\n    Console.WriteLine(\"Before first yield\");\n    yield return \"Hello\";\n    Console.WriteLine(\"Between yields\");\n    yield return \"World\";\n    Console.WriteLine(\"After last yield\");\n}\n\n// Becomes a state machine that tracks:\n// - Current state (which yield we're at)\n// - Local variables\n// - Current value</code></pre><h4>üé® Practical Iterator Examples</h4><h5>Fibonacci Sequence:</h5><pre><code>public static IEnumerable<long> Fibonacci(int count)\n{\n    long a = 0, b = 1;\n    \n    for (int i = 0; i < count; i++)\n    {\n        yield return a;\n        (a, b) = (b, a + b); // Tuple deconstruction\n    }\n}\n\n// Generate first 10 Fibonacci numbers\nforeach (var fib in Fibonacci(10))\n{\n    Console.WriteLine(fib);\n}</code></pre><h5>File Line Reader:</h5><pre><code>public static IEnumerable<string> ReadLines(string filePath)\n{\n    using var reader = new StreamReader(filePath);\n    string line;\n    \n    while ((line = reader.ReadLine()) != null)\n    {\n        yield return line;\n    }\n} // File automatically closed when enumeration ends\n\n// Process large files efficiently\nforeach (var line in ReadLines(\"huge-file.txt\").Take(100))\n{\n    ProcessLine(line); // Only reads first 100 lines\n}</code></pre><h5>Tree Traversal:</h5><pre><code>public class TreeNode\n{\n    public string Value { get; set; }\n    public List<TreeNode> Children { get; set; } = new();\n    \n    // Depth-first traversal iterator\n    public IEnumerable<string> TraverseDepthFirst()\n    {\n        yield return Value; // Visit current node\n        \n        foreach (var child in Children)\n        {\n            foreach (var value in child.TraverseDepthFirst())\n            {\n                yield return value; // Recursively visit children\n            }\n        }\n    }\n}</code></pre><h4>üõë yield break - Early Termination</h4><pre><code>public static IEnumerable<int> GetNumbersUntilNegative(int[] numbers)\n{\n    foreach (int number in numbers)\n    {\n        if (number < 0)\n        {\n            yield break; // Stop iteration immediately\n        }\n        yield return number;\n    }\n}\n\nvar numbers = new[] { 1, 2, 3, -1, 4, 5 };\nforeach (var num in GetNumbersUntilNegative(numbers))\n{\n    Console.WriteLine(num); // Prints: 1, 2, 3 (stops at -1)\n}</code></pre><h4>‚ö° Performance Benefits</h4><h5>Memory Efficiency:</h5><pre><code>// Memory-efficient: Only one item in memory at a time\npublic static IEnumerable<int> GenerateMillionNumbers()\n{\n    for (int i = 0; i < 1_000_000; i++)\n    {\n        yield return i * i; // Calculate on demand\n    }\n}\n\n// vs. Memory-intensive: All items in memory\npublic static List<int> GenerateMillionNumbersList()\n{\n    var list = new List<int>();\n    for (int i = 0; i < 1_000_000; i++)\n    {\n        list.Add(i * i); // All stored in memory\n    }\n    return list;\n}</code></pre><h5>Lazy Evaluation Example:</h5><pre><code>public static IEnumerable<string> ProcessExpensiveData(IEnumerable<string> data)\n{\n    foreach (var item in data)\n    {\n        // Expensive operation only happens when enumerated\n        var processed = PerformExpensiveProcessing(item);\n        yield return processed;\n    }\n}\n\nvar data = GetLargeDataSet();\nvar processed = ProcessExpensiveData(data); // No processing yet!\n\n// Only processes first 5 items\nvar firstFive = processed.Take(5).ToList();</code></pre><h4>üîó Combining Iterators with LINQ</h4><pre><code>public static IEnumerable<T> Repeat<T>(T value, int count)\n{\n    for (int i = 0; i < count; i++)\n    {\n        yield return value;\n    }\n}\n\npublic static IEnumerable<int> Range(int start, int count)\n{\n    for (int i = 0; i < count; i++)\n    {\n        yield return start + i;\n    }\n}\n\n// Compose iterators with LINQ\nvar result = Range(1, 10)\n    .Where(x => x % 2 == 0)\n    .Select(x => x * x)\n    .Take(3);\n\nforeach (var value in result)\n{\n    Console.WriteLine(value); // 4, 16, 36\n}</code></pre><h4>üéØ IEnumerable vs IEnumerator</h4><h5>IEnumerable<T> - The Collection:</h5><pre><code>public interface IEnumerable<T>\n{\n    IEnumerator<T> GetEnumerator();\n}\n\n// Can be enumerated multiple times\nvar numbers = GetNumbers();\nforeach (var n in numbers) { } // First enumeration\nforeach (var n in numbers) { } // Second enumeration (starts over)</code></pre><h5>IEnumerator<T> - The Iterator:</h5><pre><code>public interface IEnumerator<T> : IDisposable\n{\n    T Current { get; }\n    bool MoveNext();\n    void Reset(); // Often not implemented\n}\n\n// Manual enumeration\nvar enumerator = GetNumbers().GetEnumerator();\nwhile (enumerator.MoveNext())\n{\n    Console.WriteLine(enumerator.Current);\n}\nenumerator.Dispose();</code></pre><h4>üîß Advanced Iterator Patterns</h4><h5>Parameterized Iterators:</h5><pre><code>public static IEnumerable<T> Generate<T>(T seed, Func<T, T> generator, int count)\n{\n    var current = seed;\n    for (int i = 0; i < count; i++)\n    {\n        yield return current;\n        current = generator(current);\n    }\n}\n\n// Generate powers of 2\nvar powersOfTwo = Generate(1, x => x * 2, 10);\nforeach (var power in powersOfTwo)\n{\n    Console.WriteLine(power); // 1, 2, 4, 8, 16, ...\n}</code></pre><h5>Infinite Sequences:</h5><pre><code>public static IEnumerable<DateTime> InfiniteDates(DateTime start)\n{\n    var current = start;\n    while (true) // Infinite loop!\n    {\n        yield return current;\n        current = current.AddDays(1);\n    }\n}\n\n// Safe to create (lazy evaluation)\nvar dates = InfiniteDates(DateTime.Today);\n\n// Only take what you need\nvar nextWeek = dates.Take(7).ToList();</code></pre><h4>‚ö†Ô∏è Common Pitfalls</h4><ul><li><strong>Multiple enumeration:</strong> Iterator methods execute each time they're enumerated</li><li><strong>Exception handling:</strong> Exceptions in iterators can be tricky</li><li><strong>Resource management:</strong> Be careful with disposable resources</li><li><strong>Debugging:</strong> Harder to debug due to deferred execution</li><li><strong>Side effects:</strong> Code executes when enumerated, not when called</li></ul><h5>Multiple Enumeration Issue:</h5><pre><code>// ‚ùå This can be expensive!\npublic static IEnumerable<string> ExpensiveOperation()\n{\n    Console.WriteLine(\"Doing expensive work...\");\n    yield return \"Result 1\";\n    yield return \"Result 2\";\n}\n\nvar data = ExpensiveOperation();\nvar count1 = data.Count(); // \"Doing expensive work...\" printed\nvar count2 = data.Count(); // \"Doing expensive work...\" printed AGAIN!\n\n// ‚úÖ Better: Materialize when needed\nvar materializedData = ExpensiveOperation().ToList();\nvar count1 = materializedData.Count(); // No re-execution\nvar count2 = materializedData.Count(); // No re-execution</code></pre><h4>üõ°Ô∏è Exception Handling in Iterators</h4><pre><code>public static IEnumerable<string> SafeIterator(IEnumerable<string> input)\n{\n    // Validation happens immediately\n    if (input == null)\n        throw new ArgumentNullException(nameof(input));\n    \n    return SafeIteratorImpl(input);\n}\n\nprivate static IEnumerable<string> SafeIteratorImpl(IEnumerable<string> input)\n{\n    foreach (var item in input)\n    {\n        // This exception happens during enumeration\n        if (string.IsNullOrEmpty(item))\n            throw new InvalidOperationException(\"Empty item found\");\n            \n        yield return item.ToUpper();\n    }\n}</code></pre><h4>üèÜ Best Practices</h4><ul><li>Use iterators for large or infinite sequences</li><li>Be mindful of multiple enumeration costs</li><li>Validate parameters before the iterator implementation</li><li>Use <code>yield break</code> for early termination</li><li>Consider materializing with <code>ToList()</code> when appropriate</li><li>Document deferred execution behavior</li><li>Use iterators with LINQ for powerful composition</li><li>Prefer iterators over manually implementing IEnumerable</li></ul><h4>üöÄ Modern Iterator Features</h4><h5>Async Iterators (C# 8.0+):</h5><pre><code>public static async IAsyncEnumerable<string> ReadLinesAsync(string filePath)\n{\n    using var reader = new StreamReader(filePath);\n    string line;\n    \n    while ((line = await reader.ReadLineAsync()) != null)\n    {\n        yield return line;\n    }\n}\n\n// Async enumeration\nawait foreach (var line in ReadLinesAsync(\"file.txt\"))\n{\n    await ProcessLineAsync(line);\n}</code></pre><h5>Local Functions with Iterators:</h5><pre><code>public static IEnumerable<int> GetPrimes(int max)\n{\n    return GetPrimesImpl();\n    \n    IEnumerable<int> GetPrimesImpl()\n    {\n        for (int i = 2; i <= max; i++)\n        {\n            if (IsPrime(i))\n                yield return i;\n        }\n    }\n    \n    bool IsPrime(int n) => /* prime check logic */;\n}</code></pre></div>",
      "code": "IEnumerable<int> Evens(int max){\n  for(int i=0;i<=max;i+=2) yield return i;\n}\nforeach(var e in Evens(6)) Console.WriteLine(e);",
      "quiz": [
        { "q": "What does yield return enable?", "options": ["Eager evaluation", "Deferred execution"], "answer": 1 }
      ],
      "completionCriteria": "Custom iterator yields expected sequence.",
      "nextLevel": 9
    },
    {
      "id": 9,
      "tier": 1,
      "title": ".NET Ecosystem",
      "description": "CLR, FCL, tooling overview.",
      "concepts": ["CLR", "FCL", "Visual Studio", "VS Code Setup"],
      "requirements": [
        "Explain CLR and FCL",
        "Install and verify .NET SDK"
      ],
      "theory": "<div class='theory-content'><h4>üåê .NET Ecosystem - Understanding the Foundation</h4><p>The .NET ecosystem is a comprehensive platform for building applications across different domains. Understanding its components is crucial for becoming a proficient C# developer.</p><h4>üèóÔ∏è Common Language Runtime (CLR) - The Engine</h4><p>The CLR is the execution environment that runs .NET applications. It provides several critical services:</p><h5>Key CLR Responsibilities:</h5><ul><li><strong>Memory Management:</strong> Automatic garbage collection</li><li><strong>Type Safety:</strong> Ensures type system integrity</li><li><strong>Exception Handling:</strong> Structured exception management</li><li><strong>Security:</strong> Code access security and verification</li><li><strong>Threading:</strong> Thread management and synchronization</li></ul><h5>JIT Compilation Process:</h5><pre><code>C# Source Code (.cs)\n       ‚Üì (C# Compiler - Roslyn)\nIntermediate Language (.dll/.exe with IL)\n       ‚Üì (Just-In-Time Compiler)\nNative Machine Code (x86, x64, ARM)\n       ‚Üì\nExecution on Target Platform</code></pre><h5>Memory Management - Heap vs Stack:</h5><pre><code>public class MemoryExample\n{\n    public static void DemonstrateMemory()\n    {\n        // Stack allocated (value types)\n        int stackValue = 42;        // Lives on stack\n        DateTime now = DateTime.Now; // Struct - stack\n        \n        // Heap allocated (reference types)\n        string text = \"Hello\";      // Reference on stack, object on heap\n        var list = new List<int>(); // Reference on stack, object on heap\n        \n        // The CLR's Garbage Collector will automatically\n        // clean up heap objects when they're no longer referenced\n    }\n}</code></pre><h4>üìö Framework Class Library (FCL) - The Toolkit</h4><p>The FCL provides thousands of pre-built classes and methods for common programming tasks:</p><h5>Core FCL Namespaces:</h5><pre><code>// System - Core types and utilities\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// Input/Output operations\nusing System.IO;\nusing System.Text;\n\n// Networking\nusing System.Net;\nusing System.Net.Http;\n\n// Threading and async operations\nusing System.Threading;\nusing System.Threading.Tasks;\n\n// Data access\nusing System.Data;\nusing System.Data.SqlClient;</code></pre><h5>FCL in Action:</h5><pre><code>// File operations\nstring content = File.ReadAllText(\"data.txt\");\n\n// HTTP client\nusing var client = new HttpClient();\nstring response = await client.GetStringAsync(\"https://api.example.com\");\n\n// JSON serialization\nvar person = new { Name = \"Alice\", Age = 30 };\nstring json = JsonSerializer.Serialize(person);\n\n// LINQ operations\nint[] numbers = { 1, 2, 3, 4, 5 };\nvar evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();</code></pre><h4>üõ†Ô∏è .NET SDK and Tooling</h4><h5>Essential .NET CLI Commands:</h5><pre><code>// Check installed SDKs and runtimes\ndotnet --info\ndotnet --list-sdks\ndotnet --list-runtimes\n\n// Create new projects\ndotnet new console -n MyConsoleApp\ndotnet new classlib -n MyLibrary\ndotnet new web -n MyWebApp\ndotnet new blazorserver -n MyBlazorApp\n\n// Build and run\ndotnet build\ndotnet run\ndotnet publish -c Release\n\n// Package management\ndotnet add package Newtonsoft.Json\ndotnet remove package PackageName\ndotnet restore</code></pre><h5>Project File Structure (.csproj):</h5><pre><code><Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n  \n  <ItemGroup>\n    <PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\n  </ItemGroup>\n</Project></code></pre><h4>üéØ .NET Implementations and Targets</h4><h5>.NET Framework vs .NET (Core):</h5><table><tr><th>Aspect</th><th>.NET Framework</th><th>.NET (5+)</th></tr><tr><td>Platform</td><td>Windows Only</td><td>Cross-platform</td></tr><tr><td>Open Source</td><td>Partially</td><td>Fully</td></tr><tr><td>Performance</td><td>Good</td><td>Excellent</td></tr><tr><td>Modern Features</td><td>Limited</td><td>Latest C# features</td></tr><tr><td>Deployment</td><td>Framework required</td><td>Self-contained options</td></tr></table><h5>Target Framework Monikers (TFMs):</h5><pre><code>// Modern .NET\nnet8.0          // .NET 8.0\nnet7.0          // .NET 7.0\nnet6.0          // .NET 6.0 (LTS)\n\n// Legacy .NET Framework\nnet48           // .NET Framework 4.8\nnet472          // .NET Framework 4.7.2\n\n// .NET Standard (for libraries)\nnetstandard2.1  // .NET Standard 2.1\nnetstandard2.0  // .NET Standard 2.0</code></pre><h4>üîß Development Environment Setup</h4><h5>Visual Studio vs VS Code:</h5><ul><li><strong>Visual Studio:</strong> Full-featured IDE, excellent for large projects, Windows/Mac</li><li><strong>VS Code:</strong> Lightweight, cross-platform, great for web development</li><li><strong>JetBrains Rider:</strong> Powerful cross-platform IDE, excellent refactoring tools</li><li><strong>Visual Studio for Mac:</strong> Native Mac IDE (being discontinued in favor of VS Code)</li></ul><h5>Essential VS Code Extensions for C#:</h5><pre><code>// Install via VS Code Extensions marketplace\n1. C# Dev Kit (ms-dotnettools.csdevkit)\n2. .NET Extension Pack\n3. NuGet Package Manager\n4. C# Extensions\n5. GitLens\n6. Prettier - Code formatter</code></pre><h4>üöÄ .NET Runtime Components</h4><h5>Base Class Library (BCL):</h5><pre><code>// Core types available in all .NET applications\nSystem.Object       // Base of all types\nSystem.String       // Immutable text\nSystem.Int32        // 32-bit integer\nSystem.DateTime     // Date and time\nSystem.Exception    // Base exception type\nSystem.Collections.Generic.List<T>  // Dynamic array</code></pre><h5>Runtime Services:</h5><pre><code>// Garbage Collector behavior\nGC.Collect();           // Force garbage collection (rarely needed)\nGC.GetTotalMemory(false); // Get current memory usage\n\n// Type reflection\nType stringType = typeof(string);\nMethodInfo[] methods = stringType.GetMethods();\n\n// Assembly loading\nAssembly assembly = Assembly.LoadFrom(\"MyLibrary.dll\");</code></pre><h4>üåç Cross-Platform Development</h4><h5>Platform Detection:</h5><pre><code>using System.Runtime.InteropServices;\n\npublic static class PlatformHelper\n{\n    public static void ShowPlatformInfo()\n    {\n        Console.WriteLine($\"OS: {RuntimeInformation.OSDescription}\");\n        Console.WriteLine($\"Architecture: {RuntimeInformation.OSArchitecture}\");\n        Console.WriteLine($\"Framework: {RuntimeInformation.FrameworkDescription}\");\n        \n        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n            Console.WriteLine(\"Running on Windows\");\n        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\n            Console.WriteLine(\"Running on Linux\");\n        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))\n            Console.WriteLine(\"Running on macOS\");\n    }\n}</code></pre><h4>üì¶ Package Management with NuGet</h4><h5>Using NuGet Packages:</h5><pre><code>// Add packages via CLI\ndotnet add package Microsoft.Extensions.Logging\ndotnet add package EntityFrameworkCore\ndotnet add package AutoMapper\n\n// Using packages in code\nusing Microsoft.Extensions.Logging;\nusing Microsoft.EntityFrameworkCore;\nusing AutoMapper;</code></pre><h5>Creating Your Own NuGet Package:</h5><pre><code>// In your .csproj file\n<PropertyGroup>\n  <PackageId>MyAwesomeLibrary</PackageId>\n  <Version>1.0.0</Version>\n  <Authors>Your Name</Authors>\n  <Description>A description of your library</Description>\n  <PackageLicenseExpression>MIT</PackageLicenseExpression>\n</PropertyGroup>\n\n// Build and pack\ndotnet pack -c Release\ndotnet nuget push bin/Release/*.nupkg --api-key YOUR_API_KEY</code></pre><h4>üîç Debugging and Diagnostics</h4><h5>Built-in Debugging Support:</h5><pre><code>using System.Diagnostics;\n\npublic class DebuggingExample\n{\n    public static void Main()\n    {\n        Debug.WriteLine(\"Debug message\"); // Only in Debug builds\n        Trace.WriteLine(\"Trace message\");  // In Debug and Release\n        \n        // Conditional compilation\n        #if DEBUG\n        Console.WriteLine(\"This only runs in debug mode\");\n        #endif\n        \n        // Performance measurement\n        var stopwatch = Stopwatch.StartNew();\n        DoSomeWork();\n        stopwatch.Stop();\n        Console.WriteLine($\"Elapsed: {stopwatch.ElapsedMilliseconds}ms\");\n    }\n}</code></pre><h4>‚ö° Performance and Optimization</h4><h5>JIT Optimization:</h5><pre><code>// The JIT compiler optimizes code based on usage patterns\n// Hot paths get more optimization\n// Cold code gets minimal optimization\n\n// AOT (Ahead-of-Time) compilation for faster startup\n// Available in .NET 7+ for specific scenarios\ndotnet publish -r win-x64 -c Release --self-contained -p:PublishAot=true</code></pre><h5>Memory Profiling Tools:</h5><ul><li><strong>dotMemory (JetBrains):</strong> Commercial memory profiler</li><li><strong>PerfView:</strong> Free Microsoft tool for memory analysis</li><li><strong>Visual Studio Diagnostic Tools:</strong> Built-in profiling</li><li><strong>dotnet-counters:</strong> Command-line performance monitoring</li></ul><h4>üèÜ Best Practices</h4><ul><li>Keep up with .NET LTS (Long Term Support) versions</li><li>Use the latest C# language features when possible</li><li>Leverage the FCL instead of reinventing common functionality</li><li>Understand memory management to write efficient code</li><li>Use appropriate project templates for your application type</li><li>Take advantage of cross-platform capabilities</li><li>Implement proper logging and diagnostics from the start</li><li>Use package management effectively</li></ul><h4>üöÄ Future of .NET</h4><ul><li><strong>.NET 8 (LTS):</strong> Current long-term support version</li><li><strong>Annual Releases:</strong> New version every November</li><li><strong>Cloud-Native:</strong> Optimized for containers and microservices</li><li><strong>Performance:</strong> Continuous improvements in speed and memory usage</li><li><strong>Native AOT:</strong> Compile-time optimization for specific scenarios</li><li><strong>WebAssembly:</strong> Running .NET in browsers with Blazor</li></ul></div>",
      "code": "// Verify SDK via command line\n// dotnet --version\n// dotnet new console -n Hello\n// dotnet run",
      "quiz": [
        { "q": "JIT compiles IL to?", "options": ["Java bytecode", "Native machine code"], "answer": 1 }
      ],
      "completionCriteria": "Explain CLR vs FCL in your own words.",
      "nextLevel": 10
    },
    {
      "id": 10,
      "tier": 1,
      "title": "Classes & Objects",
      "description": "Constructors, destructors, properties, indexers, static members.",
      "concepts": ["Constructors", "Destructors", "Properties", "Indexers", "Static Members"],
      "requirements": ["Define a class with properties", "Add a constructor", "Use a static member"],
      "theory": "<div class='theory-content'><h4>üèóÔ∏è Classes & Objects - Building Blocks of OOP</h4><p>Classes are blueprints for creating objects. They encapsulate data (fields and properties) and behavior (methods) into a single unit, forming the foundation of object-oriented programming in C#.</p><h4>üéØ Class Declaration and Structure</h4><h5>Basic Class Definition:</h5><pre><code>public class Person\n{\n    // Fields (usually private)\n    private string _name;\n    private int _age;\n    \n    // Properties (public interface)\n    public string Name \n    { \n        get => _name; \n        set => _name = value ?? throw new ArgumentNullException(nameof(value));\n    }\n    \n    public int Age\n    {\n        get => _age;\n        set => _age = value >= 0 ? value : throw new ArgumentException(\"Age cannot be negative\");\n    }\n    \n    // Auto-implemented properties\n    public DateTime BirthDate { get; set; }\n    public string Email { get; init; } // Init-only property (C# 9+)\n    \n    // Read-only computed property\n    public int YearsUntilRetirement => Math.Max(0, 65 - Age);\n}</code></pre><h4>üîß Constructors - Object Initialization</h4><h5>Multiple Constructor Patterns:</h5><pre><code>public class Employee\n{\n    public string Name { get; }\n    public int Id { get; }\n    public decimal Salary { get; set; }\n    public Department Department { get; set; }\n    \n    // Default constructor\n    public Employee()\n    {\n        Name = \"Unknown\";\n        Id = -1;\n        Salary = 0;\n    }\n    \n    // Primary constructor\n    public Employee(string name, int id)\n    {\n        Name = name ?? throw new ArgumentNullException(nameof(name));\n        Id = id > 0 ? id : throw new ArgumentException(\"ID must be positive\");\n        Salary = 0;\n    }\n    \n    // Constructor chaining\n    public Employee(string name, int id, decimal salary) : this(name, id)\n    {\n        Salary = salary;\n    }\n    \n    // Constructor with all parameters\n    public Employee(string name, int id, decimal salary, Department department) \n        : this(name, id, salary)\n    {\n        Department = department;\n    }\n}</code></pre><h5>Primary Constructors (C# 12+):</h5><pre><code>// Modern, concise syntax\npublic class Point(double x, double y)\n{\n    public double X { get; } = x;\n    public double Y { get; } = y;\n    \n    public double DistanceFromOrigin => Math.Sqrt(X * X + Y * Y);\n    \n    public override string ToString() => $\"({x}, {y})\"; // Can use constructor parameters\n}</code></pre><h4>üîí Access Modifiers and Encapsulation</h4><h5>Access Levels:</h5><pre><code>public class AccessExample\n{\n    public string PublicField;        // Accessible everywhere\n    private string _privateField;     // Only within this class\n    protected string ProtectedField;  // This class and derived classes\n    internal string InternalField;    // Within the same assembly\n    protected internal string ProtectedInternalField; // Protected OR internal\n    private protected string PrivateProtectedField;   // Protected AND internal\n    \n    // Property with different access levels for get/set\n    public string Name \n    { \n        get; \n        private set; // Only this class can set the value\n    }\n}</code></pre><h4>üé≠ Properties - Controlled Access to Data</h4><h5>Property Patterns:</h5><pre><code>public class BankAccount\n{\n    private decimal _balance;\n    \n    // Full property with validation\n    public decimal Balance\n    {\n        get => _balance;\n        private set\n        {\n            if (value < 0)\n                throw new ArgumentException(\"Balance cannot be negative\");\n            _balance = value;\n        }\n    }\n    \n    // Auto-implemented property with private setter\n    public string AccountNumber { get; private set; }\n    \n    // Computed property (read-only)\n    public string DisplayBalance => $\"${Balance:F2}\";\n    \n    // Property with backing field and lazy initialization\n    private List<Transaction> _transactions;\n    public List<Transaction> Transactions\n    {\n        get\n        {\n            _transactions ??= new List<Transaction>();\n            return _transactions;\n        }\n    }\n    \n    public void Deposit(decimal amount)\n    {\n        if (amount <= 0)\n            throw new ArgumentException(\"Deposit amount must be positive\");\n        \n        Balance += amount;\n        Transactions.Add(new Transaction(\"Deposit\", amount, DateTime.Now));\n    }\n}</code></pre><h4>üìö Indexers - Array-Like Access</h4><h5>Basic Indexer:</h5><pre><code>public class StudentGrades\n{\n    private Dictionary<string, double> _grades = new();\n    \n    // String indexer\n    public double this[string subject]\n    {\n        get => _grades.TryGetValue(subject, out var grade) ? grade : 0.0;\n        set\n        {\n            if (value < 0 || value > 100)\n                throw new ArgumentException(\"Grade must be between 0 and 100\");\n            _grades[subject] = value;\n        }\n    }\n    \n    // Multiple parameter indexer\n    public double this[string subject, int semester]\n    {\n        get => this[$\"{subject}_S{semester}\"];\n        set => this[$\"{subject}_S{semester}\"] = value;\n    }\n    \n    public IEnumerable<string> Subjects => _grades.Keys;\n    public double AverageGrade => _grades.Count > 0 ? _grades.Values.Average() : 0.0;\n}</code></pre><h5>Advanced Indexer Examples:</h5><pre><code>public class Matrix\n{\n    private double[,] _data;\n    \n    public Matrix(int rows, int cols)\n    {\n        _data = new double[rows, cols];\n    }\n    \n    // 2D indexer\n    public double this[int row, int col]\n    {\n        get\n        {\n            ValidateIndices(row, col);\n            return _data[row, col];\n        }\n        set\n        {\n            ValidateIndices(row, col);\n            _data[row, col] = value;\n        }\n    }\n    \n    // Range indexer (C# 8+)\n    public double[] this[int row, Range colRange]\n    {\n        get\n        {\n            var (start, length) = colRange.GetOffsetAndLength(_data.GetLength(1));\n            var result = new double[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = _data[row, start + i];\n            }\n            return result;\n        }\n    }\n    \n    private void ValidateIndices(int row, int col)\n    {\n        if (row < 0 || row >= _data.GetLength(0))\n            throw new IndexOutOfRangeException(\"Row index out of range\");\n        if (col < 0 || col >= _data.GetLength(1))\n            throw new IndexOutOfRangeException(\"Column index out of range\");\n    }\n}</code></pre><h4>‚ö° Static Members - Type-Level Functionality</h4><h5>Static Fields and Properties:</h5><pre><code>public class Counter\n{\n    // Static field - shared across all instances\n    private static int _totalInstances = 0;\n    \n    // Instance field - unique to each instance\n    private int _instanceId;\n    \n    // Static property\n    public static int TotalInstances => _totalInstances;\n    \n    // Instance property\n    public int InstanceId => _instanceId;\n    \n    public Counter()\n    {\n        _instanceId = ++_totalInstances; // Increment and assign\n    }\n    \n    // Static method\n    public static void ResetCounter()\n    {\n        _totalInstances = 0;\n    }\n    \n    // Static constructor - runs once when type is first used\n    static Counter()\n    {\n        Console.WriteLine(\"Counter type initialized\");\n        _totalInstances = 0;\n    }\n}</code></pre><h5>Static Classes and Extension Methods:</h5><pre><code>// Static class - cannot be instantiated\npublic static class MathHelper\n{\n    public static double ToRadians(double degrees) => degrees * Math.PI / 180;\n    public static double ToDegrees(double radians) => radians * 180 / Math.PI;\n    \n    public static bool IsPrime(int number)\n    {\n        if (number < 2) return false;\n        for (int i = 2; i <= Math.Sqrt(number); i++)\n        {\n            if (number % i == 0) return false;\n        }\n        return true;\n    }\n}\n\n// Extension methods (must be in static class)\npublic static class StringExtensions\n{\n    public static bool IsValidEmail(this string email)\n    {\n        return !string.IsNullOrEmpty(email) && email.Contains('@');\n    }\n    \n    public static string Truncate(this string value, int maxLength)\n    {\n        if (string.IsNullOrEmpty(value)) return value;\n        return value.Length <= maxLength ? value : value[..maxLength] + \"...\";\n    }\n}\n\n// Usage\nstring email = \"user@example.com\";\nbool isValid = email.IsValidEmail(); // Extension method\nstring truncated = \"Very long text\".Truncate(10);</code></pre><h4>üíÄ Finalizers and IDisposable</h4><h5>Proper Resource Management:</h5><pre><code>public class FileProcessor : IDisposable\n{\n    private FileStream _fileStream;\n    private bool _disposed = false;\n    \n    public FileProcessor(string filePath)\n    {\n        _fileStream = new FileStream(filePath, FileMode.Open);\n    }\n    \n    // Finalizer (destructor) - rarely needed\n    ~FileProcessor()\n    {\n        Dispose(false);\n    }\n    \n    // IDisposable implementation\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n    \n    protected virtual void Dispose(bool disposing)\n    {\n        if (!_disposed)\n        {\n            if (disposing)\n            {\n                // Dispose managed resources\n                _fileStream?.Dispose();\n            }\n            \n            // Dispose unmanaged resources (if any)\n            _disposed = true;\n        }\n    }\n    \n    public void ProcessFile()\n    {\n        if (_disposed)\n            throw new ObjectDisposedException(nameof(FileProcessor));\n        \n        // Process the file...\n    }\n}</code></pre><h4>üîÑ Object Initialization Patterns</h4><h5>Object Initializers:</h5><pre><code>// Traditional constructor\nvar person1 = new Person(\"Alice\", 30);\n\n// Object initializer syntax\nvar person2 = new Person\n{\n    Name = \"Bob\",\n    Age = 25,\n    Email = \"bob@example.com\"\n};\n\n// Collection initializer\nvar people = new List<Person>\n{\n    new() { Name = \"Charlie\", Age = 35 },\n    new() { Name = \"Diana\", Age = 28 }\n};\n\n// With statement (C# 9+) - creates copy with changes\nvar person3 = person2 with { Age = 26 };</code></pre><h5>Record Types (C# 9+):</h5><pre><code>// Record - immutable by default\npublic record PersonRecord(string Name, int Age)\n{\n    public string Email { get; init; }\n}\n\n// Usage\nvar person = new PersonRecord(\"Alice\", 30) { Email = \"alice@example.com\" };\nvar olderPerson = person with { Age = 31 }; // Creates new instance\n\n// Value equality by default\nvar person1 = new PersonRecord(\"Bob\", 25);\nvar person2 = new PersonRecord(\"Bob\", 25);\nConsole.WriteLine(person1 == person2); // True (value equality)</code></pre><h4>‚ö†Ô∏è Common Pitfalls</h4><ul><li><strong>Public fields:</strong> Use properties instead for better encapsulation</li><li><strong>Constructors without validation:</strong> Always validate constructor parameters</li><li><strong>Mutable static state:</strong> Can cause thread safety issues</li><li><strong>Finalizers:</strong> Rarely needed and impact performance</li><li><strong>Property getters with side effects:</strong> Should be idempotent</li><li><strong>Circular references:</strong> Can prevent garbage collection</li></ul><h4>üèÜ Best Practices</h4><ul><li>Favor composition over inheritance</li><li>Keep classes focused on a single responsibility</li><li>Use properties instead of public fields</li><li>Implement IDisposable for resource management</li><li>Use readonly fields for immutable data</li><li>Prefer auto-implemented properties when possible</li><li>Use meaningful names for classes and members</li><li>Document complex indexers and their usage</li><li>Consider record types for data transfer objects</li></ul><h4>üöÄ Modern C# Features for Classes</h4><h5>Init-only Properties and Records:</h5><pre><code>public class ModernPerson\n{\n    public string Name { get; init; }     // Can only be set during initialization\n    public int Age { get; init; }\n    required public string Email { get; init; } // Required property (C# 11+)\n}\n\n// Usage\nvar person = new ModernPerson\n{\n    Name = \"Alice\",\n    Age = 30,\n    Email = \"alice@example.com\" // Required - compiler error if missing\n};</code></pre><h5>Pattern Matching with Classes:</h5><pre><code>public static string DescribePerson(Person person) => person switch\n{\n    { Age: < 18 } => \"Minor\",\n    { Age: >= 18 and < 65, Name: var name } => $\"Adult: {name}\",\n    { Age: >= 65 } => \"Senior\",\n    null => \"No person\"\n};</code></pre></div>",
      "code": "public class Counter {\n  public static int Instances;\n  public int Value { get; private set; }\n  public int this[int i] => Value + i;\n  public Counter(int start=0){ Value = start; Instances++; }\n}",
      "quiz": [ {"q":"What does static mean?","options":["Per instance","Per type"],"answer":1} ]
    },
    {
      "id": 11,
      "tier": 1,
      "title": "OOP Principles",
      "description": "Encapsulation, inheritance, polymorphism, abstraction.",
      "concepts": ["Encapsulation", "Inheritance", "Polymorphism", "Abstraction"],
      "requirements": ["Hide fields behind properties", "Derive a class and override a method"],
      "theory": "<div class='theory-content'><h4>üèõÔ∏è OOP Principles - The Four Pillars</h4><p>Object-Oriented Programming is built on four fundamental principles that help create maintainable, scalable, and robust software. Understanding these principles is crucial for writing professional C# code.</p><h4>üîí Encapsulation - Data Hiding and Protection</h4><p>Encapsulation is about bundling data and methods that operate on that data within a single unit (class) and controlling access to them.</p><h5>Proper Encapsulation Example:</h5><pre><code>public class BankAccount\n{\n    // Private fields - hidden from external access\n    private decimal _balance;\n    private string _accountNumber;\n    private List<Transaction> _transactions;\n    \n    // Public properties with controlled access\n    public decimal Balance \n    { \n        get => _balance; \n        private set // Only this class can modify balance\n        {\n            if (value < 0)\n                throw new ArgumentException(\"Balance cannot be negative\");\n            _balance = value;\n        }\n    }\n    \n    public string AccountNumber => _accountNumber; // Read-only\n    public IReadOnlyList<Transaction> Transactions => _transactions.AsReadOnly();\n    \n    public BankAccount(string accountNumber, decimal initialBalance = 0)\n    {\n        _accountNumber = accountNumber ?? throw new ArgumentNullException(nameof(accountNumber));\n        _transactions = new List<Transaction>();\n        Balance = initialBalance; // Uses property validation\n    }\n    \n    // Controlled methods for modifying state\n    public void Deposit(decimal amount)\n    {\n        if (amount <= 0)\n            throw new ArgumentException(\"Deposit amount must be positive\");\n        \n        Balance += amount;\n        _transactions.Add(new Transaction(\"Deposit\", amount, DateTime.Now));\n    }\n    \n    public bool Withdraw(decimal amount)\n    {\n        if (amount <= 0)\n            throw new ArgumentException(\"Withdrawal amount must be positive\");\n        \n        if (amount > Balance)\n            return false; // Insufficient funds\n        \n        Balance -= amount;\n        _transactions.Add(new Transaction(\"Withdrawal\", -amount, DateTime.Now));\n        return true;\n    }\n}</code></pre><h4>üß¨ Inheritance - Code Reuse and Specialization</h4><p>Inheritance allows a class to inherit properties and methods from another class, promoting code reuse and establishing \"is-a\" relationships.</p><h5>Inheritance Hierarchy:</h5><pre><code>// Base class\npublic abstract class Vehicle\n{\n    public string Make { get; set; }\n    public string Model { get; set; }\n    public int Year { get; set; }\n    protected bool _isRunning;\n    \n    protected Vehicle(string make, string model, int year)\n    {\n        Make = make;\n        Model = model;\n        Year = year;\n        _isRunning = false;\n    }\n    \n    // Virtual method - can be overridden\n    public virtual void Start()\n    {\n        _isRunning = true;\n        Console.WriteLine($\"{Make} {Model} is starting...\");\n    }\n    \n    // Abstract method - must be implemented by derived classes\n    public abstract void Accelerate();\n    \n    // Sealed method - cannot be overridden further\n    public sealed override string ToString()\n    {\n        return $\"{Year} {Make} {Model}\";\n    }\n}\n\n// Derived class\npublic class Car : Vehicle\n{\n    public int NumberOfDoors { get; set; }\n    \n    public Car(string make, string model, int year, int doors) \n        : base(make, model, year) // Call base constructor\n    {\n        NumberOfDoors = doors;\n    }\n    \n    // Override virtual method\n    public override void Start()\n    {\n        base.Start(); // Call base implementation\n        Console.WriteLine(\"Car engine warming up...\");\n    }\n    \n    // Implement abstract method\n    public override void Accelerate()\n    {\n        if (!_isRunning)\n        {\n            Start();\n        }\n        Console.WriteLine(\"Car is accelerating with engine power...\");\n    }\n}\n\npublic class ElectricCar : Car\n{\n    public int BatteryCapacity { get; set; }\n    \n    public ElectricCar(string make, string model, int year, int doors, int batteryCapacity)\n        : base(make, model, year, doors)\n    {\n        BatteryCapacity = batteryCapacity;\n    }\n    \n    // Override method with different behavior\n    public override void Start()\n    {\n        _isRunning = true;\n        Console.WriteLine($\"{Make} {Model} electric motor is ready...\");\n        // Note: Not calling base.Start() for different behavior\n    }\n    \n    public override void Accelerate()\n    {\n        if (!_isRunning)\n        {\n            Start();\n        }\n        Console.WriteLine(\"Electric car accelerating silently...\");\n    }\n}</code></pre><h4>üé≠ Polymorphism - One Interface, Multiple Forms</h4><p>Polymorphism allows objects of different types to be treated as instances of the same base type, with the correct method being called at runtime.</p><h5>Runtime Polymorphism:</h5><pre><code>public abstract class Shape\n{\n    public abstract double CalculateArea();\n    public abstract double CalculatePerimeter();\n    \n    // Virtual method with default implementation\n    public virtual string GetDescription()\n    {\n        return $\"This is a shape with area {CalculateArea():F2}\";\n    }\n}\n\npublic class Rectangle : Shape\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n    \n    public Rectangle(double width, double height)\n    {\n        Width = width;\n        Height = height;\n    }\n    \n    public override double CalculateArea() => Width * Height;\n    public override double CalculatePerimeter() => 2 * (Width + Height);\n    \n    public override string GetDescription()\n    {\n        return $\"Rectangle {Width}x{Height} with area {CalculateArea():F2}\";\n    }\n}\n\npublic class Circle : Shape\n{\n    public double Radius { get; set; }\n    \n    public Circle(double radius)\n    {\n        Radius = radius;\n    }\n    \n    public override double CalculateArea() => Math.PI * Radius * Radius;\n    public override double CalculatePerimeter() => 2 * Math.PI * Radius;\n    \n    public override string GetDescription()\n    {\n        return $\"Circle with radius {Radius} and area {CalculateArea():F2}\";\n    }\n}\n\n// Polymorphism in action\npublic static void ProcessShapes()\n{\n    Shape[] shapes = {\n        new Rectangle(5, 3),\n        new Circle(4),\n        new Rectangle(2, 8)\n    };\n    \n    foreach (Shape shape in shapes)\n    {\n        // Polymorphic method calls - correct implementation called at runtime\n        Console.WriteLine(shape.GetDescription());\n        Console.WriteLine($\"Perimeter: {shape.CalculatePerimeter():F2}\");\n        Console.WriteLine();\n    }\n}</code></pre><h5>Interface Polymorphism:</h5><pre><code>public interface IDrawable\n{\n    void Draw();\n    void Move(int x, int y);\n}\n\npublic interface IResizable\n{\n    void Resize(double factor);\n}\n\npublic class Button : IDrawable, IResizable\n{\n    public string Text { get; set; }\n    public int X { get; set; }\n    public int Y { get; set; }\n    public int Width { get; set; }\n    public int Height { get; set; }\n    \n    public void Draw()\n    {\n        Console.WriteLine($\"Drawing button '{Text}' at ({X}, {Y}) size {Width}x{Height}\");\n    }\n    \n    public void Move(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n    \n    public void Resize(double factor)\n    {\n        Width = (int)(Width * factor);\n        Height = (int)(Height * factor);\n    }\n}\n\n// Using interface polymorphism\npublic static void DrawAll(IEnumerable<IDrawable> drawables)\n{\n    foreach (var drawable in drawables)\n    {\n        drawable.Draw(); // Polymorphic call\n        \n        // Check if object also implements IResizable\n        if (drawable is IResizable resizable)\n        {\n            resizable.Resize(1.1); // Make it 10% bigger\n        }\n    }\n}</code></pre><h4>üèóÔ∏è Abstraction - Simplifying Complexity</h4><p>Abstraction involves hiding complex implementation details and exposing only the necessary functionality through interfaces and abstract classes.</p><h5>Abstract Classes vs Interfaces:</h5><pre><code>// Abstract class - provides partial implementation\npublic abstract class DatabaseConnection\n{\n    protected string _connectionString;\n    protected bool _isConnected;\n    \n    protected DatabaseConnection(string connectionString)\n    {\n        _connectionString = connectionString;\n        _isConnected = false;\n    }\n    \n    // Concrete method available to all derived classes\n    public bool IsConnected => _isConnected;\n    \n    // Abstract methods - must be implemented\n    public abstract void Connect();\n    public abstract void Disconnect();\n    public abstract IDataReader ExecuteQuery(string sql);\n    \n    // Virtual method with default implementation\n    public virtual void ExecuteNonQuery(string sql)\n    {\n        if (!_isConnected)\n            throw new InvalidOperationException(\"Not connected to database\");\n        \n        // Default implementation\n        Console.WriteLine($\"Executing: {sql}\");\n    }\n}\n\n// Interface - pure abstraction\npublic interface IRepository<T>\n{\n    Task<T> GetByIdAsync(int id);\n    Task<IEnumerable<T>> GetAllAsync();\n    Task<T> CreateAsync(T entity);\n    Task<T> UpdateAsync(T entity);\n    Task<bool> DeleteAsync(int id);\n}\n\n// Implementing both abstract class and interface\npublic class SqlServerConnection : DatabaseConnection\n{\n    public SqlServerConnection(string connectionString) : base(connectionString)\n    {\n    }\n    \n    public override void Connect()\n    {\n        // SQL Server specific connection logic\n        Console.WriteLine(\"Connecting to SQL Server...\");\n        _isConnected = true;\n    }\n    \n    public override void Disconnect()\n    {\n        Console.WriteLine(\"Disconnecting from SQL Server...\");\n        _isConnected = false;\n    }\n    \n    public override IDataReader ExecuteQuery(string sql)\n    {\n        if (!_isConnected)\n            throw new InvalidOperationException(\"Not connected\");\n        \n        // SQL Server specific query execution\n        Console.WriteLine($\"Executing SQL Server query: {sql}\");\n        return null; // Simplified for example\n    }\n}</code></pre><h4>üîÑ Method Overriding vs Method Hiding</h4><h5>Virtual/Override (Polymorphic):</h5><pre><code>public class Animal\n{\n    public virtual void MakeSound()\n    {\n        Console.WriteLine(\"Animal makes a generic sound\");\n    }\n}\n\npublic class Dog : Animal\n{\n    public override void MakeSound() // Polymorphic override\n    {\n        Console.WriteLine(\"Dog barks: Woof!\");\n    }\n}\n\nAnimal animal = new Dog();\nanimal.MakeSound(); // Output: \"Dog barks: Woof!\" (dynamic dispatch)</code></pre><h5>New Keyword (Method Hiding):</h5><pre><code>public class Cat : Animal\n{\n    public new void MakeSound() // Hides base method (not polymorphic)\n    {\n        Console.WriteLine(\"Cat meows: Meow!\");\n    }\n}\n\nAnimal animal = new Cat();\nanimal.MakeSound(); // Output: \"Animal makes a generic sound\" (static dispatch)\n\nCat cat = new Cat();\ncat.MakeSound(); // Output: \"Cat meows: Meow!\"</code></pre><h4>üéØ SOLID Principles in Practice</h4><h5>Single Responsibility Principle:</h5><pre><code>// ‚ùå Bad: Multiple responsibilities\npublic class User\n{\n    public string Name { get; set; }\n    public string Email { get; set; }\n    \n    public void Save() { /* Database logic */ }\n    public void SendEmail() { /* Email logic */ }\n    public void ValidateData() { /* Validation logic */ }\n}\n\n// ‚úÖ Good: Separated responsibilities\npublic class User\n{\n    public string Name { get; set; }\n    public string Email { get; set; }\n}\n\npublic class UserRepository\n{\n    public void Save(User user) { /* Database logic */ }\n}\n\npublic class EmailService\n{\n    public void SendWelcomeEmail(User user) { /* Email logic */ }\n}\n\npublic class UserValidator\n{\n    public bool IsValid(User user) { /* Validation logic */ }\n}</code></pre><h5>Liskov Substitution Principle:</h5><pre><code>// ‚úÖ Good: Square can substitute Rectangle without breaking functionality\npublic class Rectangle\n{\n    public virtual int Width { get; set; }\n    public virtual int Height { get; set; }\n    \n    public virtual int CalculateArea() => Width * Height;\n}\n\npublic class Square : Rectangle\n{\n    private int _side;\n    \n    public override int Width\n    {\n        get => _side;\n        set => _side = value;\n    }\n    \n    public override int Height\n    {\n        get => _side;\n        set => _side = value;\n    }\n}</code></pre><h4>‚ö†Ô∏è Common OOP Pitfalls</h4><ul><li><strong>God objects:</strong> Classes that do too much</li><li><strong>Inappropriate inheritance:</strong> Using inheritance when composition is better</li><li><strong>Breaking encapsulation:</strong> Exposing internal state unnecessarily</li><li><strong>Circular dependencies:</strong> Classes depending on each other</li><li><strong>Interface segregation violation:</strong> Interfaces that are too large</li><li><strong>Premature abstraction:</strong> Creating abstractions before they're needed</li></ul><h4>üèÜ Best Practices</h4><ul><li>Favor composition over inheritance</li><li>Program to interfaces, not implementations</li><li>Keep classes small and focused</li><li>Use meaningful names for classes and methods</li><li>Apply SOLID principles</li><li>Minimize public surface area</li><li>Use abstract classes for shared implementation</li><li>Use interfaces for contracts</li><li>Document complex inheritance hierarchies</li></ul><h4>üöÄ Modern C# OOP Features</h4><h5>Default Interface Methods (C# 8+):</h5><pre><code>public interface ILogger\n{\n    void Log(string message);\n    \n    // Default implementation\n    void LogError(string message)\n    {\n        Log($\"ERROR: {message}\");\n    }\n    \n    void LogWarning(string message)\n    {\n        Log($\"WARNING: {message}\");\n    }\n}</code></pre><h5>Records with Inheritance (C# 9+):</h5><pre><code>public abstract record Shape(double X, double Y);\npublic record Circle(double X, double Y, double Radius) : Shape(X, Y);\npublic record Rectangle(double X, double Y, double Width, double Height) : Shape(X, Y);</code></pre></div>",
      "code": "public abstract class Shape { public abstract double Area(); }\npublic class Rect: Shape { public double W,H; public override double Area()=> W*H; }",
      "quiz": [ {"q":"Which enables dynamic dispatch?","options":["override","new"],"answer":0} ]
    },
    {
      "id": 12,
      "tier": 1,
      "title": "Advanced OOP",
      "description": "Structs vs classes, enums, nested, partial.",
      "concepts": ["Structs vs Classes", "Enums", "Nested Classes", "Partial Classes/Methods"],
      "requirements": ["Define a struct and compare assignment semantics"],
      "theory": "<p>Structs are value types (copied by value), good for small immutable data. Enums map names to numeric constants. Partial types/methods split definitions across files.</p>",
      "code": "public struct Point { public int X,Y; }\npublic enum Color { Red, Green, Blue }",
      "quiz": [ {"q":"Struct assignment copies?","options":["Reference","Value"],"answer":1} ]
    },
    {
      "id": 13,
      "tier": 1,
      "title": "Built-in Collections",
      "description": "Arrays, List, Dictionary, Set, Queue, Stack, concurrent collections.",
      "concepts": ["Arrays", "List<T>", "Dictionary<K,V>", "HashSet<T>", "Queue<T>", "Stack<T>", "Concurrent Collections"],
      "requirements": ["Choose the right collection for a task"],
      "theory": "<p>Use List for dynamic arrays; Dictionary for key/value; HashSet for uniqueness; Queue/Stack for FIFO/LIFO. Concurrent collections support multi-threaded producers/consumers.</p>",
      "code": "var dict = new Dictionary<string,int>(); dict[\"a\"]=1;\nvar set = new HashSet<int>{1,2,2}; // {1,2}",
      "quiz": [ {"q":"Which preserves insertion order by default?","options":["List","Dictionary"],"answer":0} ]
    },
    {
      "id": 14,
      "tier": 1,
      "title": "Custom Collections",
      "description": "Implementing IEnumerable/IEnumerator; linked lists and trees.",
      "concepts": ["Implementing IEnumerable", "Linked Lists", "Trees"],
      "requirements": ["Implement GetEnumerator using yield"],
      "theory": "<p>Expose enumeration by implementing IEnumerable/IEnumerator. Nodes with Next references form linked lists; trees add hierarchical parent/children relations.</p>",
      "code": "public IEnumerable<int> Range(int n){ for(int i=0;i<n;i++) yield return i; }",
      "quiz": [ {"q":"yield return builds what?","options":["Iterator state machine","Array"],"answer":0} ]
    },
    {
      "id": 15,
      "tier": 1,
      "title": "Error Handling & Debugging",
      "description": "Exceptions, custom exceptions, breakpoints/logging.",
      "concepts": ["Exception Handling", "Custom Exceptions", "Debugging Techniques"],
      "requirements": ["Use try/catch/finally", "Add logging and breakpoints"],
      "theory": "<p>Throw exceptions for exceptional conditions; catch only when you can add context or recover. Custom exception types carry intent. Debugging tools and structured logging accelerate diagnosis.</p>",
      "code": "try { DoWork(); } catch(IOException ex){ Console.Error.WriteLine(ex.Message); throw; } finally { Cleanup(); }",
      "quiz": [ {"q":"Rethrowing preserves stack?","options":["throw ex;","throw;"],"answer":1} ]
    },
    {
      "id": 20,
      "tier": 2,
      "title": "Delegates & Events",
      "description": "Delegates, lambdas, Action/Func, events.",
      "concepts": ["Delegate Types", "Lambda Expressions", "Anonymous Methods", "Action/Func", "Event Handling"],
      "requirements": ["Declare a delegate and subscribe to an event"],
      "theory": "<p>Delegates are type-safe function pointers. Lambdas create inline delegates. Events wrap delegate lists with add/remove semantics for observers.</p>",
      "code": "public event EventHandler? Changed;\nvoid Raise()=> Changed?.Invoke(this, EventArgs.Empty);",
      "quiz": [ {"q":"Which delegate has no parameters and no return?","options":["Action","Func<int>"],"answer":0} ]
    },
    {
      "id": 21,
      "tier": 2,
      "title": "LINQ",
      "description": "Query vs method syntax, IEnumerable vs IQueryable, providers.",
      "concepts": ["Query Syntax", "Method Syntax", "IEnumerable<T> vs IQueryable<T>", "LINQ Providers"],
      "requirements": ["Compose a LINQ pipeline"],
      "theory": "<p>LINQ provides composable querying. IEnumerable executes in-memory; IQueryable builds expression trees for translation (e.g., SQL).</p>",
      "code": "var q = nums.Where(n=>n%2==0).Select(n=>n*n);",
      "quiz": [ {"q":"Which defers execution until enumerated?","options":["IEnumerable","List"],"answer":0} ]
    },
    {
      "id": 22,
      "tier": 2,
      "title": "Asynchronous Programming",
      "description": "async/await, Tasks, Parallel.ForEach, cancellation.",
      "concepts": ["async/await", "Task", "Parallel.ForEach", "CancellationToken"],
      "requirements": ["Await an async method", "Cancel work cooperatively"],
      "theory": "<p>Tasks represent ongoing work. async/await compose tasks without blocking threads. CancellationToken propagates cancel requests.</p>",
      "code": "async Task<int> GetAsync(){ await Task.Delay(10); return 42; }",
      "quiz": [ {"q":"Does async void belong in library code?","options":["Yes","No"],"answer":1} ]
    },
    {
      "id": 23,
      "tier": 2,
      "title": "ADO.NET",
      "description": "Connected/disconnected, transactions.",
      "concepts": ["SqlConnection", "SqlCommand", "DataTable", "Transactions"],
      "requirements": ["Open a connection and execute a command"],
      "theory": "<p>Connected model uses open connections and readers; disconnected uses DataTable/DataSet. Transactions ensure atomicity.</p>",
      "code": "using var con = new SqlConnection(cs); await con.OpenAsync(); using var cmd = new SqlCommand(\"SELECT 1\", con); var x = await cmd.ExecuteScalarAsync();",
      "quiz": [ {"q":"Which reads forward-only?","options":["DataTable","DataReader"],"answer":1} ]
    },
    {
      "id": 24,
      "tier": 2,
      "title": "Entity Framework Core",
      "description": "Code-first vs DB-first, migrations.",
      "concepts": ["Code-First", "Database-First", "Migrations"],
      "requirements": ["Add a DbContext and a DbSet", "Run a migration"],
      "theory": "<p>EF Core maps classes to tables. Code-First starts from C# models; Database-First scaffolds from an existing DB. Migrations evolve schema safely.</p>",
      "code": "public class AppDb: DbContext { public DbSet<Person> People => Set<Person>(); }",
      "quiz": [ {"q":"Which command adds a migration?","options":["dotnet ef migrations add","dotnet build"],"answer":0} ]
    },
    {
      "id": 25,
      "tier": 2,
      "title": "File I/O",
      "description": "Streams and serialization (JSON/XML/Binary).",
      "concepts": ["FileStream", "MemoryStream", "JSON", "XML", "Binary"],
      "requirements": ["Read and write a file", "Serialize to JSON"],
      "theory": "<p>Streams unify reading/writing bytes. Use System.Text.Json for JSON; XmlSerializer for XML. Always dispose streams.</p>",
      "code": "await File.WriteAllTextAsync(\"data.json\", JsonSerializer.Serialize(obj));",
      "quiz": [ {"q":"Which API serializes JSON in .NET?","options":["System.Text.Json","System.Xml"],"answer":0} ]
    },
    {
      "id": 26,
      "tier": 2,
      "title": "WPF Basics",
      "description": "XAML, layouts, controls, data binding.",
      "concepts": ["XAML Basics", "Layouts", "Controls", "Data Binding", "INotifyPropertyChanged"],
      "requirements": ["Bind a TextBox to a ViewModel property"],
      "theory": "<p>XAML declares UI; data binding connects UI to view models. Notify changes via INotifyPropertyChanged.</p>",
      "code": "<TextBox Text=\"{Binding Name, UpdateSourceTrigger=PropertyChanged}\"/>",
      "quiz": [ {"q":"Which interface notifies property changes?","options":["INotifyPropertyChanged","IEnumerable"],"answer":0} ]
    },
    {
      "id": 27,
      "tier": 2,
      "title": "Advanced WPF",
      "description": "Styles, templates, commands, MVVM.",
      "concepts": ["Styles", "Templates", "ICommand", "MVVM"],
      "requirements": ["Bind a Button to an ICommand"],
      "theory": "<p>Styles/ControlTemplates separate look from logic. MVVM organizes UI with bindings and commands. ICommand represents UI actions.</p>",
      "code": "<Button Command=\"{Binding SaveCommand}\" Content=\"Save\"/>",
      "quiz": [ {"q":"MVVM layers?","options":["Model-View-ViewModel","Model-View-Manager"],"answer":0} ]
    },
    {
      "id": 30,
      "tier": 3,
      "title": "ASP.NET Core Fundamentals",
      "description": "Middleware pipeline, Razor Pages vs MVC, Web API.",
      "concepts": ["Middleware Pipeline", "Razor Pages vs MVC", "RESTful APIs"],
      "requirements": ["Add a custom middleware", "Build a minimal API"],
      "theory": "<p>Requests flow through middleware. Razor Pages suit page-centric apps; MVC suits layered apps. Web API exposes REST endpoints.</p>",
      "code": "var app = WebApplication.Create(); app.Use(async (ctx,next)=>{ await next(); }); app.MapGet(\"/hello\", ()=>\"hi\");",
      "quiz": [ {"q":"Middleware order matters?","options":["Yes","No"],"answer":0} ]
    },
    {
      "id": 31,
      "tier": 3,
      "title": "Blazor",
      "description": "Components, binding, routing, DI, Server vs WASM.",
      "concepts": ["Components", "Data Binding", "Routing", "Dependency Injection", "Server vs WebAssembly"],
      "requirements": ["Create a component with @code and bind an input"],
      "theory": "<p>Blazor components render UI with Razor syntax. Server hosts components on the server; WASM runs in the browser.</p>",
      "code": "<input @bind=\"Name\" /> <p>@Name</p>",
      "quiz": [ {"q":"Blazor WASM runs where?","options":["Server","Browser"],"answer":1} ]
    },
    {
      "id": 32,
      "tier": 3,
      "title": "Security",
      "description": "AuthN (JWT, Cookies), AuthZ (Roles/Policies), HTTPS, CORS.",
      "concepts": ["Authentication", "Authorization", "HTTPS", "CORS"],
      "requirements": ["Protect a minimal API endpoint"],
      "theory": "<p>Authenticate users (cookies/JWT). Authorize via roles/policies. Always use HTTPS; configure CORS for cross-origin access.</p>",
      "code": "builder.Services.AddAuthorization(); app.MapGet(\"/secure\", ()=>\"ok\").RequireAuthorization();",
      "quiz": [ {"q":"Which guards cross-origin requests?","options":["CORS","CSR"],"answer":0} ]
    },
    {
      "id": 33,
      "tier": 3,
      "title": "Cross-Platform (Xamarin/MAUI)",
      "description": "Xamarin.Forms layouts/navigation, SQLite, DependencyService, OAuth, .NET MAUI intro.",
      "concepts": ["XAML Layouts", "Navigation", "SQLite.NET", "DependencyService", "OAuth 2.0", ".NET MAUI Intro"],
      "requirements": ["Create a simple page with navigation"],
      "theory": "<p>Xamarin.Forms uses XAML for UI and supports navigation stacks. MAUI is the evolution for .NET multi-platform apps.</p>",
      "code": "await Navigation.PushAsync(new DetailsPage());",
      "quiz": [ {"q":"MAUI stands for?","options":["Multi-platform App UI","Mobile App UI"],"answer":0} ]
    },
    {
      "id": 34,
      "tier": 3,
      "title": "Deployment & DevOps",
      "description": "Azure App Service, Docker, AWS Beanstalk, CI/CD (GitHub Actions, Azure DevOps), build book in CI.",
      "concepts": ["Azure App Service", "Docker Containers", "AWS Elastic Beanstalk", "GitHub Actions", "Azure DevOps", "Build book in CI"],
      "requirements": ["Add a CI workflow step", "Containerize a web API"],
      "theory": "<p>Continuous Integration builds and tests on every push. Containers bundle app + runtime. Cloud services host your apps globally.</p>",
      "code": "# GitHub Actions YAML & Dockerfile are part of this repo",
      "quiz": [ {"q":"Which file defines container steps?","options":["Dockerfile","package.json"],"answer":0} ]
    }
  ]
}